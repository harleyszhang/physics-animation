<!DOCTYPE html>
<html lang="zh">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>中学生物理可视化学习实验室</title>
  <link rel="preconnect" href="https://fonts.googleapis.com" />
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
  <link href="https://fonts.googleapis.com/css2?family=Noto+Serif:wght@400;600&family=Poppins:wght@400;600;700&display=swap" rel="stylesheet" />
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.0/css/all.min.css" integrity="sha512-st1bKsEBxV1QDF5P3uOQfTyJV7bgidh+NangNh4pW7x1YgnSUZXoqBYwygJyI072waEt2zB6rSk2qIMm4DPNig==" crossorigin="anonymous" referrerpolicy="no-referrer" />
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css" crossorigin="anonymous" referrerpolicy="no-referrer" />
  <style>
    :root {
      --primary: #4c7be5;
      --accent: #ff9b45;
      --bg: #eaf3ff;
      --text: #1d2a44;
      --panel: rgba(255, 255, 255, 0.92);
      --card: #ffffff;
    }
    * {
      box-sizing: border-box;
    }
    body {
      margin: 0;
      font-family: 'Poppins', 'Roboto', sans-serif;
      background: radial-gradient(circle at top, #f6fbff 0%, var(--bg) 60%, #fdfdfd 100%);
      color: var(--text);
      min-height: 100vh;
    }
    body::before {
      content: '';
      position: fixed;
      inset: 0;
      background: url('data:image/svg+xml,%3Csvg width="160" height="160" viewBox="0 0 200 200" xmlns="http://www.w3.org/2000/svg"%3E%3Ccircle cx="10" cy="10" r="2" fill="%23b9d4ff"/%3E%3Ccircle cx="110" cy="60" r="2" fill="%23d5e5ff"/%3E%3Ccircle cx="70" cy="150" r="3" fill="%23ffd5ad"/%3E%3C/svg%3E') repeat;
      opacity: 0.35;
      z-index: -2;
      animation: floatBg 40s linear infinite;
    }
    @keyframes floatBg {
      0% { transform: translateY(0); }
      50% { transform: translateY(-8px); }
      100% { transform: translateY(0); }
    }
    .app-shell {
      display: flex;
      min-height: 100vh;
      position: relative;
      overflow: hidden;
    }
    .glow {
      position: absolute;
      width: 420px;
      height: 420px;
      background: radial-gradient(circle, rgba(76,123,229,0.18), transparent 60%);
      border-radius: 50%;
      filter: blur(10px);
      animation: drift 18s ease-in-out infinite;
      z-index: -1;
    }
    .glow.one { top: 5%; left: -100px; }
    .glow.two { bottom: 5%; right: -120px; animation-delay: 4s; background: radial-gradient(circle, rgba(255,155,69,0.18), transparent 60%); }
    @keyframes drift {
      0% { transform: translate(0,0) scale(1); }
      50% { transform: translate(40px,-30px) scale(1.1); }
      100% { transform: translate(0,0) scale(1); }
    }
    .sidebar {
      width: 240px;
      background: var(--panel);
      border-right: 1px solid rgba(76,123,229,0.15);
      padding: 24px 18px 32px;
      display: flex;
      flex-direction: column;
      gap: 18px;
      backdrop-filter: blur(8px);
      position: sticky;
      top: 0;
      height: 100vh;
      overflow-y: auto;
      z-index: 2;
      flex-shrink: 0;
      transition: transform 0.3s ease, opacity 0.3s ease, width 0.3s ease, padding 0.3s ease;
    }
    .sidebar-overlay {
      position: fixed;
      inset: 0;
      background: rgba(17, 27, 53, 0.35);
      backdrop-filter: blur(3px);
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.3s ease;
      z-index: 1;
    }
    .sidebar-overlay.active {
      opacity: 1;
      pointer-events: auto;
    }
    .nav-toggle {
      position: fixed;
      top: 18px;
      left: 20px;
      width: 46px;
      height: 46px;
      border-radius: 50%;
      border: none;
      background: rgba(255,255,255,0.95);
      box-shadow: 0 10px 30px rgba(31,42,68,0.18);
      display: inline-flex;
      align-items: center;
      justify-content: center;
      font-size: 18px;
      color: var(--primary);
      z-index: 6;
      cursor: pointer;
    }
    .nav-toggle:active {
      transform: scale(0.95);
    }
    .sidebar-close {
      border: none;
      background: rgba(255,255,255,0.9);
      border-radius: 50%;
      width: 40px;
      height: 40px;
      position: absolute;
      top: 18px;
      right: 16px;
      font-size: 16px;
      color: var(--primary);
      box-shadow: 0 8px 16px rgba(31,42,68,0.18);
      display: inline-flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      transition: transform 0.2s ease;
    }
    .sidebar-close:hover {
      transform: rotate(6deg);
    }
    .logo {
      display: flex;
      align-items: center;
      gap: 12px;
    }
    .logo i {
      font-size: 34px;
      color: var(--accent);
      animation: pulse 3s ease-in-out infinite;
    }
    .logo h1 {
      margin: 0;
      font-size: 20px;
    }
    .logo p {
      margin: 2px 0 0;
      color: #62729d;
      font-size: 12px;
    }
    @keyframes pulse {
      0%, 100% { transform: scale(1); }
      50% { transform: scale(1.08); }
    }
    .sidebar h2 {
      font-size: 15px;
      margin: 12px 0 8px;
      color: #4d5d86;
    }
    .outline {
      display: flex;
      flex-direction: column;
      gap: 14px;
    }
    .outline-group {
      border-radius: 18px;
      background: rgba(255,255,255,0.95);
      box-shadow: 0 20px 35px rgba(39,74,143,0.08);
      overflow: hidden;
      transition: transform 0.2s ease;
    }
    .outline-group:hover {
      transform: translateY(-2px);
    }
    .outline-group-header {
      width: 100%;
      border: none;
      background: none;
      padding: 12px 16px;
      display: flex;
      align-items: center;
      justify-content: space-between;
      cursor: pointer;
      color: var(--primary);
      font-weight: 600;
    }
    .outline-group-header span {
      display: flex;
      align-items: center;
      gap: 8px;
    }
    .outline-group.collapsed .outline-group-header i:first-child {
      transform: rotate(-90deg);
    }
    .outline-items {
      max-height: 600px;
      transition: max-height 0.25s ease;
    }
    .outline-group.collapsed .outline-items {
      max-height: 0;
      overflow: hidden;
    }
    .outline-item {
      width: 100%;
      border: none;
      background: none;
      text-align: left;
      padding: 10px 22px;
      font-size: 14px;
      cursor: pointer;
      border-left: 3px solid transparent;
      transition: background 0.2s ease, border-color 0.2s ease, color 0.2s;
    }
    .outline-item:hover {
      background: rgba(76,123,229,0.07);
    }
    .outline-item.active {
      border-color: var(--accent);
      background: rgba(255,155,69,0.12);
      color: var(--accent);
      font-weight: 600;
    }
    .main-panel {
      flex: 1;
      padding: 28px 30px 40px;
      display: flex;
      flex-direction: column;
      gap: 26px;
    }
    @media (min-width: 901px) {
      .sidebar {
        transform: translateX(0);
      }
      body.nav-collapsed .sidebar {
        transform: translateX(-260px);
        opacity: 0;
        width: 0;
        padding: 0;
        border: none;
        pointer-events: none;
      }
      body.nav-collapsed .main-panel {
        padding-left: clamp(24px, 5vw, 40px);
      }
      body.nav-collapsed #sidebarOverlay {
        display: none;
      }
    }
    .card {
      background: var(--card);
      border-radius: 26px;
      box-shadow: 0 35px 55px rgba(76,123,229,0.18);
      padding: 26px 28px 30px;
      position: relative;
      overflow: hidden;
    }
    .card::after {
      content: '';
      position: absolute;
      inset: 12px;
      border-radius: 20px;
      border: 1px solid rgba(76,123,229,0.08);
      pointer-events: none;
    }
    .visual-header {
      display: flex;
      justify-content: space-between;
      flex-wrap: wrap;
      gap: 12px;
      align-items: center;
      position: relative;
      z-index: 1;
    }
    .badge {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      padding: 6px 14px;
      border-radius: 20px;
      background: rgba(76,123,229,0.15);
      color: var(--primary);
      font-size: 12px;
      font-weight: 600;
    }
    .visual-header h2 {
      margin: 6px 0 0;
      font-size: 26px;
    }
    .textbook-btn,
    .random-btn,
    .sound-btn {
      border: none;
      background: linear-gradient(135deg, #ffb567, #ff8b2d);
      color: #fff;
      padding: 10px 20px;
      border-radius: 24px;
      font-weight: 600;
      cursor: pointer;
      box-shadow: 0 16px 30px rgba(255,155,69,0.35);
      transition: transform 0.2s ease, box-shadow 0.2s;
    }
    .textbook-btn {
      background: linear-gradient(135deg, #5ac4ff, #4c7be5);
      box-shadow: 0 16px 30px rgba(90,196,255,0.35);
    }
    .textbook-btn:hover {
      transform: translateY(-3px);
      box-shadow: 0 20px 40px rgba(90,196,255,0.45);
    }
    .sound-btn {
      background: linear-gradient(135deg, #ffc56d, #ff9b45);
      display: inline-flex;
      align-items: center;
      gap: 6px;
    }
    .sound-btn.active {
      background: linear-gradient(135deg, #50d890, #2fb06a);
      box-shadow: 0 20px 40px rgba(58,190,122,0.45);
    }
    .random-btn:hover {
      transform: translateY(-3px);
      box-shadow: 0 20px 40px rgba(255,155,69,0.4);
    }
    .random-btn.active {
      animation: wiggle 0.4s ease;
    }
    @keyframes wiggle {
      0% { transform: rotate(0deg); }
      25% { transform: rotate(4deg); }
      50% { transform: rotate(-4deg); }
      75% { transform: rotate(2deg); }
      100% { transform: rotate(0deg); }
    }
    canvas {
      width: 100%;
      height: 320px;
      background: linear-gradient(135deg, #f3f9ff, #fffaf5);
      border-radius: 22px;
      margin: 18px 0;
      border: 1px dashed rgba(76,123,229,0.25);
      position: relative;
      z-index: 1;
    }
    .sliders {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
      gap: 18px;
      position: relative;
      z-index: 1;
    }
    .slider-control {
      background: rgba(239,246,255,0.95);
      border-radius: 20px;
      padding: 14px 16px;
      display: flex;
      flex-direction: column;
      gap: 8px;
      box-shadow: inset 0 0 0 1px rgba(76,123,229,0.08);
    }
    .slider-control span {
      font-size: 13px;
      color: #5c6d96;
    }
    .slider-control input[type="range"] {
      width: 100%;
      accent-color: var(--accent);
    }
    .slider-input-row {
      display: flex;
      align-items: center;
      gap: 10px;
    }
    .slider-control input[type="number"] {
      width: 80px;
      padding: 4px 6px;
      border-radius: 10px;
      border: 1px solid rgba(76,123,229,0.25);
      background: #fff;
      font-family: 'Poppins', sans-serif;
      font-size: 13px;
      color: #2a3760;
    }
    .slider-value {
      text-align: right;
      font-weight: 600;
      color: var(--accent);
      font-size: 13px;
    }
    .slider-ticks {
      position: relative;
      height: 18px;
      margin-top: 2px;
    }
    .slider-tick {
      position: absolute;
      transform: translateX(-50%);
      font-size: 10px;
      color: #7a8aa6;
      white-space: nowrap;
    }
    .formula-derivation .r1 { color: #c62828; font-weight: 600; }
    .formula-derivation .r2 { color: #1565c0; font-weight: 600; }
    .formula-derivation .u  { color: #2e7d32; font-weight: 600; }
    .practice-progress-wrap { margin-top: 10px; }
    .practice-progress-bar {
      height: 8px;
      border-radius: 4px;
      background: rgba(0,0,0,0.08);
      overflow: hidden;
      margin-bottom: 6px;
    }
    .practice-progress-fill {
      height: 100%;
      border-radius: 4px;
      transition: width 0.2s ease, background 0.2s ease;
    }
    .practice-progress-text { font-size: 12px; color: #5b6690; }
    .info-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
      gap: 18px;
      margin-top: 12px;
      position: relative;
      z-index: 1;
    }
    .info-block {
      background: #f6f9ff;
      border-radius: 18px;
      padding: 14px 16px;
      min-height: 140px;
      box-shadow: inset 0 0 0 1px rgba(76,123,229,0.06);
    }
    .info-block h3 {
      margin: 0 0 6px;
      font-size: 15px;
      color: var(--primary);
    }
    .math-text {
      font-family: 'Noto Serif', serif;
      letter-spacing: 0.5px;
    }
    .formula-main {
      font-size: 20px;
      font-weight: 700;
      color: var(--primary);
      margin-bottom: 4px;
    }
    .math-frac {
      display: inline-flex;
      flex-direction: column;
      align-items: center;
      font-size: 0.95em;
      margin: 0 4px;
    }
    .math-frac span {
      padding: 0 6px;
    }
    .math-frac .top {
      border-bottom: 1px solid currentColor;
    }
    .math-frac .bottom {
      margin-top: 2px;
    }
    .formula-extras {
      margin: 6px 0 0 16px;
      padding-left: 6px;
      color: #4d5d86;
    }
    .info-body {
      font-size: 13px;
      line-height: 1.6;
      color: #4f5c84;
    }
    .animation-desc {
      background: rgba(76, 123, 229, 0.06);
      padding: 12px 14px;
      border-radius: 12px;
      border-left: 3px solid var(--accent);
      margin: 8px 0;
      line-height: 1.65;
    }
    .summary-main {
      margin: 0 0 6px;
      font-weight: 600;
      color: #2a3760;
    }
    .teach-list {
      margin: 4px 0 6px 16px;
      padding-left: 6px;
      color: #4c5e8e;
    }
    .teach-list li { margin-bottom: 4px; }
    .detail-extra {
      display: inline-block;
      margin-top: 6px;
      padding: 6px 10px;
      border-radius: 12px;
      background: rgba(76,123,229,0.08);
      color: #2f3f66;
      font-size: 12px;
      font-weight: 600;
    }
    .formula-detail {
      margin: 0;
      font-size: 13px;
      line-height: 1.6;
      color: #4d5d86;
    }
    .practice-block {
      display: flex;
      gap: 12px;
      align-items: center;
    }
    .practice-no-task {
      padding: 20px 16px;
      color: #5b6690;
      font-size: 13px;
      line-height: 1.6;
      background: rgba(76,123,229,0.06);
      border-radius: 12px;
      border-left: 3px solid rgba(76,123,229,0.3);
    }
    .practice-indicator {
      width: 90px;
      height: 90px;
      position: relative;
    }
    .practice-indicator svg {
      transform: rotate(-90deg);
    }
    .practice-indicator circle {
      fill: none;
      stroke-width: 10;
      stroke-linecap: round;
    }
    .practice-value {
      position: absolute;
      inset: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      font-weight: 700;
      color: var(--primary);
      font-size: 14px;
    }
    .practice-status {
      font-size: 13px;
      color: #56618a;
      margin-top: 4px;
      line-height: 1.5;
    }
    .practice-btns {
      display: flex;
      gap: 8px;
      margin-top: 8px;
    }
    .practice-btns button {
      border: none;
      background: rgba(255,155,69,0.16);
      color: var(--accent);
      padding: 6px 12px;
      border-radius: 14px;
      cursor: pointer;
      font-size: 12px;
      font-weight: 600;
    }
    .path-section .path-track {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      align-items: center;
      position: relative;
      z-index: 1;
    }
    .path-node {
      border: 2px solid transparent;
      border-radius: 28px;
      padding: 10px 18px;
      background: rgba(76,123,229,0.08);
      color: var(--primary);
      font-weight: 600;
      cursor: pointer;
      transition: transform 0.2s ease, border-color 0.2s ease, background 0.2s ease;
    }
    .path-node.active {
      border-color: var(--accent);
      background: rgba(255,155,69,0.15);
      color: var(--accent);
      box-shadow: 0 12px 26px rgba(255,155,69,0.35);
    }
    .path-node:hover {
      transform: translateY(-3px);
    }
    .path-arrow {
      color: var(--primary);
      font-size: 18px;
    }
    .textbook-modal {
      position: fixed;
      inset: 0;
      background: rgba(9,17,35,0.72);
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 20px;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.3s ease;
      z-index: 10;
    }
    .textbook-modal.open {
      opacity: 1;
      pointer-events: auto;
    }
    .textbook-dialog {
      background: #ffffff;
      border-radius: 26px;
      max-width: 720px;
      width: min(90vw, 760px);
      max-height: 80vh;
      overflow-y: auto;
      padding: 28px 30px;
      position: relative;
      box-shadow: 0 35px 65px rgba(15,23,42,0.35);
      animation: scaleUp 0.35s ease;
    }
    .textbook-dialog p {
      line-height: 1.7;
      color: #2a3760;
    }
    .textbook-dialog ul {
      margin-left: 20px;
      color: #40507a;
    }
    .textbook-close {
      position: absolute;
      top: 16px;
      right: 18px;
      width: 38px;
      height: 38px;
      border-radius: 50%;
      border: none;
      background: rgba(76,123,229,0.12);
      color: var(--primary);
      font-size: 16px;
      cursor: pointer;
    }
    .more-practice-dialog {
      padding: 28px 32px 32px;
    }
    .more-practice-title {
      margin: 0 0 20px 0;
      font-size: 1.2rem;
      color: var(--text);
    }
    .more-practice-content {
      max-height: 60vh;
      overflow-y: auto;
    }
    .extra-practice-item {
      background: #f5f8fc;
      border-radius: 12px;
      padding: 14px 18px;
      margin-bottom: 12px;
      border-left: 4px solid var(--primary);
    }
    .extra-practice-item .prompt { font-weight: 600; color: #1d2a44; margin-bottom: 8px; }
    .extra-practice-item .answer { color: #40507a; font-size: 0.95rem; }
    .formula-main .katex { font-size: 1.1em; }
    .formula-main { overflow-x: auto; max-width: 100%; }
    .formula-main .formula-line { display: block; margin: 6px 0; }
    @keyframes scaleUp {
      0% { transform: scale(0.92); opacity: 0; }
      100% { transform: scale(1); opacity: 1; }
    }
    @media (min-width: 901px) {
      body:not(.nav-collapsed) #navToggle {
        left: 260px;
      }
      body.nav-collapsed #navToggle {
        left: 20px;
      }
    }
    @media (max-width: 900px) {
      .nav-toggle {
        display: inline-flex;
      }
      .sidebar {
        position: fixed;
        left: 0;
        top: 0;
        height: 100vh;
        transform: translateX(-105%);
        width: 260px;
        max-width: 85vw;
        box-shadow: 20px 0 45px rgba(31,42,68,0.2);
        transition: transform 0.3s ease;
        z-index: 5;
      }
      .sidebar.open {
        transform: translateX(0);
      }
      .main-panel {
        padding: 20px;
        width: 100%;
      }
    }
  </style>
</head>
<body>
  <button id="navToggle" class="nav-toggle" aria-label="切换知识大纲" title="切换知识大纲"><i class="fa-solid fa-bars"></i></button>
  <div id="sidebarOverlay" class="sidebar-overlay"></div>
  <div class="glow one"></div>
  <div class="glow two"></div>
  <div class="app-shell">
    <aside class="sidebar">
      <button id="sidebarClose" class="sidebar-close" aria-label="折叠知识大纲" title="折叠知识大纲"><i class="fa-solid fa-xmark"></i></button>
      <div class="logo">
        <i class="fa-solid fa-atom"></i>
        <div>
          <h1>物理树屋</h1>
          <p>Physics Playground</p>
        </div>
      </div>
      <h2><i class="fa-solid fa-diagram-project"></i> 知识大纲</h2>
      <div id="outlineContainer" class="outline"></div>
    </aside>

    <main class="main-panel">
      <section class="card visual-card">
        <div class="visual-header">
          <div>
            <span class="badge" id="visualBadge"><i class="fa-solid fa-layer-group"></i> 力学</span>
            <h2 id="visualTitle">牛顿第二定律</h2>
          </div>
          <div style="display:flex;gap:8px;flex-wrap:wrap;">
            <button id="textbookBtn" class="textbook-btn"><i class="fa-solid fa-book-open"></i> 课本讲解</button>
            <button id="randomBtn" class="random-btn"><i class="fa-solid fa-shuffle"></i> 随机示例</button>
            <button id="soundToggle" class="sound-btn" title="开启声音"><i class="fa-solid fa-volume-xmark"></i> 声音关</button>
          </div>
        </div>
        <canvas id="principleCanvas"></canvas>
        <div id="sliderControls" class="sliders"></div>
        <div class="info-grid">
          <div class="info-block" id="summaryBlock">
            <h3><i class="fa-solid fa-lightbulb"></i> 知识总结</h3>
            <div id="summaryText" class="info-body"></div>
          </div>
          <div class="info-block" id="formulaBlock">
            <h3><i class="fa-solid fa-divide"></i> 原理·公式</h3>
            <div id="formulaText" class="info-body"></div>
          </div>
          <div class="info-block" id="practiceBlock">
            <h3><i class="fa-solid fa-flask"></i> 可视化练习题</h3>
            <div id="practiceHasTask" class="practice-block">
              <div class="practice-indicator">
                <svg width="90" height="90">
                  <circle cx="45" cy="45" r="34" stroke="rgba(76,123,229,0.2)"></circle>
                  <circle id="practiceRing" cx="45" cy="45" r="34" stroke="var(--accent)" stroke-dasharray="213" stroke-dashoffset="213"></circle>
                </svg>
                <div class="practice-value" id="practiceValue">0%</div>
              </div>
              <div>
                <p id="practicePrompt">调整滑块完成目标。</p>
                <p class="practice-status" id="practiceStatus">努力使当前结果接近目标值。</p>
                <div id="practiceProgressWrap" class="practice-progress-wrap" style="display:none">
                  <div class="practice-progress-bar"><div id="practiceProgressFill" class="practice-progress-fill"></div></div>
                  <span id="practiceProgressText" class="practice-progress-text"></span>
                </div>
                <div class="practice-btns">
                  <button id="practiceReset"><i class="fa-solid fa-arrows-rotate"></i> 重新出题</button>
                  <button id="practiceExplain"><i class="fa-solid fa-circle-info"></i> 教学提示</button>
                  <button id="morePracticeBtn"><i class="fa-solid fa-list-check"></i> 更多练习题</button>
                </div>
              </div>
            </div>
            <div id="practiceNoTask" class="practice-no-task" style="display:none">本模块暂无可视化练习，请通过调节滑块探索规律。</div>
          </div>
        </div>
      </section>

      <section class="card path-section">
        <div class="visual-header">
          <div>
            <span class="badge"><i class="fa-solid fa-route"></i> 学习路线</span>
            <h2>可视化物理学习路径</h2>
          </div>
          <p style="margin:0;color:#5b6690;font-size:13px;">点击节点即可跳转到推荐的知识模块</p>
        </div>
        <div id="learningPath" class="path-track"></div>
      </section>
    </main>
  </div>
  <div id="textbookModal" class="textbook-modal">
    <div class="textbook-dialog">
      <button id="textbookClose" class="textbook-close"><i class="fa-solid fa-xmark"></i></button>
      <div id="textbookContent"></div>
    </div>
  </div>
  <div id="morePracticeModal" class="textbook-modal">
    <div class="textbook-dialog more-practice-dialog">
      <button id="morePracticeClose" class="textbook-close"><i class="fa-solid fa-xmark"></i></button>
      <h3 class="more-practice-title"><i class="fa-solid fa-list-check"></i> 更多练习题</h3>
      <div id="morePracticeContent" class="more-practice-content"></div>
    </div>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
  <script>
    const g = 9.8;
    const n1 = 1.0;
    const n2 = 1.33;
    const kElectro = 8.99e9;
    const MOBILE_BREAKPOINT = 900;

    const clamp = (value, min, max) => Math.min(Math.max(value, min), max);
    const toRad = (deg) => deg * Math.PI / 180;

    const escapeHTML = (str) =>
      str.replace(/&/g, '&amp;')
         .replace(/</g, '&lt;')
         .replace(/>/g, '&gt;');

    const audioEngine = (() => {
      let ctx = null;
      let gain = null;
      let osc = null;
      let enabled = false;
      const ensure = () => {
        if (ctx) return;
        const AudioContextClass = window.AudioContext || window.webkitAudioContext;
        if (!AudioContextClass) return;
        ctx = new AudioContextClass();
        osc = ctx.createOscillator();
        gain = ctx.createGain();
        osc.type = 'sine';
        gain.gain.value = 0;
        osc.connect(gain).connect(ctx.destination);
        osc.start();
      };
      return {
        setEnabled(state) {
          enabled = state;
          if (!state) {
            if (gain && ctx) gain.gain.setTargetAtTime(0, ctx.currentTime, 0.08);
            return;
          }
          ensure();
          if (ctx && ctx.state === 'suspended') ctx.resume();
        },
        update(signature) {
          if (!enabled || !gain || !ctx || !signature) return;
          const freq = clamp(signature.freq || 220, 60, 2000);
          const targetVol = clamp(signature.volume || 0.05, 0, 0.5);
          const now = ctx.currentTime;
          gain.gain.setTargetAtTime(targetVol, now, 0.03);
          osc.frequency.setTargetAtTime(freq, now, 0.02);
        },
        isEnabled() {
          return enabled;
        }
      };
    })();

    function formatFormula(text = '') {
      if (!text) return '';
      let html = escapeHTML(text);
      html = html.replace(/\\times/g, '&times;')
                 .replace(/\\cdot/g, '&middot;')
                 .replace(/\\quad/g, ' ')
                 .replace(/\\sqrt\{([^}]*)\}/g, (_, c) => '√(' + c + ')')
                 .replace(/\\text\{([^}]*)\}/g, '$1')
                 .replace(/\\\\Rightarrow/g, '⇒')
                 .replace(/\\Rightarrow/g, '⇒')
                 .replace(/\\to/g, '→')
                 .replace(/\\rightarrow/g, '→')
                 .replace(/\\vec\{([^}]*)\}/g, '$1')
                 .replace(/\\lambda/g, 'λ')
                 .replace(/\\mp/g, '∓');
      const symbolMap = [
        ['\\\\Delta', 'Δ'],
        ['\\\\alpha', 'α'],
        ['\\\\beta', 'β'],
        ['\\\\omega', 'ω'],
        ['\\\\theta', 'θ'],
        ['\\\\varphi', 'φ'],
        ['\\\\varepsilon', 'ε'],
        ['\\\\sin', 'sin'],
        ['\\\\cos', 'cos'],
        ['\\\\tan', 'tan'],
        ['\\\\pm', '±'],
        ['\\\\propto', '∝'],
        ['\\\\cdots', '⋯'],
        ['\\\\pi', 'π'],
        ['\\\\sqrt', '√'],
        ['\\\\Phi', 'Φ'],
        ['\\\\sigma', 'σ'],
        ['\\\\gamma', 'γ']
      ];
      symbolMap.forEach(([pattern, symbol]) => {
        html = html.replace(new RegExp(pattern, 'g'), symbol);
      });
      html = replaceFractions(html);
      html = html.replace(/\^\{([^}]*)\}/g, '<sup>$1</sup>');
      html = html.replace(/_\{([^}]*)\}/g, '<sub>$1</sub>');
      return html;
    }

    function replaceFractions(str) {
      const extractGroup = (text, start) => {
        if (text[start] !== '{') return null;
        let depth = 0;
        for (let i = start; i < text.length; i++) {
          const char = text[i];
          if (char === '{') depth++;
          else if (char === '}') {
            depth--;
            if (depth === 0) {
              return { content: text.slice(start + 1, i), end: i + 1 };
            }
          }
        }
        return null;
      };
      let result = '';
      let i = 0;
      while (i < str.length) {
        if (str.slice(i, i + 5) === '\\frac') {
          const numGroup = extractGroup(str, i + 5);
          if (!numGroup) { result += '\\frac'; i += 5; continue; }
          const denGroup = extractGroup(str, numGroup.end);
          if (!denGroup) { result += '\\frac'; i += 5; continue; }
          result += `<span class="math-frac"><span class="top">${numGroup.content}</span><span class="bottom">${denGroup.content}</span></span>`;
          i = denGroup.end;
        } else {
          result += str[i];
          i++;
        }
      }
      return result;
    }

    function roundedRectPath(ctx, x, y, width, height, radius) {
      const r = Math.min(radius, width / 2, height / 2);
      ctx.beginPath();
      ctx.moveTo(x + r, y);
      ctx.lineTo(x + width - r, y);
      ctx.quadraticCurveTo(x + width, y, x + width, y + r);
      ctx.lineTo(x + width, y + height - r);
      ctx.quadraticCurveTo(x + width, y + height, x + width - r, y + height);
      ctx.lineTo(x + r, y + height);
      ctx.quadraticCurveTo(x, y + height, x, y + height - r);
      ctx.lineTo(x, y + r);
      ctx.quadraticCurveTo(x, y, x + r, y);
      ctx.closePath();
    }

    function drawArrow(ctx, fromX, fromY, toX, toY, color, width = 3) {
      const headLen = 12;
      const angle = Math.atan2(toY - fromY, toX - fromX);
      ctx.save();
      ctx.strokeStyle = color;
      ctx.fillStyle = color;
      ctx.lineWidth = width;
      ctx.beginPath();
      ctx.moveTo(fromX, fromY);
      ctx.lineTo(toX, toY);
      ctx.stroke();
      ctx.beginPath();
      ctx.moveTo(toX, toY);
      ctx.lineTo(toX - headLen * Math.cos(angle - Math.PI / 6), toY - headLen * Math.sin(angle - Math.PI / 6));
      ctx.lineTo(toX - headLen * Math.cos(angle + Math.PI / 6), toY - headLen * Math.sin(angle + Math.PI / 6));
      ctx.closePath();
      ctx.fill();
      ctx.restore();
    }

    function computeAudioSignature(id, params) {
      switch (id) {
        case 'newton': {
          const acc = params.force / params.mass;
          return { freq: 180 + acc * 40, volume: clamp(acc / 10, 0.05, 0.45) };
        }
        case 'ohm': {
          const current = params.voltage / Math.max(params.resistance, 0.2);
          return { freq: 160 + current * 120, volume: clamp(current / 4, 0.05, 0.4) };
        }
        case 'series': {
          const current = params.voltage / Math.max(params.r1 + params.r2, 0.2);
          return { freq: 140 + current * 100, volume: clamp(current / 3, 0.05, 0.35) };
        }
        case 'capacitor': {
          const tau = (params.resistance * 1000) * (params.capacitance / 1000);
          return { freq: 120 + (1 / Math.max(tau, 0.1)) * 260, volume: 0.06 + 0.04 * Math.sin(params.time) };
        }
        case 'fuse': {
          const current = params.voltage / Math.max(params.load, 0.1);
          return { freq: 220 + current * 60, volume: clamp(current / params.fuseRating, 0.05, 0.45) };
        }
        case 'reflection':
        case 'refraction':
          return { freq: 350 + (params.angle || 0) * 3, volume: 0.07 };
        case 'buoyancy': {
          return { freq: 120 + (params.density || 1) * 40, volume: 0.06 + 0.03 * Math.sin(params.time * 1.5) };
        }
        case 'pressure': {
          const pressure = (params.density || 1) * 1000 * g * (params.depth || 1);
          return { freq: 140 + pressure / 4000, volume: 0.07 + Math.min(pressure / 400000, 0.2) };
        }
        case 'projectile': {
          const angle = toRad(params.angle || 0);
          const v = params.speed || 0;
          const vy = v * Math.sin(angle);
          const totalTime = Math.max(0.2, (vy * 2) / g);
          const t = params.time ? (params.time % totalTime) : 0;
          const height = vy * t - 0.5 * g * t * t;
          return {
            freq: 220 + Math.max(height, 0) * 5 + vy * 12,
            volume: 0.08 + Math.min(v / 50, 0.25)
          };
        }
        case 'circular': {
          const ac = (params.speed || 1) ** 2 / Math.max(params.radius || 1, 0.5);
          return { freq: 180 + ac * 25, volume: 0.06 + Math.min(ac / 25, 0.28) };
        }
        case 'reaction': {
          const thrust = (params.pressure || 1) * 35;
          return { freq: 220 + thrust * 0.8, volume: 0.07 + Math.min(thrust / 250, 0.35) };
        }
        case 'sound': {
          const f = clamp(params.frequency || 440, 200, 800);
          const amp = clamp(params.amplitude || 1, 0.6, 1.6);
          return { freq: f, volume: 0.05 + (amp - 0.6) * 0.2 };
        }
        case 'resonance': {
          const voiceF = params.voiceFreq || 900;
          const glassF = params.glassFreq || 850;
          const diff = Math.abs(voiceF - glassF);
          const resonance = clamp(1 - diff / 120, 0, 1);
          return {
            freq: voiceF,
            volume: 0.04 + resonance * 0.25
          };
        }
        case 'harmonic': {
          const f = params.frequency || 1;
          return { freq: 200 + f * 150, volume: 0.05 + (params.amplitude || 40) / 400 };
        }
        case 'doppler': {
          const vSound = 340;
          const vSrc = params.sourceSpeed || 0;
          const f0 = params.frequency || 440;
          const fApproach = f0 * vSound / Math.max(vSound - vSrc, 1);
          return { freq: fApproach, volume: 0.06 + Math.min(vSrc / 400, 0.2) };
        }
        case 'wave': {
          const f = params.frequency || 2;
          return { freq: 180 + f * 80, volume: 0.05 + (params.amplitude || 35) / 500 };
        }
        case 'lens': {
          return { freq: 260 + (params.intensity || 1) * 20, volume: 0.06 + (params.intensity || 1) / 25 };
        }
        case 'dispersion':
          return { freq: 320 + (params.spread || 1) * 40, volume: 0.06 + (params.spread || 1) / 18 };
        case 'conduction':
          return { freq: 150 + (params.temperature || 20) * 2, volume: 0.05 + params.time / 25 };
        case 'phase':
          return { freq: 200 + (params.energy || 0), volume: 0.06 + (params.energy || 0) / 500 };
        case 'photoelectric':
          return { freq: 280 + (params.time * 15 % 80), volume: 0.06 };
        case 'atomicLevel':
          return { freq: 320 + Math.sin(params.time * 2) * 40, volume: 0.05 };
        case 'fission':
          return { freq: 120 + (params.time % 2) * 60, volume: 0.06 };
        case 'gravityOrbit':
          return { freq: 200 + Math.sin(params.time * 0.2) * 50, volume: 0.05 };
        case 'blackHole':
          return { freq: 160 + (params.time * 0.1 % 1) * 80, volume: 0.05 };
        case 'hydroPower':
          return { freq: 220 + Math.sin(params.time * 1.5) * 50, volume: 0.06 };
        case 'eddyCurrent':
          return { freq: 180 + Math.sin(params.time * 0.5) * 25, volume: 0.05 };
        default: {
          const sliderValues = Object.values(params).filter((v) => typeof v === 'number' && v < 10000);
          const base = sliderValues.length ? sliderValues[0] : 1;
          return { freq: 150 + base * 10, volume: 0.06 };
        }
      }
    }

    function drawNewton(ctx, w, h, params) {
      const groundY = h * 0.8;
      ctx.save();
      const sky = ctx.createLinearGradient(0, 0, 0, groundY);
      sky.addColorStop(0, '#b1d4ff');
      sky.addColorStop(1, '#e8f1ff');
      ctx.fillStyle = sky;
      ctx.fillRect(0, 0, w, groundY);
      ctx.fillStyle = '#9ea7ba';
      ctx.fillRect(0, groundY, w, h - groundY);
      ctx.fillStyle = '#ffffff';
      ctx.globalAlpha = 0.15;
      for (let i = 0; i < 5; i++) {
        ctx.fillRect(i * 120, groundY - 40, 80, 160);
      }
      ctx.globalAlpha = 1;

      const baseMass = 25;
      const heavyMass = baseMass + params.mass * 25;
      const carts = [
        { label: '空车', mass: baseMass, color: '#f8fbff', stripe: '#94c1ff', x: w * 0.18 },
        { label: '满载', mass: heavyMass, color: '#fff1d6', stripe: '#f59f45', x: w * 0.18 }
      ];
      const t = (params.time % 4);
      const force = params.force;
      const scale = 55;

      carts.forEach((cart, index) => {
        const acc = force / cart.mass;
        const displacement = 0.5 * acc * t * t * scale;
        const cartX = cart.x + displacement + index * 0.28 * w;
        const cartY = groundY - 65;

        // shoppers in background
        ctx.fillStyle = 'rgba(255,255,255,0.35)';
        ctx.beginPath();
        ctx.arc(cartX - 140, groundY - 60 + Math.sin(params.time + index) * 2, 16, 0, Math.PI * 2);
        ctx.fill();
        ctx.fillRect(cartX - 148, groundY - 60, 16, 40);

        // cart basket
        ctx.fillStyle = cart.color;
        roundedRectPath(ctx, cartX, cartY - 30, 140, 55, 18);
        ctx.fill();
        ctx.strokeStyle = '#c5ccd8';
        ctx.lineWidth = 2;
        ctx.stroke();
        ctx.fillStyle = cart.stripe;
        ctx.fillRect(cartX + 8, cartY - 12, 124, 10);
        ctx.fillStyle = '#d9dfea';
        ctx.fillRect(cartX + 10, cartY + 8, 120, 6);
        ctx.fillStyle = '#a7b4ca';
        ctx.fillRect(cartX - 8, cartY + 6, 10, 45);

        // load crates for heavy cart
        if (index === 1) {
          ctx.fillStyle = '#9fc0ff';
          for (let i = 0; i < 3; i++) {
            ctx.fillRect(cartX + 15 + i * 35, cartY - 25, 30, 22);
            ctx.fillStyle = '#7aa5ff';
          }
        }

        const wheelPositions = [cartX + 25, cartX + 95];
        wheelPositions.forEach((wx) => {
          ctx.fillStyle = '#2f2f3c';
          ctx.beginPath();
          ctx.arc(wx, groundY - 8, 16, 0, Math.PI * 2);
          ctx.fill();
          ctx.strokeStyle = '#54607c';
          ctx.lineWidth = 3;
          ctx.beginPath();
          ctx.arc(wx, groundY - 8, 8, 0, Math.PI * 2);
          ctx.stroke();
        });

        // person pushing
        const muscle = index === 0 ? '#fdd1a3' : '#f09a5b';
        const lean = index === 0 ? -0.15 : -0.35;
        ctx.save();
        ctx.translate(cartX - 40, groundY - 70);
        ctx.rotate(lean);
        ctx.fillStyle = muscle;
        ctx.fillRect(-6, 0, 12, 55);
        ctx.fillRect(-20, 10, 12, 55);
        ctx.fillStyle = '#ffcc8c';
        ctx.beginPath();
        ctx.arc(0, -12, 16, 0, Math.PI * 2);
        ctx.fill();
        ctx.fillStyle = index === 0 ? '#4c93ff' : '#ff6f4e';
        ctx.fillRect(-20, 20, 40, 46);
        ctx.restore();

        const arrowLen = 40 + force * 6;
        drawArrow(ctx, cartX - 20, cartY + 10, cartX - 20 + arrowLen, cartY + 10, '#ff9b45', 5);
        ctx.fillStyle = '#1f2a44';
        ctx.font = '13px Poppins, sans-serif';
        ctx.fillText(`${cart.label} a=${acc.toFixed(2)}m/s²`, cartX, cartY - 40);
      });

      ctx.fillStyle = '#1f2a44';
      ctx.font = '14px Poppins, sans-serif';
      ctx.fillText(`F = ${force.toFixed(1)} N`, w * 0.12, groundY + 30);
      ctx.fillText(`满载质量 ≈ ${heavyMass.toFixed(1)} kg`, w * 0.12, groundY + 52);
      ctx.restore();
    }

    function drawActionReaction(ctx, w, h, params) {
      const floor = h * 0.78;
      ctx.save();
      ctx.fillStyle = '#ffe9ff';
      ctx.fillRect(0, 0, w, floor);
      ctx.fillStyle = '#f5d0e8';
      ctx.fillRect(0, floor, w, h - floor);
      for (let i = 0; i < 5; i++) {
        ctx.fillStyle = `rgba(255,255,255,${0.25})`;
        ctx.beginPath();
        ctx.arc(80 + i * 120, 90 + Math.sin(params.time + i) * 8, 30, 0, Math.PI * 2);
        ctx.fill();
      }

      const thrust = params.pressure * 35;
      const mass = params.mass;
      const accel = thrust / mass;
      const t = params.time % 2.5;
      const baseX = w * 0.2;
      const pathY = floor - 120;
      const distance = accel * t * t * 60;
      const balloonX = baseX + distance;
      const balloonY = pathY - Math.sin(t * 3) * 40;

      // kids
      ctx.fillStyle = '#ffd8a8';
      ctx.beginPath();
      ctx.arc(w * 0.15, floor - 40, 20, 0, Math.PI * 2);
      ctx.fill();
      ctx.fillStyle = '#8cc7ff';
      ctx.fillRect(w * 0.15 - 15, floor - 40, 30, 50);

      ctx.fillStyle = '#ffd8a8';
      ctx.beginPath();
      ctx.arc(w * 0.8, floor - 35, 18, 0, Math.PI * 2);
      ctx.fill();
      ctx.fillStyle = '#ffb077';
      ctx.fillRect(w * 0.8 - 14, floor - 35, 28, 45);

      // balloon
      ctx.save();
      ctx.translate(balloonX, balloonY);
      ctx.rotate(Math.sin(params.time * 1.5) * 0.2);
      const stretch = 1 + params.pressure * 0.1;
      ctx.scale(1, stretch);
      ctx.fillStyle = '#ff6fb2';
      ctx.beginPath();
      ctx.ellipse(0, 0, 40, 24, 0, 0, Math.PI * 2);
      ctx.fill();
      ctx.restore();

      // nozzle jet
      const jetLength = thrust * 0.6;
      const plumeAngle = Math.PI / 6;
      ctx.strokeStyle = 'rgba(255,255,255,0.7)';
      ctx.lineWidth = 6;
      ctx.beginPath();
      ctx.moveTo(balloonX - 30, balloonY + 5);
      ctx.lineTo(balloonX - 30 - jetLength, balloonY + 5 + Math.tan(plumeAngle) * jetLength);
      ctx.stroke();
      for (let i = 0; i < 6; i++) {
        ctx.fillStyle = `rgba(255,255,255,${0.4 - i * 0.05})`;
        ctx.beginPath();
        ctx.arc(balloonX - 30 - i * 15, balloonY + 15 + Math.sin(params.time * 4 + i) * 6, 6 - i * 0.6, 0, Math.PI * 2);
        ctx.fill();
      }

      // trajectory trail
      ctx.strokeStyle = 'rgba(255,111,178,0.3)';
      ctx.setLineDash([6, 8]);
      ctx.beginPath();
      ctx.moveTo(baseX, pathY);
      ctx.quadraticCurveTo(baseX + distance * 0.4, pathY - 60, balloonX, balloonY);
      ctx.stroke();
      ctx.setLineDash([]);

      ctx.fillStyle = '#1f2a44';
      ctx.font = '14px Poppins, sans-serif';
      ctx.fillText(`推力 ≈ ${thrust.toFixed(1)} N`, w * 0.05, floor + 26);
      ctx.fillText(`气球质量 ≈ ${mass.toFixed(1)} g`, w * 0.35, floor + 26);
      ctx.fillText(`加速度 ≈ ${accel.toFixed(2)} m/s²`, w * 0.62, floor + 26);
      ctx.restore();
    }

    function drawSoundLab(ctx, w, h, params) {
      ctx.save();
      ctx.fillStyle = '#f2f7ff';
      ctx.fillRect(0, 0, w, h);
      const tableY = h * 0.7;
      ctx.fillStyle = '#d6d8e8';
      ctx.fillRect(0, tableY, w, h - tableY);
      ctx.fillStyle = '#c5c8da';
      ctx.fillRect(0, tableY - 80, w, 80);

      const forkX = w * 0.3;
      const forkY = tableY - 80;
      const omega = 2 * Math.PI * params.frequency;
      const vibrate = params.amplitude * 10 * Math.sin(omega * params.time);
      ctx.strokeStyle = '#7d8ab2';
      ctx.lineWidth = 8;
      ctx.beginPath();
      ctx.moveTo(forkX + vibrate, forkY);
      ctx.lineTo(forkX + vibrate, tableY + 20);
      ctx.stroke();
      ctx.lineWidth = 16;
      ctx.beginPath();
      ctx.moveTo(forkX - 30 - vibrate, forkY);
      ctx.lineTo(forkX - 30 - vibrate, forkY - 120);
      ctx.moveTo(forkX + 30 + vibrate, forkY);
      ctx.lineTo(forkX + 30 + vibrate, forkY - 120);
      ctx.stroke();

      ctx.fillStyle = '#9ec9ff';
      ctx.beginPath();
      ctx.ellipse(forkX + 150, tableY - 10, 100, 25, 0, 0, Math.PI * 2);
      ctx.fill();
      const wavelength = 340 / Math.max(params.frequency, 1);
      for (let i = 0; i < 6; i++) {
        const rippleR = 30 + i * 18 + (params.time * 340 * 0.15) % wavelength;
        ctx.strokeStyle = `rgba(255,255,255,${0.5 - i * 0.07})`;
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.arc(forkX + 150, tableY - 10, Math.min(rippleR, 120), 0, Math.PI * 2);
        ctx.stroke();
      }

      ctx.strokeStyle = 'rgba(120,200,255,0.35)';
      ctx.lineWidth = 4;
      const waveSpeed = 340 * 0.12;
      for (let i = 0; i < 8; i++) {
        const r = 60 + (params.time * waveSpeed + i * wavelength * 0.4) % (w * 0.5);
        ctx.beginPath();
        ctx.arc(forkX, forkY - 80, r, Math.PI / 3, -Math.PI / 3, true);
        ctx.stroke();
      }

      ctx.fillStyle = '#1f2a44';
      ctx.font = '13px Poppins, sans-serif';
      ctx.fillText(`频率 f = ${params.frequency.toFixed(0)} Hz`, 40, 40);
      ctx.fillText(`振幅 ${params.amplitude.toFixed(1)} 倍 · 波长 λ = v/f ≈ ${(340 / params.frequency).toFixed(2)} m`, 40, 62);
      ctx.restore();
    }

    function drawResonance(ctx, w, h, params) {
      ctx.save();
      ctx.fillStyle = '#1b1324';
      ctx.fillRect(0, 0, w, h);
      ctx.fillStyle = '#2f2142';
      ctx.fillRect(0, h * 0.7, w, h * 0.3);
      ctx.fillStyle = '#442a54';
      ctx.fillRect(0, h * 0.65, w, 15);

      ctx.fillStyle = '#f0b2c6';
      ctx.beginPath();
      ctx.arc(w * 0.2, h * 0.45, 28, 0, Math.PI * 2);
      ctx.fill();
      ctx.fillStyle = '#ffdede';
      ctx.fillRect(w * 0.18, h * 0.45, 30, 70);

      const glassX = w * 0.65;
      const glassY = h * 0.55;
      const natural = params.glassFreq;
      const diff = Math.abs(params.voiceFreq - natural);
      const resonance = clamp(1 - diff / 120, 0, 1);
      ctx.strokeStyle = '#d2f1ff';
      ctx.lineWidth = 3;
      ctx.beginPath();
      ctx.ellipse(glassX, glassY, 55 + resonance * 4, 90 + resonance * 10, 0, 0, Math.PI * 2);
      ctx.stroke();
      ctx.fillStyle = 'rgba(255,255,255,0.1)';
      ctx.fillRect(glassX - 40, glassY - 80, 80, 120);

      ctx.strokeStyle = `rgba(255,255,255,${0.2 + resonance * 0.6})`;
      for (let i = 0; i < 4; i++) {
        ctx.beginPath();
        ctx.arc(glassX, glassY, 30 + i * 12, 0, Math.PI * 2);
        ctx.stroke();
      }

      if (resonance > 0.95) {
        for (let i = 0; i < 20; i++) {
          const angle = (i / 20) * Math.PI * 2;
          ctx.strokeStyle = `rgba(255,255,255,${Math.random()})`;
          ctx.beginPath();
          ctx.moveTo(glassX, glassY);
          ctx.lineTo(glassX + Math.cos(angle) * 80, glassY + Math.sin(angle) * 80);
          ctx.stroke();
        }
      }

      ctx.fillStyle = '#1f2a44';
      ctx.font = '13px Poppins, sans-serif';
      ctx.fillText(`歌声频率 ${params.voiceFreq.toFixed(0)} Hz`, 30, 40);
      ctx.fillText(`酒杯固有频率 ${natural.toFixed(0)} Hz`, 30, 64);
      ctx.fillText(`共振程度 ${(resonance * 100).toFixed(0)}%`, 30, 88);
      ctx.restore();
    }

    function drawBernoulli(ctx, w, h, params) {
      ctx.save();
      ctx.fillStyle = '#f2f4ff';
      ctx.fillRect(0, 0, w, h);
      ctx.fillStyle = '#e4ebff';
      ctx.fillRect(0, h * 0.7, w, h * 0.3);

      const personX = w * 0.2;
      ctx.fillStyle = '#ffd7b9';
      ctx.beginPath();
      ctx.arc(personX, h * 0.45, 24, 0, Math.PI * 2);
      ctx.fill();
      ctx.fillStyle = '#6ba0ff';
      ctx.fillRect(personX - 20, h * 0.45, 40, 80);

      const paper1X = w * 0.5 - 40;
      const paper2X = w * 0.5 + 40;
      const sway = Math.sin(params.time * 2) * 4;
      ctx.fillStyle = '#ffffff';
      ctx.rotate(0);
      ctx.fillRect(paper1X - 5 + sway, h * 0.3, 10, 180);
      ctx.fillRect(paper2X + 5 - sway, h * 0.3, 10, 180);

      ctx.strokeStyle = 'rgba(120,180,255,0.3)';
      ctx.lineWidth = 4;
      for (let i = 0; i < 6; i++) {
        ctx.beginPath();
        ctx.moveTo(personX + 20, h * 0.5 + i * 12);
        ctx.quadraticCurveTo(w * 0.43, h * 0.45 + Math.sin(params.time * 1.5 + i) * 12, w * 0.6, h * 0.5 + i * 8);
        ctx.stroke();
      }

      ctx.fillStyle = '#1f2a44';
      ctx.font = '13px Poppins, sans-serif';
      ctx.fillText(`吹气速度 ${params.flow.toFixed(1)} m/s`, 30, 40);
      ctx.fillText('流速↑ → 压强↓ → 纸张靠拢', 30, 64);
      ctx.restore();
    }

    function drawSubmarine(ctx, w, h, params) {
      ctx.save();
      ctx.fillStyle = '#0f2c4f';
      ctx.fillRect(0, 0, w, h);
      const waterTop = h * 0.2;
      ctx.fillStyle = '#0a4a78';
      ctx.fillRect(0, waterTop, w, h - waterTop);

      const ballast = params.ballast;
      const subY = waterTop + ballast * 220;
      ctx.fillStyle = '#ffb347';
      ctx.beginPath();
      ctx.ellipse(w * 0.5, subY, 160, 50, 0, 0, Math.PI * 2);
      ctx.fill();
      ctx.fillStyle = '#d47c3b';
      ctx.fillRect(w * 0.44, subY - 70, 60, 60);

      ctx.fillStyle = '#7bd5ff';
      ctx.fillRect(w * 0.52, subY - 20, 30, 20);

      const bubbles = Math.round((1 - ballast) * 8);
      ctx.fillStyle = 'rgba(255,255,255,0.6)';
      for (let i = 0; i < bubbles; i++) {
        const x = w * 0.5 + Math.sin(params.time * 2 + i) * 20;
        const y = subY + 10 - i * 20 - params.time * 20 % 40;
        ctx.beginPath();
        ctx.arc(x, y, 6, 0, Math.PI * 2);
        ctx.fill();
      }

      ctx.fillStyle = '#1f2a44';
      ctx.font = '13px Poppins, sans-serif';
      ctx.fillText(`水舱注水量 ${Math.round(ballast * 100)}%`, 30, 40);
      ctx.fillText(ballast > 0.5 ? '重力>浮力 → 下潜' : '浮力>重力 → 上浮', 30, 64);
      ctx.restore();
    }

    function drawSurfaceTension(ctx, w, h, params) {
      ctx.save();
      ctx.fillStyle = '#daf2ff';
      ctx.fillRect(0, 0, w, h);
      const waterY = h * 0.6;
      ctx.fillStyle = '#8ed0ff';
      ctx.beginPath();
      ctx.moveTo(0, waterY);
      for (let x = 0; x <= w; x += 20) {
        ctx.lineTo(x, waterY + Math.sin(x / 40 + params.time) * 6);
      }
      ctx.lineTo(w, h);
      ctx.lineTo(0, h);
      ctx.closePath();
      ctx.fill();

      const insectX = w * 0.5 + Math.sin(params.time) * 80;
      const insectY = waterY - 10;
      ctx.fillStyle = '#4c3e24';
      ctx.ellipse(insectX, insectY, 35, 14, 0, 0, Math.PI * 2);
      ctx.fill();
      ctx.fillStyle = '#1f1b12';
      for (let i = -1; i <= 1; i++) {
        ctx.beginPath();
        ctx.arc(insectX + i * 12, insectY, 8, 0, Math.PI * 2);
        ctx.fill();
      }

      ctx.strokeStyle = 'rgba(255,255,255,0.8)';
      ctx.lineWidth = 2;
      for (let i = -2; i <= 2; i++) {
        ctx.beginPath();
        ctx.ellipse(insectX + i * 18, insectY + 10, 12, 6, 0, 0, Math.PI * 2);
        ctx.stroke();
      }

      ctx.strokeStyle = 'rgba(255,255,255,0.4)';
      ctx.beginPath();
      ctx.moveTo(w * 0.2, waterY - 40);
      ctx.lineTo(w * 0.8, waterY - 40);
      ctx.stroke();

      ctx.fillStyle = '#1f2a44';
      ctx.font = '13px Poppins, sans-serif';
      ctx.fillText(`昆虫质量 ${params.mass.toFixed(2)} g`, 30, 40);
      ctx.fillText(`水面张力 ≈ ${params.tension.toFixed(1)} mN`, 30, 64);
      ctx.restore();
    }

    function drawBuoyancy(ctx, w, h, params) {
      const waterTop = h * 0.32;
      ctx.save();
      ctx.fillStyle = '#cfe8ff';
      ctx.fillRect(0, 0, w, waterTop);
      ctx.fillStyle = '#86c4ff';
      ctx.fillRect(0, waterTop, w, h - waterTop);
      ctx.strokeStyle = '#bfe2ff';
      for (let i = 0; i < 40; i++) {
        const waveY = waterTop + Math.sin(params.time * 2 + i) * (4 + params.density);
        ctx.beginPath();
        ctx.ellipse((i / 40) * w, waveY, 30, 10, 0, 0, Math.PI * 2);
        ctx.stroke();
      }

      const volumeM3 = params.volume / 1000;
      const buoy = 1000 * g * volumeM3;
      const weight = params.density * 1000 * g * volumeM3;
      const ratio = clamp(weight / buoy, 0.2, 1.5);
      const bob = Math.sin(params.time * 1.4) * 6;
      const boatWidth = 240;
      const boatHeight = 70;
      const boatX = w * 0.5 - boatWidth / 2;
      const boatY = waterTop + 45 * ratio + bob;

      ctx.fillStyle = '#b16c36';
      ctx.beginPath();
      ctx.moveTo(boatX, boatY);
      ctx.lineTo(boatX + boatWidth, boatY);
      ctx.quadraticCurveTo(boatX + boatWidth - 40, boatY + boatHeight, boatX + boatWidth / 2, boatY + boatHeight + 10);
      ctx.quadraticCurveTo(boatX + 40, boatY + boatHeight, boatX, boatY);
      ctx.fill();
      ctx.fillStyle = '#f8d8b0';
      ctx.fillRect(boatX + 40, boatY - 55, 60, 55);
      ctx.fillRect(boatX + boatWidth - 110, boatY - 45, 70, 45);
      ctx.fillStyle = '#4c7be5';
      roundedRectPath(ctx, boatX + boatWidth / 2 - 22, boatY - 75, 44, 65, 16);
      ctx.fill();
      ctx.fillStyle = '#fbd3a5';
      ctx.beginPath();
      ctx.arc(boatX + boatWidth / 2, boatY - 85, 22, 0, Math.PI * 2);
      ctx.fill();

      const centerX = boatX + boatWidth / 2;
      drawArrow(ctx, centerX, boatY + 12, centerX, boatY + 12 - buoy * 0.012, '#ff9b45', 5);
      drawArrow(ctx, centerX, boatY - 80, centerX, boatY - 80 + weight * 0.012, '#1f3f7a', 5);

      ctx.fillStyle = '#ffffff';
      ctx.font = '15px Poppins, sans-serif';
      ctx.fillText('浮力', centerX + 14, boatY + 12 - buoy * 0.012 - 6);
      ctx.fillText('重力', centerX + 14, boatY - 80 + weight * 0.012 + 16);
      ctx.fillStyle = '#1f2a44';
      ctx.font = '14px Poppins, sans-serif';
      ctx.fillText(`ρ物=${params.density.toFixed(2)} g/cm³`, boatX + 12, boatY - 95);
      ctx.fillText(`排水体积=${params.volume.toFixed(1)} L`, boatX + 12, boatY - 72);
      ctx.fillText(weight > buoy ? '船体下沉 → 过载' : '浮力≥重力 → 稳定漂浮', boatX + 12, boatY - 50);

      ctx.strokeStyle = 'rgba(255,255,255,0.85)';
      ctx.lineWidth = 3;
      ctx.beginPath();
      ctx.moveTo(boatX + 60, boatY + 10);
      ctx.lineTo(boatX + boatWidth - 60, boatY + 10);
      ctx.stroke();

      ctx.restore();
    }

    function drawLever(ctx, w, h, params) {
      const pivotX = w * 0.5;
      const pivotY = h * 0.7;
      ctx.save();
      ctx.fillStyle = '#c76f3c';
      ctx.beginPath();
      ctx.moveTo(pivotX - 25, pivotY);
      ctx.lineTo(pivotX + 25, pivotY);
      ctx.lineTo(pivotX + 5, pivotY + 70);
      ctx.lineTo(pivotX - 5, pivotY + 70);
      ctx.closePath();
      ctx.fill();
      ctx.strokeStyle = '#a75625';
      ctx.lineWidth = 5;
      ctx.beginPath();
      ctx.moveTo(w * 0.15, pivotY - 40);
      ctx.lineTo(w * 0.85, pivotY + 40);
      ctx.stroke();

      const leftPos = pivotX - params.leftArm * 45;
      const rightArm = 3;
      const rightPos = pivotX + rightArm * 45;
      const angleTilt = (params.leftForce * params.leftArm - rightArm * 3) * 0.005;

      ctx.save();
      ctx.translate(pivotX, pivotY);
      ctx.rotate(angleTilt);
      ctx.fillStyle = '#e4a653';
      ctx.fillRect(-w * 0.35, -12, w * 0.7, 24);
      ctx.restore();

      const childRadius = 28;
      ctx.fillStyle = '#ffcd9b';
      ctx.beginPath();
      ctx.arc(leftPos, pivotY - 70 - angleTilt * 40, childRadius, 0, Math.PI * 2);
      ctx.fill();
      ctx.fillStyle = '#ff9b45';
      ctx.fillRect(leftPos - 18, pivotY - 60 - angleTilt * 40, 36, 45);

      ctx.fillStyle = '#cbe5ff';
      ctx.beginPath();
      ctx.arc(rightPos, pivotY - 40 + angleTilt * 40, childRadius, 0, Math.PI * 2);
      ctx.fill();
      ctx.fillStyle = '#4c7be5';
      ctx.fillRect(rightPos - 18, pivotY - 30 + angleTilt * 40, 36, 45);

      drawArrow(ctx, leftPos, pivotY - 80, leftPos, pivotY - 80 + params.leftForce * 8, '#ff9b45', 4);
      const needed = params.leftForce * params.leftArm / rightArm;
      drawArrow(ctx, rightPos, pivotY - 50, rightPos, pivotY - 50 + needed * 8, '#4c7be5', 4);
      ctx.restore();
    }

    function drawReflection(ctx, w, h, params) {
      ctx.save();
      ctx.fillStyle = '#f5f8fc';
      ctx.fillRect(0, 0, w, h);
      const mirrorX = w * 0.5;
      const centerY = h * 0.5;
      const angleDeg = clamp(params.angle || 45, 5, 85);
      const angleRad = toRad(angleDeg);
      const rayLen = 180;
      const incDirX = Math.sin(angleRad);
      const incDirY = Math.cos(angleRad);
      const sourceX = mirrorX - rayLen * incDirX;
      const sourceY = centerY - rayLen * incDirY;
      const hitY = centerY;
      const reflDirX = -incDirX;
      const reflDirY = incDirY;
      const endX = mirrorX + rayLen * reflDirX;
      const endY = centerY + rayLen * reflDirY;

      ctx.fillStyle = 'rgba(200,220,255,0.4)';
      ctx.fillRect(mirrorX - 8, 80, 16, h - 160);
      ctx.strokeStyle = '#4c7be5';
      ctx.lineWidth = 3;
      ctx.strokeRect(mirrorX - 8, 80, 16, h - 160);
      ctx.setLineDash([6, 5]);
      ctx.strokeStyle = 'rgba(0,0,0,0.35)';
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.moveTo(mirrorX, 80);
      ctx.lineTo(mirrorX, h - 80);
      ctx.stroke();
      ctx.setLineDash([]);
      ctx.fillStyle = '#1f2a44';
      ctx.font = '11px Poppins, sans-serif';
      ctx.fillText('法线', mirrorX + 12, centerY - 6);

      ctx.strokeStyle = '#e65100';
      ctx.lineWidth = 4;
      ctx.beginPath();
      ctx.moveTo(sourceX, sourceY);
      ctx.lineTo(mirrorX, centerY);
      ctx.stroke();
      ctx.strokeStyle = '#1565c0';
      ctx.beginPath();
      ctx.moveTo(mirrorX, centerY);
      ctx.lineTo(endX, endY);
      ctx.stroke();
      ctx.fillStyle = '#e65100';
      ctx.beginPath();
      ctx.arc(sourceX, sourceY, 10, 0, Math.PI * 2);
      ctx.fill();
      ctx.fillStyle = '#1565c0';
      ctx.beginPath();
      ctx.arc(endX, endY, 10, 0, Math.PI * 2);
      ctx.fill();
      ctx.fillStyle = '#1f2a44';
      ctx.font = '12px Poppins, sans-serif';
      ctx.fillText('入射', sourceX - 28, sourceY + 4);
      ctx.fillText('反射', endX + 10, endY + 4);
      ctx.fillText(`入射角 θi = ${angleDeg}°`, 24, 42);
      ctx.fillText(`反射角 θr = ${angleDeg}°  ∠i = ∠r`, 24, 58);
      ctx.fillText('调节角度观察入射光线与反射光线对称', 24, 74);
      ctx.restore();
    }

    function drawRefraction(ctx, w, h, params) {
      ctx.save();
      ctx.fillStyle = '#f7fbff';
      ctx.fillRect(0, 0, w, h);
      const tableY = h * 0.75;
      ctx.fillStyle = '#d9d9e3';
      ctx.fillRect(0, tableY, w, h - tableY);

      const cupX = w * 0.45;
      const cupY = tableY - 20;
      ctx.fillStyle = 'rgba(200,220,255,0.5)';
      ctx.beginPath();
      ctx.ellipse(cupX, cupY, 110, 30, 0, 0, Math.PI * 2);
      ctx.fill();
      ctx.fillRect(cupX - 110, cupY - 160, 220, 140);
      ctx.strokeStyle = 'rgba(150,190,255,0.8)';
      ctx.lineWidth = 4;
      ctx.strokeRect(cupX - 110, cupY - 160, 220, 140);

      ctx.fillStyle = 'rgba(120,190,255,0.25)';
      ctx.fillRect(cupX - 108, cupY - 160, 216, 100);
      ctx.fillStyle = '#ffffff';
      ctx.globalAlpha = 0.25;
      ctx.fillRect(cupX - 70, cupY - 152, 30, 152);
      ctx.globalAlpha = 1;

      const stickStart = { x: w * 0.2, y: tableY - 60 };
      const stickMid = { x: cupX, y: cupY - 60 };
      const stickEnd = { x: cupX + 40, y: cupY - 150 };
      ctx.strokeStyle = '#c47a40';
      ctx.lineWidth = 8;
      ctx.lineCap = 'round';
      ctx.beginPath();
      ctx.moveTo(stickStart.x, stickStart.y);
      ctx.lineTo(stickMid.x, stickMid.y);
      ctx.lineTo(stickEnd.x, stickEnd.y);
      ctx.stroke();

      const rayOrigin = { x: stickMid.x + 10, y: stickMid.y - 10 };
      const angle = toRad(params.angle);
      const sinTheta2 = clamp((n2 / n1) * Math.sin(angle), -0.999, 0.999);
      const theta2 = Math.asin(sinTheta2);
      const rayLength = 220;
      ctx.strokeStyle = '#ffb347';
      ctx.lineWidth = 5;
      ctx.beginPath();
      ctx.moveTo(rayOrigin.x, rayOrigin.y);
      ctx.lineTo(rayOrigin.x + Math.cos(angle) * 160, rayOrigin.y - Math.sin(angle) * 160);
      ctx.stroke();
      ctx.strokeStyle = '#66d9ff';
      ctx.beginPath();
      ctx.moveTo(rayOrigin.x, rayOrigin.y);
      ctx.lineTo(rayOrigin.x + Math.cos(theta2) * rayLength, rayOrigin.y - Math.sin(theta2) * rayLength);
      ctx.stroke();

      ctx.fillStyle = '#1f2a44';
      ctx.font = '14px Poppins, sans-serif';
      ctx.fillText(`θ水=${params.angle.toFixed(0)}°`, w * 0.1, 60);
      ctx.fillText(`θ空气=${(theta2 * 180 / Math.PI).toFixed(1)}°`, w * 0.1, 84);
      ctx.fillText('水杯中的筷子看似折断，其实是光线折射', w * 0.1, 110);
      ctx.restore();
    }

    function drawLens(ctx, w, h, params) {
      ctx.save();
      ctx.fillStyle = '#f6fff3';
      ctx.fillRect(0, 0, w, h);
      ctx.fillStyle = '#cfe7b5';
      ctx.beginPath();
      ctx.moveTo(0, h * 0.6);
      ctx.quadraticCurveTo(w * 0.5, h * 0.45, w, h * 0.6);
      ctx.lineTo(w, h);
      ctx.lineTo(0, h);
      ctx.closePath();
      ctx.fill();

      const lensX = w * 0.45;
      const sunRays = [];
      for (let i = -2; i <= 2; i++) {
        sunRays.push({ angle: toRad(10 + i * 2) });
      }
      ctx.strokeStyle = 'rgba(255,215,128,0.7)';
      ctx.lineWidth = 4;
      sunRays.forEach((ray, idx) => {
        const startX = lensX - 220;
        const startY = 80 + idx * 30;
        ctx.beginPath();
        ctx.moveTo(startX, startY);
        ctx.lineTo(lensX, startY + Math.tan(ray.angle) * 120);
        ctx.stroke();
      });

      ctx.fillStyle = 'rgba(255,255,255,0.6)';
      ctx.beginPath();
      ctx.ellipse(lensX, h * 0.35, 30, 140, 0, 0, Math.PI * 2);
      ctx.fill();
      ctx.strokeStyle = '#7ab7ff';
      ctx.lineWidth = 3;
      ctx.beginPath();
      ctx.ellipse(lensX, h * 0.35, 30, 140, 0, 0, Math.PI * 2);
      ctx.stroke();

      const focal = params.distance;
      const focusPoint = { x: lensX + focal * 80, y: h * 0.6 };
      ctx.strokeStyle = '#ffb347';
      ctx.lineWidth = 4;
      sunRays.forEach((ray, idx) => {
        const startY = 80 + idx * 30;
        ctx.beginPath();
        ctx.moveTo(lensX, startY + Math.tan(ray.angle) * 120);
        ctx.lineTo(focusPoint.x, focusPoint.y);
        ctx.stroke();
      });

      ctx.fillStyle = '#6b4b2b';
      ctx.fillRect(focusPoint.x - 10, focusPoint.y - 10, 20, 50);
      ctx.fillStyle = '#88c057';
      ctx.beginPath();
      ctx.ellipse(focusPoint.x, focusPoint.y - 20, 40, 15, 0, 0, Math.PI * 2);
      ctx.fill();
      const glow = ctx.createRadialGradient(focusPoint.x, focusPoint.y - 20, 5, focusPoint.x, focusPoint.y - 20, 40);
      glow.addColorStop(0, `rgba(255,230,120,${params.intensity / 10})`);
      glow.addColorStop(1, 'rgba(255,230,120,0)');
      ctx.fillStyle = glow;
      ctx.beginPath();
      ctx.arc(focusPoint.x, focusPoint.y - 20, 60, 0, Math.PI * 2);
      ctx.fill();

      ctx.fillStyle = '#1f2a44';
      ctx.font = '14px Poppins, sans-serif';
      ctx.fillText(`焦距设置≈${focal.toFixed(1)} 倍`, 30, 50);
      ctx.fillText(`光强比=${params.intensity.toFixed(1)}`, 30, 74);
      ctx.restore();
    }

    function drawDispersion(ctx, w, h, params) {
      ctx.save();
      ctx.fillStyle = '#fdf7ed';
      ctx.fillRect(0, 0, w, h);
      ctx.fillStyle = '#e9d8c0';
      ctx.fillRect(0, h * 0.7, w, h * 0.3);

      ctx.fillStyle = '#c1c1cf';
      ctx.beginPath();
      ctx.moveTo(w * 0.6, h * 0.3);
      ctx.lineTo(w * 0.7, h * 0.5);
      ctx.lineTo(w * 0.5, h * 0.5);
      ctx.closePath();
      ctx.fill();

      const whiteRayX = w * 0.2;
      ctx.strokeStyle = 'rgba(255,255,255,0.8)';
      ctx.lineWidth = 6;
      ctx.beginPath();
      ctx.moveTo(whiteRayX, h * 0.35);
      ctx.lineTo(w * 0.55, h * 0.38);
      ctx.stroke();

      const colors = ['#ff4b4b', '#ffa53b', '#ffe14b', '#5bd45b', '#3ea1ff', '#6f52ff', '#a34cff'];
      colors.forEach((color, idx) => {
        ctx.strokeStyle = color;
        ctx.lineWidth = 5;
        ctx.beginPath();
        ctx.moveTo(w * 0.58, h * 0.39);
        ctx.lineTo(w * 0.9, h * 0.4 + idx * 10 * (params.spread / 2));
        ctx.stroke();
      });

      ctx.fillStyle = '#d9dedd';
      ctx.beginPath();
      ctx.ellipse(w * 0.9, h * 0.55, 120, 40, 0, 0, Math.PI * 2);
      ctx.fill();

      ctx.fillStyle = '#1f2a44';
      ctx.font = '14px Poppins, sans-serif';
      ctx.fillText('白光 → 三棱镜 → 彩虹', 30, 40);
      ctx.fillText(`色散角≈${(params.spread * 20).toFixed(1)}°`, 30, 64);
      ctx.restore();
    }

    function drawConduction(ctx, w, h, params) {
      ctx.save();
      ctx.fillStyle = '#f8f0ea';
      ctx.fillRect(0, 0, w, h);
      const stoveY = h * 0.65;
      ctx.fillStyle = '#b4b0ad';
      ctx.fillRect(0, stoveY, w, h - stoveY);

      ctx.fillStyle = '#a34927';
      ctx.fillRect(w * 0.2, stoveY - 120, w * 0.6, 120);
      ctx.fillStyle = '#f5aa63';
      ctx.beginPath();
      ctx.ellipse(w * 0.5, stoveY - 120, 250, 60, 0, 0, Math.PI);
      ctx.fill();

      const timeFactor = params.time;
      const soupTemp = params.temperature;
      const metalHeat = clamp(timeFactor * soupTemp / 100, 0, 1);
      const plasticHeat = clamp(timeFactor * 0.3, 0, 0.4);

      const spoons = [
        { x: w * 0.38, label: '金属勺', heat: metalHeat, color: '#c0cad6' },
        { x: w * 0.62, label: '塑料勺', heat: plasticHeat, color: '#f2d5ff' }
      ];
      spoons.forEach((spoon) => {
        const gradient = ctx.createLinearGradient(0, stoveY - 200, 0, stoveY + 20);
        gradient.addColorStop(0, `rgba(255,120,80,${spoon.heat})`);
        gradient.addColorStop(1, spoon.color);
        ctx.fillStyle = gradient;
        ctx.fillRect(spoon.x - 10, stoveY - 200, 20, 210);
        ctx.fillStyle = '#d88947';
        ctx.beginPath();
        ctx.arc(spoon.x, stoveY - 200, 30, 0, Math.PI * 2);
        ctx.fill();
        ctx.fillStyle = '#1f2a44';
        ctx.font = '13px Poppins, sans-serif';
        ctx.fillText(spoon.label, spoon.x - 30, stoveY - 220);
      });

      ctx.fillStyle = '#ffffff';
      ctx.font = '14px Poppins, sans-serif';
      ctx.fillText(`时间 = ${params.time.toFixed(1)} s`, 30, 40);
      ctx.fillText(`汤温 ≈ ${params.temperature.toFixed(0)} °C`, 30, 64);
      ctx.restore();
    }

    function drawPhase(ctx, w, h, params) {
      ctx.save();
      ctx.fillStyle = '#f0fbff';
      ctx.fillRect(0, 0, w, h);
      const mid = w / 2;
      ctx.fillStyle = '#dbeeff';
      ctx.fillRect(0, 0, mid, h);
      ctx.fillStyle = '#ffe9d2';
      ctx.fillRect(mid, 0, mid, h);

      const meltLevel = clamp(params.energy / 100, 0, 1);
      ctx.fillStyle = '#d4f1ff';
      ctx.beginPath();
      ctx.ellipse(mid * 0.4, h * 0.6, 80, 30, 0, 0, Math.PI * 2);
      ctx.fill();
      ctx.fillStyle = '#a0d8ff';
      ctx.fillRect(mid * 0.4 - 60, h * 0.5, 120, 20 + meltLevel * 50);
      ctx.fillStyle = '#f7fbff';
      ctx.fillRect(mid * 0.4 - 50, h * 0.5 - meltLevel * 30, 100, 40 - meltLevel * 20);

      ctx.fillStyle = '#ffe1a8';
      ctx.beginPath();
      ctx.ellipse(mid + mid * 0.3, h * 0.6, 80, 30, 0, 0, Math.PI * 2);
      ctx.fill();
      ctx.fillStyle = '#febc5c';
      ctx.beginPath();
      ctx.arc(mid + mid * 0.3, h * 0.58, 40, 0, Math.PI * 2);
      ctx.fill();
      const bubbleCount = 8;
      for (let i = 0; i < bubbleCount; i++) {
        const bx = mid + mid * 0.3 + Math.sin(params.time * 2 + i) * 30;
        const by = h * 0.6 - i * 15;
        ctx.fillStyle = 'rgba(255,255,255,0.6)';
        ctx.beginPath();
        ctx.arc(bx, by, 6, 0, Math.PI * 2);
        ctx.fill();
      }

      ctx.fillStyle = '#1f2a44';
      ctx.font = '14px Poppins, sans-serif';
      ctx.fillText(`吸收热量 Q = ${params.energy.toFixed(0)} kJ`, 30, 40);
      ctx.fillText(`蒸发速率 = ${(params.energy * 0.02).toFixed(1)} g/s`, mid + 20, 40);
      ctx.restore();
    }

    function drawPhotoelectric(ctx, w, h, params) {
      ctx.save();
      ctx.fillStyle = '#10111b';
      ctx.fillRect(0, 0, w, h);
      const chamberY = h * 0.65;
      ctx.fillStyle = '#1e2335';
      ctx.fillRect(w * 0.2, chamberY - 140, w * 0.6, 160);
      ctx.strokeStyle = '#4e5a7a';
      ctx.strokeRect(w * 0.2, chamberY - 140, w * 0.6, 160);

      const freq = params.frequency;
      const intensity = params.intensity;
      ctx.fillStyle = '#ffd76d';
      for (let i = 0; i < intensity * 2; i++) {
        const start = w * 0.25 - 60 + i * 8;
        ctx.beginPath();
        ctx.moveTo(start, chamberY - 80);
        ctx.lineTo(w * 0.4, chamberY - 60 + Math.sin(params.time * 2 + i) * 10);
        ctx.strokeStyle = `rgba(255,215,109,${0.3 + Math.random() * 0.2})`;
        ctx.lineWidth = 2;
        ctx.stroke();
      }

      ctx.fillStyle = '#5eb4ff';
      const energy = freq - params.threshold;
      const electrons = Math.max(0, energy) * intensity;
      for (let i = 0; i < electrons; i++) {
        const ex = w * 0.42 + Math.random() * 120;
        const ey = chamberY - 80 + Math.sin(params.time * 4 + i) * 20;
        ctx.beginPath();
        ctx.arc(ex, ey, 4, 0, Math.PI * 2);
        ctx.fill();
      }

      ctx.fillStyle = '#1f2a44';
      ctx.font = '13px Poppins, sans-serif';
      ctx.fillText(`入射频率 ${freq.toFixed(0)} THz`, 30, 40);
      ctx.fillText(`阈频 ${params.threshold.toFixed(0)} THz`, 30, 64);
      ctx.fillText(`光强 ${intensity.toFixed(1)} 倍`, 30, 88);
      ctx.restore();
    }

    function drawEnergyLevels(ctx, w, h, params) {
      ctx.save();
      ctx.fillStyle = '#060410';
      ctx.fillRect(0, 0, w, h);
      ctx.fillStyle = '#1d1b3a';
      ctx.fillRect(0, h * 0.65, w, h * 0.35);

      ctx.fillStyle = '#ff4d4d';
      ctx.font = '48px Poppins, sans-serif';
      ctx.fillText('CAFE', w * 0.15, h * 0.4);

      const tubeX = w * 0.6;
      ctx.strokeStyle = '#ff7f7f';
      ctx.lineWidth = 6;
      ctx.beginPath();
      ctx.rect(tubeX - 50, h * 0.3, 100, h * 0.4);
      ctx.stroke();

      const jumps = Math.round(params.voltage / 10);
      for (let i = 0; i < jumps; i++) {
        const startY = h * 0.6 - i * 15;
        ctx.strokeStyle = `rgba(255,80,80,${0.4 + Math.random() * 0.4})`;
        ctx.beginPath();
        ctx.moveTo(tubeX - 40, startY);
        ctx.lineTo(tubeX + 40, startY - 30);
        ctx.stroke();
      }

      ctx.fillStyle = '#1f2a44';
      ctx.font = '13px Poppins, sans-serif';
      ctx.fillText(`电压 ${params.voltage.toFixed(0)} V`, 30, 40);
      ctx.restore();
    }

    function drawFission(ctx, w, h, params) {
      ctx.save();
      ctx.fillStyle = '#050810';
      ctx.fillRect(0, 0, w, h);
      const centerX = w * 0.45;
      const centerY = h * 0.5;
      ctx.fillStyle = '#2a72ff';
      ctx.beginPath();
      ctx.arc(centerX, centerY, 60, 0, Math.PI * 2);
      ctx.fill();

      const control = params.control;
      const neutrons = Math.max(1, Math.round((1 - control) * 4));
      for (let i = 0; i < neutrons; i++) {
        const angle = params.time * 1.5 + i;
        ctx.fillStyle = '#ffd75e';
        ctx.beginPath();
        ctx.arc(centerX + Math.cos(angle) * 80, centerY + Math.sin(angle) * 80, 8, 0, Math.PI * 2);
        ctx.fill();
      }

      ctx.fillStyle = '#1f2a44';
      ctx.font = '13px Poppins, sans-serif';
      ctx.fillText(`控制棒插入 ${Math.round(control * 100)}%`, 30, 40);
      ctx.fillText('控制棒越深入 → 链式反应越弱', 30, 64);
      ctx.restore();
    }

    function drawOrbit(ctx, w, h, params) {
      ctx.save();
      ctx.fillStyle = '#050520';
      ctx.fillRect(0, 0, w, h);
      ctx.fillStyle = '#f9b23e';
      ctx.beginPath();
      ctx.arc(w * 0.5, h * 0.55, 40, 0, Math.PI * 2);
      ctx.fill();

      const a = 180;
      const b = a * (1 - params.eccentricity * 0.5);
      ctx.strokeStyle = 'rgba(255,255,255,0.4)';
      ctx.lineWidth = 2;
      ctx.beginPath();
      for (let angle = 0; angle <= Math.PI * 2; angle += 0.02) {
        const x = w * 0.5 + a * Math.cos(angle);
        const y = h * 0.55 + b * Math.sin(angle);
        angle === 0 ? ctx.moveTo(x, y) : ctx.lineTo(x, y);
      }
      ctx.stroke();

      const orbitAngle = params.time * params.speed * 0.05;
      const earthX = w * 0.5 + a * Math.cos(orbitAngle);
      const earthY = h * 0.55 + b * Math.sin(orbitAngle);
      ctx.fillStyle = '#4db4ff';
      ctx.beginPath();
      ctx.arc(earthX, earthY, 18, 0, Math.PI * 2);
      ctx.fill();

      ctx.fillStyle = 'rgba(255,255,255,0.4)';
      for (let i = 0; i < 40; i++) {
        const starX = Math.random() * w;
        const starY = Math.random() * h;
        ctx.fillRect(starX, starY, 2, 2);
      }

      ctx.fillStyle = '#ffffff';
      ctx.font = '13px Poppins, sans-serif';
      ctx.fillText(`轨道偏心率 ${params.eccentricity.toFixed(2)}`, 30, 40);
      ctx.restore();
    }

    function drawBlackHole(ctx, w, h, params) {
      ctx.save();
      ctx.fillStyle = '#01030a';
      ctx.fillRect(0, 0, w, h);
      const holeX = w * 0.5;
      const holeY = h * 0.5;
      const mass = params.mass;
      ctx.fillStyle = '#000000';
      ctx.beginPath();
      ctx.arc(holeX, holeY, 60 + mass * 5, 0, Math.PI * 2);
      ctx.fill();

      ctx.strokeStyle = '#ff8c42';
      ctx.lineWidth = 6;
      ctx.beginPath();
      ctx.arc(holeX, holeY, 100 + mass * 5, 0, Math.PI * 2);
      ctx.stroke();

      ctx.strokeStyle = '#66d9ff';
      ctx.lineWidth = 3;
      ctx.beginPath();
      ctx.arc(holeX, holeY, 160, Math.PI / 4, Math.PI * 3 / 4);
      ctx.stroke();

      ctx.fillStyle = '#ffffff';
      ctx.font = '13px Poppins, sans-serif';
      ctx.fillText(`黑洞质量系数 ${mass.toFixed(1)}`, 30, 40);
      ctx.fillText(`背景星光在强引力下弯曲`, 30, 64);
      ctx.restore();
    }

    function drawHydroPower(ctx, w, h, params) {
      ctx.save();
      ctx.fillStyle = '#bde3ff';
      ctx.fillRect(0, 0, w, h);
      ctx.fillStyle = '#7cc4ff';
      ctx.fillRect(0, h * 0.4, w, h * 0.6);

      ctx.fillStyle = '#a8a9b4';
      ctx.fillRect(w * 0.35, h * 0.15, 60, h * 0.55);
      ctx.fillRect(w * 0.35, h * 0.15, w * 0.35, 40);

      const flow = params.flow;
      ctx.strokeStyle = '#4ec2ff';
      ctx.lineWidth = 8;
      ctx.beginPath();
      ctx.moveTo(w * 0.35, h * 0.5);
      ctx.lineTo(w * 0.2, h * 0.8);
      ctx.stroke();

      ctx.fillStyle = '#ffc857';
      ctx.beginPath();
      ctx.arc(w * 0.22, h * 0.78, 50, 0, Math.PI * 2);
      ctx.fill();

      ctx.fillStyle = '#1f2a44';
      ctx.font = '13px Poppins, sans-serif';
      ctx.fillText(`水头高度 ${params.head.toFixed(0)} m`, 30, 40);
      ctx.fillText(`流量 ${flow.toFixed(1)} m³/s`, 30, 64);
      ctx.restore();
    }

    function drawEddyDamping(ctx, w, h, params) {
      ctx.save();
      ctx.fillStyle = '#f4f0ff';
      ctx.fillRect(0, 0, w, h);
      ctx.fillStyle = '#b5a089';
      ctx.fillRect(w * 0.55, h * 0.2, 30, h * 0.6);

      const magnetY = h * 0.25 + (params.time * 40) % (h * 0.5);
      const slowFactor = params.magnetStrength;
      const displayedY = h * 0.25 + (params.time * 20) % (h * 0.5) / (slowFactor);
      ctx.fillStyle = '#b82243';
      ctx.fillRect(w * 0.55 - 10, displayedY, 50, 40);

      ctx.strokeStyle = 'rgba(80,150,255,0.3)';
      for (let i = 0; i < 5; i++) {
        ctx.beginPath();
        ctx.ellipse(w * 0.57, displayedY + 20, 30 + i * 6, 12 + i * 4, 0, 0, Math.PI * 2);
        ctx.stroke();
      }

      ctx.fillStyle = '#1f2a44';
      ctx.font = '13px Poppins, sans-serif';
      ctx.fillText(`磁铁强度 ${params.magnetStrength.toFixed(1)} T`, 30, 40);
      ctx.fillText(`铜管长度 ${params.pipeLength.toFixed(1)} m`, 30, 64);
      ctx.restore();
    }

    function drawOhm(ctx, w, h, params) {
      ctx.save();
      const deskY = h * 0.72;
      ctx.fillStyle = '#f1f5ff';
      ctx.fillRect(0, 0, w, deskY);
      ctx.fillStyle = '#d7e0f7';
      ctx.fillRect(0, deskY, w, h - deskY);

      ctx.fillStyle = '#c08a56';
      ctx.fillRect(w * 0.18, deskY - 15, w * 0.64, 15);

      const safeResistance = Math.max(params.resistance, 0.2);
      const current = params.voltage / safeResistance;
      const brightness = clamp(current / 0.4, 0, 2.4);
      const monitorGlow = clamp(current / 0.35, 0.1, 1.2);
      const motorSpeed = clamp(current * 120, 10, 420);

      ctx.fillStyle = '#3b3c4f';
      ctx.fillRect(w * 0.2, deskY - 90, 28, 90);
      ctx.fillRect(w * 0.77, deskY - 90, 28, 90);

      const lampX = w * 0.45;
      const lampY = deskY - 110;
      ctx.fillStyle = `rgba(247,193,74,${0.6 + 0.2 * Math.min(1, brightness)})`;
      ctx.beginPath();
      ctx.arc(lampX, lampY, 34, 0, Math.PI * 2);
      ctx.fill();
      ctx.fillStyle = '#fff7de';
      ctx.beginPath();
      ctx.arc(lampX, lampY, 20, 0, Math.PI * 2);
      ctx.fill();
      const glow = ctx.createRadialGradient(lampX, lampY, 15, lampX, lampY, 140);
      glow.addColorStop(0, `rgba(255,233,150,${0.8 * Math.min(1, brightness)})`);
      glow.addColorStop(1, 'rgba(255,233,150,0)');
      ctx.fillStyle = glow;
      ctx.beginPath();
      ctx.arc(lampX, lampY, 120, 0, Math.PI * 2);
      ctx.fill();

      ctx.fillStyle = '#1f1f2f';
      ctx.fillRect(w * 0.3, deskY - 70, 90, 55);
      ctx.fillStyle = `rgba(80,190,255,${0.2 + 0.4 * monitorGlow})`;
      ctx.fillRect(w * 0.31, deskY - 65, 72, 42);
      ctx.fillStyle = `rgba(255,255,255,${0.15 * monitorGlow})`;
      ctx.fillRect(w * 0.31, deskY - 65, 72 * monitorGlow, 42);

      const motorX = w * 0.65;
      const motorY = deskY - 70;
      ctx.fillStyle = '#6c7bd8';
      ctx.fillRect(motorX - 40, motorY - 40, 80, 80);
      ctx.save();
      ctx.translate(motorX, motorY);
      ctx.rotate(params.time * motorSpeed * 0.02);
      ctx.fillStyle = '#f5f5f5';
      for (let i = 0; i < 4; i++) {
        ctx.rotate(Math.PI / 2);
        ctx.fillRect(0, -6, 32, 12);
      }
      ctx.restore();
      ctx.fillStyle = '#f1a45c';
      ctx.fillRect(motorX - 60, motorY + 50, 120, 14);
      for (let i = 0; i < 3; i++) {
        const offset = ((params.time * motorSpeed * 0.4) + i * 60) % 160;
        ctx.fillStyle = '#ffd27a';
        ctx.fillRect(motorX - 70 + offset, motorY + 36, 24, 14);
      }

      ctx.strokeStyle = '#4c7be5';
      ctx.lineWidth = 5;
      ctx.beginPath();
      ctx.moveTo(w * 0.22, deskY - 40);
      ctx.lineTo(lampX - 34, deskY - 60);
      ctx.lineTo(w * 0.62, deskY - 45);
      ctx.lineTo(w * 0.79, deskY - 30);
      ctx.stroke();

      ctx.strokeStyle = '#ff9b45';
      ctx.lineWidth = 4;
      ctx.beginPath();
      ctx.moveTo(w * 0.22, deskY - 10);
      ctx.lineTo(w * 0.79, deskY - 10);
      ctx.stroke();
      const dashCount = 12;
      for (let i = 0; i < dashCount; i++) {
        const t = (i / dashCount + params.time * current * 0.5) % 1;
        const x = w * 0.22 + t * (w * 0.57);
        ctx.fillStyle = '#ff9b45';
        ctx.beginPath();
        ctx.arc(x, deskY - 10, 5, 0, Math.PI * 2);
        ctx.fill();
      }

      ctx.fillStyle = '#1f2a44';
      ctx.font = '14px Poppins, sans-serif';
      ctx.fillText('电池', w * 0.2, deskY - 105);
      ctx.fillText('灯泡 + 工位', lampX - 45, deskY - 140);
      ctx.fillText('电脑监控', w * 0.31, deskY - 80);
      ctx.fillText('工厂电机', motorX + 20, motorY - 45);
      ctx.fillText(`I = ${(current).toFixed(2)} A`, w * 0.48, deskY - 135);
      ctx.fillText(`P = UI = ${(params.voltage * current).toFixed(1)} W`, w * 0.48, deskY - 110);
      ctx.fillText(`转速 ~ ${(motorSpeed).toFixed(0)} rpm`, w * 0.48, deskY - 85);
      ctx.restore();
    }

    function drawSeries(ctx, w, h, params) {
      const tableY = h * 0.75;
      ctx.save();
      ctx.fillStyle = '#eef3ff';
      ctx.fillRect(0, 0, w, tableY);
      ctx.fillStyle = '#d8e0f0';
      ctx.fillRect(0, tableY, w, h - tableY);

      ctx.fillStyle = '#444';
      ctx.fillRect(w * 0.18, tableY - 70, 25, 70);
      ctx.fillRect(w * 0.82 - 25, tableY - 70, 25, 70);
      const lampX = w * 0.3;
      const lampY = tableY - 80;
      ctx.fillStyle = '#f0c44a';
      ctx.beginPath();
      ctx.ellipse(lampX, lampY, 30, 18, 0, 0, Math.PI * 2);
      ctx.fill();

      ctx.fillStyle = '#a0c6ff';
      ctx.fillRect(w * 0.42, tableY - 90, 60, 60);
      ctx.fillStyle = '#789ddc';
      ctx.fillRect(w * 0.55, tableY - 70, 60, 40);
      ctx.fillStyle = '#f2f5ff';
      ctx.fillRect(w * 0.64, tableY - 35, 80, 20);

      ctx.strokeStyle = '#4c7be5';
      ctx.lineWidth = 4;
      ctx.beginPath();
      ctx.moveTo(w * 0.18 + 25, tableY - 40);
      ctx.lineTo(w * 0.3 - 30, tableY - 40);
      ctx.moveTo(w * 0.3 + 30, tableY - 40);
      ctx.lineTo(w * 0.42, tableY - 60);
      ctx.lineTo(w * 0.55, tableY - 50);
      ctx.lineTo(w * 0.64, tableY - 20);
      ctx.lineTo(w * 0.82 - 25, tableY - 40);
      ctx.stroke();

      const total = Math.max(params.r1 + params.r2, 0.2);
      const current = params.voltage / total;
      const dots = 14;
      for (let i = 0; i < dots; i++) {
        const t = (i / dots + params.time * current) % 1;
        const x = w * 0.2 + t * (w * 0.6);
        ctx.fillStyle = '#ff9b45';
        ctx.beginPath();
        ctx.arc(x, tableY - 35, 5, 0, Math.PI * 2);
        ctx.fill();
      }

      const lampBrightness = clamp(current / 0.35, 0, 2.2);
      const lampGlow = ctx.createRadialGradient(lampX, lampY, 15, lampX, lampY, 90);
      lampGlow.addColorStop(0, `rgba(255,230,140,${0.65 * Math.min(1, lampBrightness)})`);
      lampGlow.addColorStop(1, 'rgba(255,230,140,0)');
      ctx.fillStyle = lampGlow;
      ctx.beginPath();
      ctx.arc(lampX, lampY, 80, 0, Math.PI * 2);
      ctx.fill();

      const fanCenterX = w * 0.54;
      const fanCenterY = tableY - 50;
      const fanSpeed = clamp(current * 140, 0, 480);
      ctx.save();
      ctx.translate(fanCenterX, fanCenterY);
      ctx.rotate(params.time * fanSpeed * 0.03);
      ctx.fillStyle = '#f6f8ff';
      for (let i = 0; i < 4; i++) {
        ctx.rotate(Math.PI / 2);
        ctx.fillRect(0, -4, 32, 10);
      }
      ctx.restore();

      const conveyorY = tableY - 10;
      ctx.fillStyle = '#babeca';
      ctx.fillRect(w * 0.62, conveyorY, w * 0.18, 12);
      ctx.strokeStyle = '#888';
      ctx.lineWidth = 3;
      ctx.beginPath();
      ctx.arc(w * 0.62, conveyorY + 6, 10, 0, Math.PI * 2);
      ctx.arc(w * 0.8, conveyorY + 6, 10, 0, Math.PI * 2);
      ctx.stroke();
      const conveyorSpeed = clamp(current * 90, 15, 260);
      for (let i = 0; i < 3; i++) {
        const offset = ((params.time * conveyorSpeed) + i * 60) % (w * 0.18);
        ctx.fillStyle = '#f9cc7a';
        ctx.fillRect(w * 0.62 + offset, conveyorY - 25, 28, 20);
      }

      ctx.fillStyle = '#1f2a44';
      ctx.font = '13px Poppins, sans-serif';
      ctx.fillText('串联灯泡', w * 0.28, tableY - 110);
      ctx.fillText('风扇(电机)', w * 0.44, tableY - 95);
      ctx.fillText('电脑/电阻箱', w * 0.54, tableY - 30);
      ctx.fillText(`I=${current.toFixed(2)}A`, w * 0.65, tableY - 90);
      ctx.fillText(`输送线≈${(conveyorSpeed * 0.05).toFixed(1)} m/s`, w * 0.6, tableY - 55);
      ctx.restore();
    }

    function drawCapacitor(ctx, w, h, params) {
      ctx.save();
      ctx.fillStyle = '#eff4ff';
      ctx.fillRect(0, 0, w, h);
      ctx.fillStyle = '#d7dee9';
      ctx.fillRect(0, h * 0.25, w, h * 0.75);

      const cameraX = w * 0.25;
      const cameraY = h * 0.55;
      ctx.fillStyle = '#1f243c';
      ctx.fillRect(cameraX - 90, cameraY - 70, 180, 120);
      ctx.fillStyle = '#3a4263';
      ctx.fillRect(cameraX - 110, cameraY - 20, 220, 40);
      ctx.fillStyle = '#101320';
      ctx.beginPath();
      ctx.arc(cameraX + 70, cameraY - 10, 38, 0, Math.PI * 2);
      ctx.fill();
      ctx.fillStyle = '#5778d3';
      ctx.beginPath();
      ctx.arc(cameraX + 70, cameraY - 10, 26, 0, Math.PI * 2);
      ctx.fill();

      const capX = w * 0.45;
      const capY = h * 0.5;
      ctx.fillStyle = '#4c7be5';
      ctx.fillRect(capX - 45, capY - 110, 90, 220);
      ctx.fillStyle = '#1f2f56';
      ctx.fillRect(capX - 12, capY - 120, 24, 240);

      const resistanceOhm = params.resistance * 1000;
      const capacitanceF = params.capacitance / 1000;
      const tau = resistanceOhm * capacitanceF;
      const cycle = 7;
      const t = params.time % cycle;
      const chargingPhase = cycle - 1.5;
      let chargeLevel;
      if (t < chargingPhase) {
        const normalized = t / Math.max(chargingPhase, 0.1);
        chargeLevel = 1 - Math.exp(-normalized * (chargingPhase / Math.max(tau, 0.2)));
      } else {
        chargeLevel = Math.max(0, 1 - (t - chargingPhase) * 4);
      }
      chargeLevel = clamp(chargeLevel, 0, 1);
      ctx.fillStyle = `rgba(255,255,255,${0.25 + chargeLevel * 0.6})`;
      ctx.fillRect(capX - 32, capY - 85, 64, 170);

      const ledX = w * 0.68;
      const ledY = h * 0.45;
      ctx.fillStyle = '#1a1d2d';
      ctx.fillRect(ledX - 40, ledY - 30, 80, 60);
      ctx.fillStyle = `rgba(255,100,100,${0.3 + chargeLevel * 0.7})`;
      ctx.beginPath();
      ctx.arc(ledX, ledY, 18, 0, Math.PI * 2);
      ctx.fill();

      ctx.strokeStyle = '#ffae5f';
      ctx.lineWidth = 3;
      ctx.beginPath();
      ctx.moveTo(capX + 80, capY);
      ctx.lineTo(ledX - 60, ledY);
      ctx.lineTo(ledX + 70, ledY);
      ctx.stroke();

      const particles = 16;
      for (let i = 0; i < particles; i++) {
        const progress = (i / particles + chargeLevel * params.time * 0.2) % 1;
        const px = capX + 80 + progress * (ledX - 60 - (capX + 80));
        ctx.fillStyle = `rgba(255,255,255,${0.2 + chargeLevel * 0.6})`;
        ctx.beginPath();
        ctx.arc(px, ledY, 3, 0, Math.PI * 2);
        ctx.fill();
      }

      const flash = t >= chargingPhase;
      if (flash) {
        ctx.fillStyle = `rgba(255,255,255,${chargeLevel})`;
        ctx.fillRect(0, 0, w, h);
      }

      ctx.fillStyle = '#1f2a44';
      ctx.font = '14px Poppins, sans-serif';
      ctx.fillText(`τ ≈ ${(tau).toFixed(2)} s`, capX - 45, capY + 140);
      ctx.fillText(chargeLevel > 0.95 ? '充满 → 准备闪光' : '慢充进行中', capX - 60, capY + 160);
      ctx.restore();
    }

    function drawFuse(ctx, w, h, params) {
      ctx.save();
      ctx.fillStyle = '#f5f7ff';
      ctx.fillRect(0, 0, w, h);
      const tableY = h * 0.7;
      ctx.fillStyle = '#d8e0ef';
      ctx.fillRect(0, tableY, w, h - tableY);

      const current = params.voltage / Math.max(params.load, 0.1);
      const overload = current > params.fuseRating;

      ctx.fillStyle = '#444';
      ctx.fillRect(w * 0.2, tableY - 80, 20, 80);
      ctx.fillRect(w * 0.8 - 20, tableY - 80, 20, 80);

      ctx.strokeStyle = '#4c7be5';
      ctx.lineWidth = 4;
      ctx.beginPath();
      ctx.moveTo(w * 0.21, tableY - 40);
      ctx.lineTo(w * 0.35, tableY - 40);
      ctx.lineTo(w * 0.5, tableY - 50);
      ctx.lineTo(w * 0.65, tableY - 50);
      ctx.lineTo(w * 0.79, tableY - 40);
      ctx.stroke();

      const fuseX = w * 0.5;
      ctx.fillStyle = '#f6f6f6';
      ctx.fillRect(fuseX - 50, tableY - 65, 100, 30);
      ctx.strokeStyle = '#c8c8c8';
      ctx.strokeRect(fuseX - 50, tableY - 65, 100, 30);

      if (overload) {
        ctx.strokeStyle = '#ff7b4a';
        ctx.lineWidth = 4;
        ctx.beginPath();
        ctx.moveTo(fuseX - 40, tableY - 50);
        ctx.lineTo(fuseX - 15, tableY - 50 + Math.sin(params.time * 20) * 5);
        ctx.lineTo(fuseX + 10, tableY - 50 - Math.sin(params.time * 15) * 5);
        ctx.lineTo(fuseX + 35, tableY - 50);
        ctx.stroke();
        ctx.fillStyle = 'rgba(255,120,60,0.45)';
        ctx.fillRect(fuseX - 50, tableY - 65, 100, 30);
        ctx.fillStyle = `rgba(120,120,120,${0.3 + 0.3 * Math.sin(params.time * 5)})`;
        ctx.beginPath();
        ctx.ellipse(fuseX, tableY - 80, 70, 20, 0, 0, Math.PI * 2);
        ctx.fill();
      } else {
        ctx.strokeStyle = '#b0b7c9';
        ctx.lineWidth = 4;
        ctx.beginPath();
        ctx.moveTo(fuseX - 40, tableY - 50);
        ctx.lineTo(fuseX + 40, tableY - 50);
        ctx.stroke();
      }

      const bulbX = w * 0.7;
      ctx.fillStyle = '#ffd467';
      ctx.beginPath();
      ctx.arc(bulbX, tableY - 70, 18, 0, Math.PI * 2);
      ctx.fill();
      ctx.fillStyle = '#ffa200';
      ctx.fillRect(bulbX - 10, tableY - 70, 20, 25);
      const bulbGlow = overload ? 0.1 : clamp(current / params.fuseRating, 0, 1);
      const bulbGradient = ctx.createRadialGradient(bulbX, tableY - 70, 10, bulbX, tableY - 70, 80);
      bulbGradient.addColorStop(0, `rgba(255,210,120,${0.5 * bulbGlow})`);
      bulbGradient.addColorStop(1, 'rgba(255,210,120,0)');
      ctx.fillStyle = bulbGradient;
      ctx.beginPath();
      ctx.arc(bulbX, tableY - 70, 80, 0, Math.PI * 2);
      ctx.fill();

      ctx.fillStyle = '#1f2a44';
      ctx.font = '14px Poppins, sans-serif';
      ctx.fillText(`I = ${current.toFixed(2)}A`, w * 0.22, tableY - 100);
      ctx.fillText(`额定 ${params.fuseRating.toFixed(1)}A`, fuseX - 40, tableY - 80);
      ctx.fillText(overload ? '保险丝熔断！' : '电路安全运行', w * 0.6, tableY - 100);
      ctx.restore();
    }

    function drawEnergy(ctx, w, h, params) {
      ctx.save();
      ctx.fillStyle = '#e5f2ff';
      ctx.fillRect(0, 0, w, h);
      ctx.fillStyle = '#bedc9a';
      ctx.beginPath();
      ctx.moveTo(0, h * 0.8);
      ctx.quadraticCurveTo(w * 0.3, h * 0.5, w * 0.6, h * 0.72);
      ctx.lineTo(w, h);
      ctx.lineTo(0, h);
      ctx.closePath();
      ctx.fill();

      const towerX = w * 0.25;
      ctx.fillStyle = '#c0c9db';
      ctx.fillRect(towerX - 25, h * 0.2, 50, h * 0.7);

      const heightNorm = params.height / 10;
      const liftHeight = h * 0.75 - heightNorm * 250 - Math.sin(params.time * 1.4) * 8;
      ctx.fillStyle = '#4c7be5';
      ctx.fillRect(towerX - 40, liftHeight - 5, 80, 5);
      ctx.fillStyle = '#ffaf6e';
      ctx.fillRect(towerX - 40, liftHeight - 55, 80, 55);
      ctx.fillStyle = '#f6d0a3';
      ctx.beginPath();
      ctx.arc(towerX, liftHeight - 70, 18, 0, Math.PI * 2);
      ctx.fill();

      const energy = params.mass * g * params.height;
      ctx.fillStyle = '#1f2a44';
      ctx.font = '16px Poppins, sans-serif';
      ctx.fillText(`Ep = mgh = ${energy.toFixed(1)} J`, w * 0.5, h * 0.3);
      ctx.fillText(`m = ${params.mass.toFixed(1)} kg`, w * 0.5, h * 0.34);
      ctx.fillText(`h = ${params.height.toFixed(1)} m`, w * 0.5, h * 0.38);

      ctx.strokeStyle = '#ff9b45';
      ctx.lineWidth = 4;
      ctx.beginPath();
      ctx.moveTo(towerX + 50, liftHeight);
      ctx.lineTo(towerX + 50, liftHeight + params.height * 10);
      ctx.stroke();
      ctx.restore();
    }

    function drawMomentum(ctx, w, h, params) {
      const trackY = h * 0.78;
      ctx.save();
      ctx.strokeStyle = '#d8e2ff';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(30, trackY);
      ctx.lineTo(w - 30, trackY);
      ctx.stroke();
      const blockHeight = 55;
      const block1Width = 70;
      const block2Width = 80;
      const cycle = (params.time % 4) / 4;
      const collisionX = w * 0.55;
      let block1X, block2X;
      if (cycle < 0.5) {
        const t = cycle / 0.5;
        block1X = w * 0.15 + t * (collisionX - w * 0.15 - block1Width);
        block2X = w * 0.72;
      } else {
        const t = (cycle - 0.5) / 0.5;
        const v1p = ((params.mass1 - params.mass2) / (params.mass1 + params.mass2)) * params.v1;
        const v2p = (2 * params.mass1 / (params.mass1 + params.mass2)) * params.v1;
        block1X = collisionX - block1Width + v1p * t * 6;
        block2X = w * 0.65 + v2p * t * 5;
      }
      block1X = clamp(block1X, 30, w - block1Width - 30);
      block2X = clamp(block2X, 30, w - block2Width - 30);
      ctx.fillStyle = '#fff';
      ctx.strokeStyle = '#4c7be5';
      roundedRectPath(ctx, block1X, trackY - blockHeight - 10, block1Width, blockHeight, 10);
      ctx.fill();
      ctx.stroke();
      ctx.fillStyle = '#fff';
      ctx.strokeStyle = '#ff9b45';
      roundedRectPath(ctx, block2X, trackY - blockHeight - 10, block2Width, blockHeight, 10);
      ctx.fill();
      ctx.stroke();
      drawArrow(ctx, block1X + block1Width / 2, trackY - blockHeight - 25, block1X + block1Width / 2 + params.v1 * 4, trackY - blockHeight - 25, '#4c7be5', 3);
      ctx.restore();
    }

    function drawCircular(ctx, w, h, params) {
      const centerX = w / 2;
      const centerY = h / 2 + 40;
      ctx.save();
      const bg = ctx.createLinearGradient(0, 0, 0, h);
      bg.addColorStop(0, '#1d2233');
      bg.addColorStop(1, '#343d58');
      ctx.fillStyle = bg;
      ctx.fillRect(0, 0, w, h);
      ctx.fillStyle = '#2a2f44';
      ctx.fillRect(0, centerY + 70, w, h - (centerY + 70));
      ctx.fillStyle = 'rgba(255,255,255,0.1)';
      for (let i = 0; i < 5; i++) {
        ctx.fillRect(40 + i * 140, centerY + 80, 100, 8);
      }

      ctx.fillStyle = '#444c66';
      ctx.beginPath();
      ctx.arc(centerX, centerY + 40, 80, Math.PI, 0);
      ctx.lineTo(centerX + 80, centerY + 100);
      ctx.lineTo(centerX - 80, centerY + 100);
      ctx.closePath();
      ctx.fill();

      ctx.fillStyle = '#ffcf7d';
      ctx.beginPath();
      ctx.arc(centerX, centerY - 120, 35, 0, Math.PI * 2);
      ctx.fill();
      ctx.fillStyle = '#6d88ff';
      ctx.fillRect(centerX - 30, centerY - 120, 60, 110);

      const umbrellaRadius = 120 + params.radius * 6;
      ctx.fillStyle = '#f05b72';
      ctx.beginPath();
      ctx.moveTo(centerX, centerY - 40);
      for (let i = 0; i <= 6; i++) {
        const angle = (i / 6) * Math.PI;
        const x = centerX + umbrellaRadius * Math.cos(angle);
        const y = centerY - 40 - umbrellaRadius * Math.sin(angle);
        ctx.lineTo(x, y);
      }
      ctx.closePath();
      ctx.fill();

      const r = Math.max(params.radius, 0.5);
      const angularSpeed = params.speed / r;
      const dropletCount = 20;
      for (let i = 0; i < dropletCount; i++) {
        const theta = params.time * angularSpeed + (i / dropletCount) * Math.PI * 2;
        const startX = centerX + umbrellaRadius * Math.cos(theta);
        const startY = centerY - 40 - umbrellaRadius * Math.sin(theta);
        const tangentX = -Math.sin(theta);
        const tangentY = -Math.cos(theta);
        const vx = tangentX * params.speed * 5;
        const vy = tangentY * params.speed * 5;
        const life = (params.time * 3 + i) % 1;
        const splashX = startX + vx * 12 * life;
        const splashY = startY + vy * 12 * life;
        const alpha = 1 - life;
        ctx.fillStyle = `rgba(132,200,255,${alpha})`;
        ctx.beginPath();
        ctx.arc(splashX, splashY, 3 + (params.speed * params.speed / r) * 0.03 * (1 - life), 0, Math.PI * 2);
        ctx.fill();
      }

      ctx.fillStyle = 'rgba(255,255,255,0.3)';
      ctx.beginPath();
      ctx.arc(centerX + 30, centerY - 160, 25, 0, Math.PI * 2);
      ctx.fill();

      ctx.fillStyle = '#9ad5ff';
      for (let i = 0; i < 8; i++) {
        const offset = (params.time * 50 + i * 60) % w;
        ctx.beginPath();
        ctx.arc(offset, centerY + 70, 6, 0, Math.PI * 2);
        ctx.fill();
      }

      const ac = (params.speed * params.speed / Math.max(params.radius, 0.5)).toFixed(2);
      ctx.fillStyle = 'rgba(200,220,255,0.85)';
      ctx.beginPath();
      ctx.roundRect(24, 24, 220, 36, 10);
      ctx.fill();
      ctx.strokeStyle = 'rgba(76,123,229,0.4)';
      ctx.stroke();
      ctx.fillStyle = '#1f2a44';
      ctx.font = 'bold 14px Poppins, sans-serif';
      ctx.fillText(`向心加速度 a_c = ${ac} m/s²`, 36, 48);
      ctx.font = '12px Poppins, sans-serif';
      ctx.fillText(`v = ${params.speed} m/s，r = ${params.radius} m → a_c = v²/r`, 30, 78);
      ctx.fillText('雨伞甩出的水滴沿切线飞出 → “离心力”只是惯性', 30, 64);
      ctx.restore();
    }

    function drawProjectile(ctx, w, h, params) {
      const groundY = h - 80;
      const margin = 80;
      const axisMargin = 32;
      ctx.save();
      const sky = ctx.createLinearGradient(0, 0, 0, groundY);
      sky.addColorStop(0, '#a6d8ff');
      sky.addColorStop(1, '#eaf7ff');
      ctx.fillStyle = sky;
      ctx.fillRect(0, 0, w, groundY);
      ctx.fillStyle = '#b4d28d';
      ctx.fillRect(0, groundY, w, h - groundY);

      ctx.fillStyle = '#87b6e0';
      ctx.beginPath();
      ctx.moveTo(0, groundY - 180);
      ctx.lineTo(w * 0.2, groundY - 250);
      ctx.lineTo(w * 0.4, groundY - 150);
      ctx.lineTo(w * 0.6, groundY - 260);
      ctx.lineTo(w * 0.8, groundY - 150);
      ctx.lineTo(w, groundY - 220);
      ctx.lineTo(w, groundY);
      ctx.lineTo(0, groundY);
      ctx.closePath();
      ctx.fill();

      const angle = toRad(params.angle);
      const v = params.speed;
      const vx = v * Math.cos(angle);
      const vy = v * Math.sin(angle);
      const totalTime = Math.max(0.2, (vy * 2) / g);
      const range = vx * totalTime;
      const maxHeight = (vy * vy) / (2 * g);

      // 固定比例尺：水平 0–35 m，竖直 0–12 m，靶子固定在 25 m
      const physicalXMax = 35;
      const physicalYMax = 12;
      const scale = Math.min(
        (w - margin * 2 - axisMargin) / physicalXMax,
        (groundY - margin - axisMargin) / physicalYMax
      );
      const originX = margin + axisMargin;
      const originY = groundY - 15;
      const targetDistance = 25;

      const toCanvas = (x, y) => ({
        x: originX + x * scale,
        y: originY - y * scale
      });

      // 坐标轴与刻度
      ctx.strokeStyle = '#2d3142';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(originX, originY);
      ctx.lineTo(originX + physicalXMax * scale, originY);
      ctx.moveTo(originX, originY);
      ctx.lineTo(originX, originY - physicalYMax * scale);
      ctx.stroke();
      ctx.fillStyle = '#2d3142';
      ctx.font = '11px Poppins, sans-serif';
      ctx.textAlign = 'center';
      for (let m = 5; m <= 35; m += 5) {
        const tx = originX + m * scale;
        ctx.beginPath();
        ctx.moveTo(tx, originY);
        ctx.lineTo(tx, originY + 6);
        ctx.stroke();
        ctx.fillText(m + ' m', tx, originY + 20);
      }
      ctx.textAlign = 'left';
      for (let m = 2; m <= 12; m += 2) {
        const ty = originY - m * scale;
        ctx.beginPath();
        ctx.moveTo(originX, ty);
        ctx.lineTo(originX - 6, ty);
        ctx.stroke();
        ctx.fillText(m + ' m', originX - 28, ty + 4);
      }
      ctx.fillText('0', originX - 10, originY + 18);

      // 跑道与炮
      ctx.fillStyle = '#7c5c42';
      ctx.fillRect(originX - 30, originY - 15, 120, 15);
      ctx.fillStyle = '#4b3d2c';
      ctx.fillRect(originX - 40, originY - 8, 140, 8);
      ctx.save();
      ctx.translate(originX, originY - 8);
      ctx.rotate(-angle);
      ctx.fillStyle = '#3d4f88';
      roundedRectPath(ctx, -25, -12, 70, 24, 10);
      ctx.fill();
      ctx.restore();
      ctx.fillStyle = '#ff9b45';
      ctx.beginPath();
      ctx.moveTo(originX, originY);
      ctx.arc(originX, originY, 36, -angle, 0, false);
      ctx.fill();
      ctx.fillStyle = '#1f2a44';
      ctx.font = '12px Poppins, sans-serif';
      ctx.fillText(`${params.angle.toFixed(0)}°`, originX + 32 * Math.cos(-angle / 2), originY - 32 * Math.sin(angle / 2));

      // 靶子：固定物理距离 25 m
      const targetCanvasX = originX + targetDistance * scale;
      const targetCanvasY = originY;
      ctx.fillStyle = '#f7f3c1';
      ctx.fillRect(targetCanvasX - 14, targetCanvasY - 48, 28, 48);
      ctx.fillStyle = '#f36e6e';
      ctx.beginPath();
      ctx.arc(targetCanvasX, targetCanvasY - 58, 14, 0, Math.PI * 2);
      ctx.fill();
      ctx.fillStyle = '#2d3142';
      ctx.font = '11px Poppins, sans-serif';
      ctx.textAlign = 'center';
      ctx.fillText('25 m', targetCanvasX, targetCanvasY + 28);

      // 轨迹：线宽与颜色随初速/角度变化，使调节参数后更明显
      const trajWidth = 2 + v / 8 + (params.angle || 45) / 45;
      const trajAlpha = 0.5 + Math.min(v / 40, 0.5);
      ctx.strokeStyle = `rgba(76,123,229,${trajAlpha})`;
      ctx.lineWidth = trajWidth;
      ctx.beginPath();
      const segments = 180;
      let started = false;
      for (let i = 0; i <= segments; i++) {
        const t = (i / segments) * totalTime;
        const x = vx * t;
        const y = vy * t - 0.5 * g * t * t;
        if (y < -0.2) break;
        const { x: drawX, y: drawY } = toCanvas(x, y);
        if (!started) { ctx.moveTo(drawX, drawY); started = true; }
        else ctx.lineTo(drawX, drawY);
      }
      ctx.stroke();

      // 射程虚线
      ctx.setLineDash([6, 5]);
      ctx.strokeStyle = 'rgba(76,123,229,0.4)';
      ctx.beginPath();
      ctx.moveTo(originX, originY);
      ctx.lineTo(originX + range * scale, originY);
      ctx.stroke();
      ctx.setLineDash([]);
      ctx.fillStyle = '#1f2a44';
      ctx.font = '12px Poppins, sans-serif';
      ctx.textAlign = 'center';
      ctx.fillText(`射程 ${range.toFixed(1)} m`, originX + (range * scale) / 2, originY + 22);
      ctx.textAlign = 'left';

      // 最高点
      const apexX = vx * (vy / g);
      const apexY = maxHeight;
      if (apexY <= physicalYMax && apexX <= physicalXMax) {
        const apex = toCanvas(apexX, apexY);
        ctx.fillStyle = '#ffcc7c';
        ctx.beginPath();
        ctx.arc(apex.x, apex.y, 8, 0, Math.PI * 2);
        ctx.fill();
        ctx.fillStyle = '#1f2a44';
        ctx.fillText(`最高点 ${maxHeight.toFixed(1)} m`, apex.x - 20, apex.y - 10);
      }

      const progress = params.time % (totalTime + 0.5);
      const px = vx * Math.min(progress, totalTime);
      const py = vy * progress - 0.5 * g * progress * progress;
      const projectile = toCanvas(px, Math.max(py, 0));
      const hitTime = targetDistance / vx;
      const yAtTarget = vy * hitTime - 0.5 * g * hitTime * hitTime;
      const isHit = hitTime <= totalTime && Math.abs(yAtTarget) < 1.2 && progress >= hitTime - 0.1 && progress <= hitTime + 0.3;

      const dotRadius = 7 + v / 6;
      const trailCount = 6 + Math.min(Math.round(v / 2.5), 14);
      const trailStep = 0.025 + 0.015 * (25 / Math.max(v, 5));

      if (progress <= totalTime) {
        ctx.fillStyle = '#ff9b45';
        ctx.beginPath();
        ctx.arc(projectile.x, projectile.y, dotRadius, 0, Math.PI * 2);
        ctx.fill();
        ctx.strokeStyle = 'rgba(200,120,40,0.6)';
        ctx.lineWidth = 2;
        ctx.stroke();
        ctx.fillStyle = 'rgba(255,155,69,0.4)';
        for (let i = 1; i <= trailCount; i++) {
          const t = Math.max(progress - i * trailStep, 0);
          const tx = vx * t;
          const ty = vy * t - 0.5 * g * t * t;
          const spot = toCanvas(tx, Math.max(ty, 0));
          const r = Math.max(1, dotRadius * 0.6 - i * 0.35);
          ctx.beginPath();
          ctx.arc(spot.x, spot.y, r, 0, Math.PI * 2);
          ctx.fill();
        }
        const arrowScale = 0.12 + v / 400;
        drawArrow(ctx, projectile.x, projectile.y, projectile.x + vx * scale * arrowScale, projectile.y, '#3cc5ff', 2 + v / 12);
        drawArrow(ctx, projectile.x, projectile.y, projectile.x, projectile.y - (vy - g * progress) * scale * arrowScale, '#ff6b81', 2 + v / 12);
        ctx.fillStyle = '#1f2a44';
        ctx.font = '11px Poppins, sans-serif';
        ctx.fillText(`vx=${vx.toFixed(1)}`, projectile.x + 14, projectile.y + 14);
        ctx.fillText(`vy=${(vy - g * progress).toFixed(1)}`, projectile.x - 72, projectile.y - 6);
      }

      if (isHit) {
        ctx.fillStyle = 'rgba(255,80,80,0.35)';
        ctx.beginPath();
        ctx.arc(targetCanvasX, targetCanvasY - 58, 22, 0, Math.PI * 2);
        ctx.fill();
        ctx.fillStyle = '#c62828';
        ctx.font = 'bold 18px Poppins, sans-serif';
        ctx.textAlign = 'center';
        ctx.fillText('命中！', targetCanvasX, targetCanvasY - 70);
        ctx.textAlign = 'left';
      }

      // 信息板
      ctx.fillStyle = 'rgba(255,255,255,0.9)';
      ctx.fillRect(w - 200, 36, 175, 132);
      ctx.strokeStyle = '#c8d0e0';
      ctx.strokeRect(w - 200, 36, 175, 132);
      ctx.fillStyle = '#1f2a44';
      ctx.font = '13px Poppins, sans-serif';
      ctx.fillText(`时间 ${Math.min(progress, totalTime).toFixed(2)} / ${totalTime.toFixed(2)} s`, w - 192, 58);
      ctx.fillText(`最大高度 ${maxHeight.toFixed(1)} m`, w - 192, 78);
      ctx.fillText(`射程 R = ${range.toFixed(1)} m`, w - 192, 98);
      ctx.fillText(`初速 v = ${v.toFixed(1)} m/s`, w - 192, 118);
      ctx.fillText(`发射角 θ = ${params.angle.toFixed(0)}°`, w - 192, 132);
      ctx.fillText(`靶距 25 m ${range >= 24 && range <= 26 ? '→ 可命中' : range < 24 ? '→ 未达' : '→ 越过'}`, w - 192, 152);
      ctx.restore();
    }

    function drawHarmonic(ctx, w, h, params) {
      ctx.save();
      ctx.fillStyle = '#f1f5ff';
      ctx.fillRect(0, 0, w, h);
      const pivotX = w * 0.5;
      const pivotY = h * 0.15;
      ctx.fillStyle = '#d9dce9';
      ctx.fillRect(pivotX - 60, pivotY - 10, 120, 20);

      const omega = 2 * Math.PI * params.frequency;
      const displacement = params.amplitude * Math.sin(omega * params.time);
      const bobX = pivotX + displacement;
      const bobY = h * 0.6;

      ctx.strokeStyle = '#4c7be5';
      ctx.lineWidth = 4;
      ctx.beginPath();
      ctx.moveTo(pivotX, pivotY);
      ctx.lineTo(bobX, bobY);
      ctx.stroke();

      ctx.fillStyle = '#ff9b45';
      ctx.beginPath();
      ctx.arc(bobX, bobY, 25, 0, Math.PI * 2);
      ctx.fill();

      ctx.fillStyle = '#1f2a44';
      ctx.font = '14px Poppins, sans-serif';
      ctx.fillText(`x(t) = A sin(ωt)，ω = 2πf = ${(omega).toFixed(2)} rad/s`, pivotX - 95, pivotY + 30);
      ctx.restore();
    }

    function drawWave(ctx, w, h, params) {
      ctx.save();
      ctx.fillStyle = '#f0f4ff';
      ctx.fillRect(0, 0, w, h);
      const ropeY = h * 0.6;
      ctx.strokeStyle = '#c9d7ff';
      ctx.lineWidth = 8;
      ctx.beginPath();
      ctx.moveTo(0, ropeY);
      ctx.lineTo(w, ropeY);
      ctx.stroke();

      const amplitude = params.amplitude;
      const freq = params.frequency;
      const omega = 2 * Math.PI * freq;
      const k = omega / 80;
      ctx.lineWidth = 5;
      ctx.strokeStyle = '#ff9b45';
      ctx.beginPath();
      for (let x = 0; x <= w; x++) {
        const y = ropeY + amplitude * Math.sin(k * x - omega * params.time);
        if (x === 0) ctx.moveTo(x, y);
        else ctx.lineTo(x, y);
      }
      ctx.stroke();

      ctx.fillStyle = '#1f2a44';
      ctx.font = '14px Poppins, sans-serif';
      ctx.fillText('绳子端点被上下抖动 → 横波沿绳传播', 20, ropeY - 40);
      ctx.restore();
    }

    function drawDoppler(ctx, w, h, params) {
      const roadY = h * 0.65;
      ctx.save();
      ctx.fillStyle = '#f3f7ff';
      ctx.fillRect(0, 0, w, roadY);
      ctx.fillStyle = '#cbd6e7';
      ctx.fillRect(0, roadY, w, h - roadY);

      const ambulanceX = w * 0.2 + Math.sin(params.time * 0.3) * 80;
      ctx.fillStyle = '#ffffff';
      roundedRectPath(ctx, ambulanceX - 60, roadY - 70, 120, 50, 12);
      ctx.fill();
      ctx.fillStyle = '#ff4d4d';
      ctx.fillRect(ambulanceX - 20, roadY - 90, 40, 20);
      ctx.fillStyle = '#1f2a44';
      ctx.beginPath();
      ctx.arc(ambulanceX - 35, roadY - 10, 14, 0, Math.PI * 2);
      ctx.arc(ambulanceX + 35, roadY - 10, 14, 0, Math.PI * 2);
      ctx.fill();

      const baseSpacing = 35;
      const approachSpacing = baseSpacing * (1 - params.sourceSpeed / 200);
      const recedeSpacing = baseSpacing * (1 + params.sourceSpeed / 200);
      ctx.strokeStyle = '#4c7be5';
      ctx.lineWidth = 2;
      for (let i = 1; i <= 6; i++) {
        ctx.beginPath();
        ctx.arc(ambulanceX + i * approachSpacing, roadY - 40, i * approachSpacing, -0.4, 0.4);
        ctx.stroke();
        ctx.beginPath();
        ctx.arc(ambulanceX - i * recedeSpacing, roadY - 40, i * recedeSpacing, Math.PI - 0.4, Math.PI + 0.4);
        ctx.stroke();
      }
      ctx.restore();
    }

    function drawThermal(ctx, w, h, params) {
      ctx.save();
      ctx.fillStyle = '#eff4ff';
      ctx.fillRect(0, 0, w, h);
      const trackY = h * 0.65;

      ctx.fillStyle = '#c3d2ec';
      ctx.fillRect(0, trackY, w, 12);

      const expansion = params.alpha * 1e-6 * params.deltaT;
      const railBase = w * 0.35;
      const railLength = railBase * (1 + expansion * 200);
      const gap = clamp(18 - expansion * 4000, 2, 18);
      ctx.fillStyle = '#d46a32';
      ctx.fillRect(w * 0.2, trackY - 20, railLength, 20);
      ctx.clearRect(w * 0.2 + railLength - gap, trackY - 20, gap, 20);

      ctx.strokeStyle = '#ff9b45';
      ctx.lineWidth = 3;
      ctx.beginPath();
      ctx.moveTo(w * 0.2, trackY - 32);
      ctx.lineTo(w * 0.2 + railLength - gap, trackY - 32);
      ctx.stroke();
      ctx.beginPath();
      ctx.moveTo(w * 0.2 + railLength, trackY - 32);
      ctx.lineTo(w * 0.2 + railLength + 40, trackY - 32);
      ctx.stroke();

      ctx.fillStyle = '#1f2a44';
      ctx.font = '14px Poppins, sans-serif';
      ctx.fillText(`ΔT = ${params.deltaT.toFixed(0)}°C`, w * 0.2, trackY - 70);
      ctx.fillText(`ΔL(1m) ≈ ${(expansion * 1000).toFixed(2)} mm`, w * 0.2, trackY - 50);
      ctx.fillText(`预留缝隙 ≈ ${gap.toFixed(1)} mm`, w * 0.2, trackY - 30);

      ctx.fillStyle = '#ff9b45';
      ctx.fillRect(w * 0.7, trackY - params.deltaT * 0.8, 20, params.deltaT * 0.8);
      ctx.strokeStyle = '#1f2a44';
      ctx.strokeRect(w * 0.7, trackY - 80, 20, 80);
      ctx.fillStyle = '#1f2a44';
      ctx.fillText('温度计', w * 0.68, trackY - 90);
      ctx.restore();
    }

    function drawMagnetic(ctx, w, h, params) {
      const centerX = w * 0.5;
      const centerY = h * 0.45;
      ctx.save();
      ctx.fillStyle = '#f4f7ff';
      ctx.fillRect(0, 0, w, h);
      ctx.fillStyle = '#d15b5b';
      ctx.fillRect(40, centerY - 80, 50, 160);
      ctx.fillStyle = '#4a6fca';
      ctx.fillRect(w - 90, centerY - 80, 50, 160);

      ctx.strokeStyle = '#cfd8ed';
      ctx.lineWidth = 2;
      for (let i = -3; i <= 3; i++) {
        ctx.beginPath();
        ctx.moveTo(90, centerY + i * 25);
        ctx.lineTo(w - 90, centerY + i * 25);
        ctx.stroke();
      }

      const radius = 110;
      const angle = params.time * params.velocity * params.magneticField * 0.2;
      const particleX = centerX + radius * Math.cos(angle);
      const particleY = centerY + radius * Math.sin(angle);
      ctx.fillStyle = '#ff9b45';
      ctx.beginPath();
      ctx.arc(particleX, particleY, 14, 0, Math.PI * 2);
      ctx.fill();

      drawArrow(ctx, particleX, particleY, particleX - Math.sin(angle) * 45, particleY + Math.cos(angle) * 45, '#4c7be5', 4);
      ctx.restore();
    }

    function drawEnergyFlow(ctx, w, h, params) {
      ctx.save();
      ctx.fillStyle = '#f9fbff';
      ctx.fillRect(0, 0, w, h);
      ctx.fillStyle = '#dde6f5';
      ctx.fillRect(w * 0.05, h * 0.2, w * 0.4, h * 0.6);

      const radiatorX = w * 0.1;
      ctx.fillStyle = '#c7d4ea';
      for (let i = 0; i < 6; i++) {
        ctx.fillRect(radiatorX + i * 30, h * 0.3, 20, h * 0.4);
      }

      const amplitude = params.tempDiff * 4;
      ctx.strokeStyle = '#ff9b45';
      ctx.lineWidth = 3;
      ctx.beginPath();
      for (let y = 0; y <= h; y += 6) {
        const x = radiatorX + 210 + Math.sin((y / 40) + params.time * 0.8) * amplitude;
        if (y === 0) ctx.moveTo(x, y);
        else ctx.lineTo(x, y);
      }
      ctx.stroke();
      ctx.fillStyle = '#1f2a44';
      ctx.font = '14px Poppins, sans-serif';
      ctx.fillText(`温差 ${params.tempDiff.toFixed(0)}°C → 对流更强`, radiatorX + 200, h * 0.3);
      ctx.restore();
    }

    function drawPressure(ctx, w, h, params) {
      const fluidTop = h * 0.2;
      ctx.save();
      ctx.fillStyle = '#e9f4ff';
      ctx.fillRect(0, 0, w, h);
      ctx.fillStyle = '#b2d9ff';
      ctx.fillRect(w * 0.1, fluidTop, w * 0.8, h * 0.6);

      const pressure = params.density * 1000 * g * params.depth;
      const areaSmall = 0.02;
      const areaLarge = 0.12;
      const outputForce = pressure * areaLarge;
      const lift = clamp(outputForce / 4500, 0, 1.4) * 90;

      const smallX = w * 0.25;
      const largeX = w * 0.7;
      const baseY = fluidTop + h * 0.5;

      ctx.fillStyle = '#f6f7fb';
      ctx.fillRect(smallX - 20, fluidTop - 30, 40, fluidTop - 10);
      ctx.fillRect(largeX - 50, fluidTop - 30, 100, fluidTop - 10);

      ctx.fillStyle = '#4a6fd8';
      ctx.fillRect(smallX - 18, baseY - 40, 36, 40);
      ctx.fillRect(largeX - 60, baseY - lift - 40, 120, 40);

      ctx.fillStyle = '#f1d5b9';
      ctx.beginPath();
      ctx.arc(smallX, baseY - 60 + Math.sin(params.time * 1.5) * 5, 20, 0, Math.PI * 2);
      ctx.fill();
      ctx.fillStyle = '#5a81e5';
      ctx.fillRect(smallX - 18, baseY - 50, 36, 50);

      ctx.fillStyle = '#d6dceb';
      ctx.fillRect(largeX - 90, baseY - lift - 80, 180, 40);
      ctx.fillStyle = '#4c7be5';
      ctx.beginPath();
      ctx.moveTo(largeX - 80, baseY - lift - 80);
      ctx.lineTo(largeX + 80, baseY - lift - 80);
      ctx.lineTo(largeX + 60, baseY - lift - 120);
      ctx.lineTo(largeX - 60, baseY - lift - 120);
      ctx.closePath();
      ctx.fill();
      ctx.fillStyle = '#1f2a44';
      ctx.fillRect(largeX - 50, baseY - lift - 70, 100, 30);

      drawArrow(ctx, smallX, baseY - 60, smallX, baseY - 120, '#ff9b45', 4);
      drawArrow(ctx, largeX, baseY - lift - 40, largeX, baseY - lift - 100, '#ff9b45', 6);

      ctx.fillStyle = '#1f2a44';
      ctx.font = '14px Poppins, sans-serif';
      ctx.fillText(`输入压强 P = ${(pressure / 1000).toFixed(1)} kPa`, w * 0.08, fluidTop - 40);
      ctx.fillText(`输出力 ≈ ${outputForce.toFixed(0)} N`, largeX - 90, baseY - lift - 140);
      ctx.fillText(`利用帕斯卡定律：P 传遍流体 → 大活塞抬起汽车`, w * 0.12, fluidTop + h * 0.62);

      ctx.strokeStyle = 'rgba(255,255,255,0.6)';
      ctx.lineWidth = 3;
      for (let i = 0; i < 6; i++) {
        ctx.beginPath();
        ctx.moveTo(w * 0.1, fluidTop + i * 30);
        ctx.lineTo(w * 0.9, fluidTop + i * 30 + Math.sin(params.time + i) * 6);
        ctx.stroke();
      }

      ctx.restore();
    }

    function drawCoulomb(ctx, w, h, params) {
      const leftX = w * 0.3;
      const rightX = w * 0.7;
      const centerY = h * 0.5;
      ctx.save();
      ctx.fillStyle = params.q1 >= 0 ? '#ff7878' : '#4c7be5';
      ctx.beginPath();
      ctx.ellipse(leftX, centerY - 20, 40, 55, 0, 0, Math.PI * 2);
      ctx.fill();
      ctx.fillStyle = '#fff';
      ctx.font = '18px Poppins, sans-serif';
      ctx.textAlign = 'center';
      ctx.fillText(params.q1 >= 0 ? '+' : '-', leftX, centerY - 10);
      ctx.strokeStyle = '#c0894a';
      ctx.beginPath();
      ctx.moveTo(leftX, centerY + 35);
      ctx.lineTo(leftX, centerY + 80);
      ctx.stroke();
      ctx.fillStyle = params.q2 >= 0 ? '#ff7878' : '#4c7be5';
      ctx.beginPath();
      ctx.ellipse(rightX, centerY - 20, 40, 55, 0, 0, Math.PI * 2);
      ctx.fill();
      ctx.fillStyle = '#fff';
      ctx.fillText(params.q2 >= 0 ? '+' : '-', rightX, centerY - 10);
      ctx.strokeStyle = '#c0894a';
      ctx.beginPath();
      ctx.moveTo(rightX, centerY + 35);
      ctx.lineTo(rightX, centerY + 80);
      ctx.stroke();
      const lines = 6;
      for (let i = -lines; i <= lines; i++) {
        const offset = (i / lines) * 40;
        ctx.strokeStyle = '#fcd6a8';
        ctx.beginPath();
        ctx.moveTo(leftX + 35, centerY + offset);
        ctx.bezierCurveTo(w / 2, centerY + offset + Math.sin(i) * 30, w / 2, centerY + offset - Math.sin(i) * 30, rightX - 35, centerY + offset);
        ctx.stroke();
      }
      const force = kElectro * Math.abs(params.q1 * 1e-6 * params.q2 * 1e-6) / Math.pow(params.distance, 2);
      const direction = params.q1 * params.q2 >= 0 ? -1 : 1;
      const arrowLen = clamp(force * 80, 25, 120);
      drawArrow(ctx, leftX + 35, centerY, leftX + 35 + direction * arrowLen, centerY, '#ff9b45', 4);
      drawArrow(ctx, rightX - 35, centerY, rightX - 35 - direction * arrowLen, centerY, '#ff9b45', 4);
      ctx.restore();
    }

    function drawInduction(ctx, w, h, params) {
      ctx.save();
      ctx.fillStyle = '#f5f3eb';
      ctx.fillRect(0, 0, w, h);
      ctx.fillStyle = '#d8c7a1';
      ctx.fillRect(0, h * 0.7, w, h * 0.3);

      const N = params.turns || 60;
      const speed = params.speed || 0.8;
      const coilX = w * 0.5;
      const coilY = h * 0.5;
      const coilR = 58;
      const coilW = 42;
      ctx.fillStyle = 'rgba(198,121,47,0.12)';
      ctx.fillRect(coilX - coilW, coilY - coilR, coilW * 2, coilR * 2);
      ctx.strokeStyle = '#c6792f';
      ctx.lineWidth = 4;
      const nLoops = 8 + Math.floor(N / 15);
      for (let i = 0; i < nLoops; i++) {
        const y = coilY - coilR + (i / Math.max(nLoops - 1, 1)) * (coilR * 2);
        ctx.beginPath();
        ctx.ellipse(coilX, y, coilW - 2, 8, 0, 0, Math.PI * 2);
        ctx.stroke();
      }
      ctx.strokeStyle = 'rgba(255,191,73,0.25)';
      ctx.lineWidth = 1;
      for (let i = -1; i <= 1; i++) {
        ctx.beginPath();
        ctx.ellipse(coilX, coilY, 28 + i * 6, 12, 0, 0, Math.PI * 2);
        ctx.stroke();
      }

      const range = 85;
      const phaseRate = speed * 1.4;
      const motion = Math.sin(params.time * phaseRate) * range;
      const magnetY = coilY + motion;
      const magnetH = 48;
      const magnetInCoil = magnetY > coilY - coilR + magnetH && magnetY < coilY + coilR - magnetH;
      ctx.fillStyle = '#ff6b6b';
      ctx.fillRect(coilX - 14, magnetY - magnetH, 28, magnetH);
      ctx.fillStyle = '#3c6dd0';
      ctx.fillRect(coilX - 14, magnetY, 28, magnetH);
      ctx.fillStyle = '#fff';
      ctx.font = '12px Poppins, sans-serif';
      ctx.fillText('N', coilX - 5, magnetY - 24);
      ctx.fillText('S', coilX - 5, magnetY + 26);

      const emf = (magnetInCoil ? 0.8 : 1.2) * speed * (N / 50) * (1.2 + 0.5 * Math.abs(Math.cos(params.time * phaseRate)));
      const emfClamp = clamp(emf, 0, 8);
      const pointerBaseX = w * 0.72;
      const pointerBaseY = coilY;
      ctx.fillStyle = '#fff';
      ctx.strokeStyle = '#8a8f9f';
      ctx.lineWidth = 4;
      ctx.beginPath();
      ctx.arc(pointerBaseX, pointerBaseY, 58, Math.PI * 0.78, Math.PI * 0.22, false);
      ctx.stroke();
      ctx.strokeStyle = '#ff9b45';
      ctx.lineWidth = 3;
      const deflection = clamp((emfClamp / 4 - 1) * 0.85, -0.9, 0.9);
      const angle = Math.PI * 0.5 + deflection * Math.PI * 0.25;
      ctx.beginPath();
      ctx.moveTo(pointerBaseX, pointerBaseY);
      ctx.lineTo(pointerBaseX + 48 * Math.cos(angle), pointerBaseY + 48 * Math.sin(angle));
      ctx.stroke();
      ctx.fillStyle = '#1f2a44';
      ctx.font = 'bold 16px Poppins, sans-serif';
      ctx.fillText(`|ε| ≈ ${emfClamp.toFixed(2)} V`, pointerBaseX - 42, pointerBaseY - 55);
      ctx.font = '11px Poppins, sans-serif';
      ctx.fillText('伏特表', pointerBaseX - 28, pointerBaseY + 68);

      const bulbX = w * 0.58;
      const bulbY = coilY - 20;
      ctx.fillStyle = emfClamp > 1.5 ? `rgba(255,220,100,${0.3 + Math.min(emfClamp / 6, 0.5)})` : 'rgba(180,180,180,0.4)';
      ctx.beginPath();
      ctx.arc(bulbX, bulbY, 22, 0, Math.PI * 2);
      ctx.fill();
      ctx.strokeStyle = '#8a8f9f';
      ctx.lineWidth = 2;
      ctx.stroke();
      ctx.fillStyle = '#1f2a44';
      ctx.font = '10px Poppins, sans-serif';
      ctx.fillText('灯泡', bulbX - 14, bulbY + 38);
      ctx.strokeStyle = '#5a5f6f';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(coilX + coilW + 10, coilY - 12);
      ctx.lineTo(bulbX - 20, bulbY);
      ctx.moveTo(coilX + coilW + 10, coilY + 12);
      ctx.lineTo(bulbX - 20, bulbY);
      ctx.stroke();

      ctx.fillStyle = '#1f2a44';
      ctx.font = '13px Poppins, sans-serif';
      ctx.fillText('法拉第定律 |ε| = N · ΔΦ/Δt  参考 PhET 法拉第定律', 22, 32);
      ctx.fillText(`匝数 N=${N}  磁铁从上往下穿过线圈 → 磁通变化 → 感应电动势 → 灯泡变亮`, 22, 52);
      ctx.fillText('楞次定律：感应电流阻碍磁通变化', 22, 72);
      ctx.restore();
    }

    function drawPhotoelectric(ctx, w, h, params) {
      ctx.save();
      ctx.fillStyle = '#1a1d28';
      ctx.fillRect(0, 0, w, h);
      ctx.fillStyle = '#2d3142';
      ctx.fillRect(0, h * 0.65, w, h * 0.35);

      const freq = params.frequency || 8;
      const intensity = clamp(params.intensity || 2.5, 1, 5);
      const workFunc = params.workFunction || 3.5;
      const hasPhoto = freq > workFunc * 0.4;

      const metalX = w * 0.35;
      const metalY = h * 0.5;
      ctx.fillStyle = '#8b7355';
      ctx.fillRect(metalX - 80, metalY - 50, 160, 100);
      ctx.strokeStyle = '#c9a86c';
      ctx.lineWidth = 2;
      for (let i = 0; i < 6; i++) {
        for (let j = 0; j < 4; j++) {
          ctx.strokeRect(metalX - 70 + i * 28, metalY - 40 + j * 22, 24, 18);
        }
      }

      const t = params.time * (1 + freq * 0.1);
      const photonCount = Math.min(12, Math.round(intensity * 3));
      for (let i = 0; i < photonCount; i++) {
        const px = metalX - 120 - (t * 80 + i * 35) % 160;
        const py = metalY - 60 + (i % 3) * 25;
        ctx.fillStyle = 'rgba(255,215,100,0.9)';
        ctx.beginPath();
        ctx.arc(px, py, 6, 0, Math.PI * 2);
        ctx.fill();
      }

      const electronCount = hasPhoto ? Math.min(8, Math.round(intensity * 2.5)) : 0;
      for (let i = 0; i < electronCount; i++) {
        const ex = metalX + 50 + Math.sin(t + i * 1.2) * 30;
        const ey = metalY - 80 - (t * 60 + i * 25) % 120;
        if (ey > metalY - 70) continue;
        ctx.fillStyle = 'rgba(100,180,255,0.95)';
        ctx.beginPath();
        ctx.arc(ex, ey, 5, 0, Math.PI * 2);
        ctx.fill();
      }

      ctx.fillStyle = '#3a4560';
      ctx.fillRect(w * 0.68, h * 0.35, 50, 80);
      ctx.fillStyle = '#ff9b45';
      const currentLevel = hasPhoto ? (0.2 + intensity * 0.12 * (0.7 + 0.3 * Math.sin(params.time * 3))) : 0.05;
      ctx.fillRect(w * 0.68 + 10, h * 0.35 + 60 - currentLevel * 50, 30, currentLevel * 50);
      ctx.strokeStyle = '#62729d';
      ctx.strokeRect(w * 0.68, h * 0.35, 50, 80);
      ctx.fillStyle = '#e8ecf4';
      ctx.font = '12px Poppins, sans-serif';
      ctx.fillText('光电流', w * 0.66, h * 0.32);
      ctx.fillText(`f=${freq}×10¹⁴Hz W₀=${workFunc}eV 光强×${intensity.toFixed(1)}`, 30, 50);
      ctx.fillText(hasPhoto ? 'E_k = hf − W₀ → 有光电子' : 'hf < W₀ → 无光电子', 30, 72);
      ctx.restore();
    }

    function drawAtomicLevel(ctx, w, h, params) {
      ctx.save();
      ctx.fillStyle = '#0f0f18';
      ctx.fillRect(0, 0, w, h);
      const tubeX = w * 0.5;
      const tubeY = h * 0.5;
      const voltage = params.voltage || 120;
      const current = clamp(params.current || 15, 5, 30);
      const jumpRate = 2 + (voltage / 80) * 2;
      const glow = 0.2 + (current / 30) * 0.5;

      ctx.strokeStyle = `rgba(255,80,80,${0.7 + glow * 0.3})`;
      ctx.lineWidth = 8;
      ctx.beginPath();
      ctx.ellipse(tubeX, tubeY, 100, 25, 0, 0, Math.PI * 2);
      ctx.stroke();
      ctx.fillStyle = `rgba(255,60,60,${0.1 + glow * 0.15})`;
      ctx.fill();

      const levels = [0, 35, 70, 110];
      const t = params.time * jumpRate;
      const jumpCount = Math.min(8, Math.round(3 + current / 5));
      for (let i = 0; i < jumpCount; i++) {
        const lvl = i % 3 + 1;
        const phase = (t + i * 0.7) % 2;
        const y = tubeY - levels[lvl] + (phase < 1 ? phase * 35 : 35 - (phase - 1) * 35);
        const x = tubeX - 70 + (i * 25) % 140;
        ctx.fillStyle = 'rgba(255,200,100,0.95)';
        ctx.beginPath();
        ctx.arc(x, y, 4, 0, Math.PI * 2);
        ctx.fill();
        if (phase > 0.5 && phase < 1) {
          ctx.fillStyle = 'rgba(255,80,80,0.8)';
          ctx.beginPath();
          ctx.arc(x + 15, (y + tubeY - 70) / 2, 3, 0, Math.PI * 2);
          ctx.fill();
        }
      }

      ctx.strokeStyle = 'rgba(255,255,255,0.2)';
      ctx.lineWidth = 1;
      ctx.setLineDash([4, 4]);
      for (let i = 1; i <= 3; i++) {
        ctx.beginPath();
        ctx.ellipse(tubeX, tubeY - levels[i], 85, 20, 0, 0, Math.PI * 2);
        ctx.stroke();
      }
      ctx.setLineDash([]);
      ctx.fillStyle = '#c8d0e0';
      ctx.font = '13px Poppins, sans-serif';
      ctx.fillText(`激发电压 U=${voltage}V 电流=${current}mA`, 30, 45);
      ctx.fillText('E_n − E_m = hf → 红色光子', 30, 68);
      ctx.restore();
    }

    function drawFission(ctx, w, h, params) {
      ctx.save();
      ctx.fillStyle = '#1c1e28';
      ctx.fillRect(0, 0, w, h);
      ctx.fillStyle = '#2a2d3a';
      ctx.fillRect(0, h * 0.7, w, h * 0.3);

      const controlRod = (params.controlRod || 40) / 100;
      const reactivity = params.reactivity || 1;
      const centerX = w * 0.5;
      const centerY = h * 0.45;
      const t = params.time * (1.2 - controlRod * 0.8) * reactivity;
      const cycle = t % 3;
      if (cycle < 1.2) {
        ctx.fillStyle = 'rgba(100,180,255,0.9)';
        ctx.beginPath();
        ctx.arc(centerX - 90, centerY - 20, 8, 0, Math.PI * 2);
        ctx.fill();
        ctx.beginPath();
        ctx.moveTo(centerX - 90, centerY - 20);
        ctx.lineTo(centerX - 90 + (1 - cycle / 1.2) * 160, centerY - 20);
        ctx.strokeStyle = 'rgba(100,180,255,0.6)';
        ctx.lineWidth = 3;
        ctx.stroke();
      }
      const split = cycle > 1.2 && cycle < 2.5;
      if (split) {
        const prog = (cycle - 1.2) / 1.3;
        ctx.fillStyle = 'rgba(255,180,80,0.9)';
        ctx.beginPath();
        ctx.ellipse(centerX - 30 - prog * 50, centerY, 25, 18, 0, 0, Math.PI * 2);
        ctx.fill();
        ctx.beginPath();
        ctx.ellipse(centerX + 30 + prog * 50, centerY, 25, 18, 0, 0, Math.PI * 2);
        ctx.fill();
        for (let i = 0; i < 3; i++) {
          const angle = (i / 3) * Math.PI * 2 + prog * 2;
          ctx.fillStyle = 'rgba(255,220,100,0.95)';
          ctx.beginPath();
          ctx.arc(centerX + Math.cos(angle) * (40 + prog * 60), centerY + Math.sin(angle) * (40 + prog * 60), 6, 0, Math.PI * 2);
          ctx.fill();
        }
      } else if (cycle >= 2.5) {
        ctx.fillStyle = 'rgba(255,200,100,0.85)';
        ctx.beginPath();
        ctx.arc(centerX, centerY, 28, 0, Math.PI * 2);
        ctx.fill();
      } else if (cycle < 1.2) {
        ctx.fillStyle = 'rgba(255,200,100,0.85)';
        ctx.beginPath();
        ctx.arc(centerX, centerY, 28, 0, Math.PI * 2);
        ctx.fill();
      }
      ctx.fillStyle = '#a0a8c0';
      ctx.font = '13px Poppins, sans-serif';
      ctx.fillText('²³⁵U + n → 碎片 + 2~3n + 能量', 30, 42);
      ctx.fillText(`控制棒 ${(controlRod * 100).toFixed(0)}% ${controlRod > 0.6 ? '→ 反应减弱' : '→ 链式反应'}`, 30, 65);
      ctx.restore();
    }

    function drawGravityOrbit(ctx, w, h, params) {
      ctx.save();
      const bg = ctx.createRadialGradient(w/2, h/2, 0, w/2, h/2, w);
      bg.addColorStop(0, '#0a0c14');
      bg.addColorStop(1, '#1a1d2e');
      ctx.fillStyle = bg;
      ctx.fillRect(0, 0, w, h);
      for (let i = 0; i < 80; i++) {
        ctx.fillStyle = `rgba(255,255,255,${0.03 + Math.random() * 0.05})`;
        ctx.beginPath();
        ctx.arc(Math.random() * w, Math.random() * h, 1, 0, Math.PI * 2);
        ctx.fill();
      }

      const sunX = w * 0.5;
      const sunY = h * 0.5;
      const gr = ctx.createRadialGradient(sunX, sunY, 0, sunX, sunY, 55);
      gr.addColorStop(0, '#fff5d4');
      gr.addColorStop(0.4, '#ffd966');
      gr.addColorStop(1, 'rgba(255,180,50,0.3)');
      ctx.fillStyle = gr;
      ctx.beginPath();
      ctx.arc(sunX, sunY, 55, 0, Math.PI * 2);
      ctx.fill();

      const a = 140;
      const e = clamp(params.eccentricity || 0.6, 0.1, 0.9);
      const orbitSpeed = params.orbitSpeed || 0.15;
      const angle = params.time * orbitSpeed;
      const r = a * (1 - e * e) / (1 + e * Math.cos(angle));
      const earthX = sunX + r * Math.cos(angle) * 0.9;
      const earthY = sunY - r * Math.sin(angle) * 0.5;
      ctx.fillStyle = '#6ba3d0';
      ctx.beginPath();
      ctx.arc(earthX, earthY, 18, 0, Math.PI * 2);
      ctx.fill();
      ctx.strokeStyle = 'rgba(255,255,255,0.4)';
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.ellipse(sunX, sunY, a * 0.9, a * 0.45, 0, 0, Math.PI * 2);
      ctx.stroke();

      const lines = 6;
      for (let i = 0; i < lines; i++) {
        const frac = (i + 0.3) / lines;
        const lx = sunX + (earthX - sunX) * frac;
        const ly = sunY + (earthY - sunY) * frac;
        ctx.strokeStyle = `rgba(255,220,120,${0.15 + 0.1 * Math.sin(params.time + i)})`;
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(sunX, sunY);
        ctx.lineTo(lx, ly);
        ctx.stroke();
      }
      ctx.fillStyle = '#e0e8f0';
      ctx.font = '13px Poppins, sans-serif';
      ctx.fillText(`偏心率 e=${e.toFixed(2)} 公转速度×${orbitSpeed.toFixed(2)}`, 25, 38);
      ctx.fillText('地球', earthX + 22, earthY + 5);
      ctx.restore();
    }

    function drawBlackHole(ctx, w, h, params) {
      ctx.save();
      const bg = ctx.createRadialGradient(w/2, h/2, 0, w/2, h/2, w);
      bg.addColorStop(0, '#050510');
      bg.addColorStop(1, '#15182a');
      ctx.fillStyle = bg;
      ctx.fillRect(0, 0, w, h);
      ctx.fillStyle = 'rgba(255,255,255,0.06)';
      for (let i = 0; i < 60; i++) {
        ctx.beginPath();
        ctx.arc(80 + (i * 37) % (w - 100), 50 + (i * 29) % (h - 80), 1, 0, Math.PI * 2);
        ctx.fill();
      }

      const mass = clamp(params.mass || 1, 0.5, 1.5);
      const diskBright = clamp(params.diskBright || 1, 0.5, 1.5);
      const cx = w * 0.48;
      const cy = h * 0.5;
      const holeR = 35 + mass * 25;
      ctx.fillStyle = '#000';
      ctx.beginPath();
      ctx.arc(cx, cy, holeR, 0, Math.PI * 2);
      ctx.fill();
      ctx.strokeStyle = 'rgba(255,255,255,0.2)';
      ctx.lineWidth = 2;
      ctx.stroke();

      const diskAngle = params.time * (0.06 + mass * 0.04);
      ctx.save();
      ctx.translate(cx, cy);
      ctx.rotate(diskAngle);
      const diskGrad = ctx.createRadialGradient(0, 0, 0, 0, 0, 90 + mass * 40);
      diskGrad.addColorStop(0, `rgba(255,100,80,${0.3 * diskBright})`);
      diskGrad.addColorStop(0.5, `rgba(255,180,100,${0.2 * diskBright})`);
      diskGrad.addColorStop(1, 'rgba(255,200,150,0.05)');
      ctx.fillStyle = diskGrad;
      ctx.beginPath();
      ctx.ellipse(0, 0, 90 + mass * 35, 28 + mass * 10, 0, 0, Math.PI * 2);
      ctx.fill();
      ctx.restore();

      ctx.strokeStyle = 'rgba(200,220,255,0.35)';
      ctx.lineWidth = 2;
      for (let i = 0; i < 5; i++) {
        const bend = 0.3 + 0.15 * Math.sin(params.time + i);
        ctx.beginPath();
        ctx.moveTo(w * 0.15 + i * 25, 80);
        ctx.quadraticCurveTo(cx - 60 + i * 15, cy - 80, cx - 30, cy);
        ctx.quadraticCurveTo(cx + 80 + bend * 40, cy + 60, w * 0.85 - i * 20, h - 60);
        ctx.stroke();
      }
      ctx.fillStyle = '#b0b8d0';
      ctx.font = '12px Poppins, sans-serif';
      ctx.fillText(`质量×${mass.toFixed(1)} 吸积盘亮度×${diskBright.toFixed(1)}`, 25, 42);
      ctx.restore();
    }

    function drawHydroPower(ctx, w, h, params) {
      ctx.save();
      ctx.fillStyle = '#c8e0f5';
      ctx.fillRect(0, 0, w, h * 0.35);
      ctx.fillStyle = '#7eb8e8';
      ctx.fillRect(0, h * 0.35, w, h * 0.25);
      ctx.fillStyle = '#4a7ca8';
      ctx.fillRect(0, h * 0.6, w, h * 0.4);

      const damX = w * 0.55;
      ctx.fillStyle = '#8b9aab';
      ctx.fillRect(damX - 25, 0, 50, h);
      ctx.fillStyle = '#6b7b8e';
      ctx.fillRect(damX - 28, h * 0.32, 56, 25);

      const flow = clamp(params.flow || 1.5, 0.5, 3);
      const head = clamp(params.head || 1, 0.6, 1.4);
      const flowY = h * 0.38 + (params.time * 40 * flow) % (60 * head);
      ctx.fillStyle = 'rgba(255,255,255,0.5)';
      const streamCount = Math.min(6, Math.round(flow * 2) + 1);
      for (let i = 0; i < streamCount; i++) {
        ctx.fillRect(damX - 15 + i * (30 / streamCount), h * 0.36, 4, flowY - h * 0.36);
      }
      ctx.fillStyle = '#5a9bd4';
      ctx.beginPath();
      ctx.moveTo(damX - 20, flowY);
      ctx.lineTo(damX + 20, flowY);
      ctx.lineTo(damX + 25, flowY + 40);
      ctx.lineTo(damX - 25, flowY + 40);
      ctx.closePath();
      ctx.fill();

      const turbineY = h * 0.58;
      const turbineAngle = params.time * (2 + flow * 1.5);
      ctx.save();
      ctx.translate(damX, turbineY);
      ctx.rotate(turbineAngle);
      ctx.fillStyle = '#3d5a6c';
      for (let i = 0; i < 6; i++) {
        ctx.rotate(Math.PI / 3);
        ctx.fillRect(-8, -45, 16, 90);
      }
      ctx.restore();
      ctx.fillStyle = '#2d3d4a';
      ctx.fillRect(damX - 35, turbineY - 15, 70, 30);

      ctx.fillStyle = '#ff6b6b';
      const wireLen = 15 + 8 * Math.sin(params.time * 2);
      ctx.lineWidth = 4;
      ctx.beginPath();
      ctx.moveTo(damX + 45, turbineY);
      ctx.lineTo(damX + 90, turbineY - 20);
      ctx.lineTo(damX + 130, turbineY - 20);
      ctx.stroke();
      ctx.fillStyle = '#e8ecf4';
      ctx.font = '13px Poppins, sans-serif';
      ctx.fillText(`流量×${flow.toFixed(1)} 水头×${head.toFixed(1)} → 势能→电能`, 25, 38);
      ctx.fillText('水库', damX - 55, h * 0.2);
      ctx.fillText('水轮机', damX - 28, turbineY + 45);
      ctx.restore();
    }

    function drawEddyCurrent(ctx, w, h, params) {
      ctx.save();
      ctx.fillStyle = '#f2f4f8';
      ctx.fillRect(0, 0, w, h);
      ctx.fillStyle = '#d4d8e4';
      ctx.fillRect(0, h * 0.68, w, h * 0.32);

      const tubeX = w * 0.5;
      const tubeTop = 50;
      const tubeH = h * 0.6;
      const grad = ctx.createLinearGradient(tubeX - 50, 0, tubeX + 50, 0);
      grad.addColorStop(0, '#c0b8a8');
      grad.addColorStop(0.5, '#e8e0d0');
      grad.addColorStop(1, '#b8b0a0');
      ctx.fillStyle = grad;
      ctx.fillRect(tubeX - 35, tubeTop, 70, tubeH);
      ctx.strokeStyle = '#8a8278';
      ctx.lineWidth = 2;
      ctx.strokeRect(tubeX - 35, tubeTop, 70, tubeH);

      const magnetStr = clamp(params.magnetStrength || 1, 0.5, 1.5);
      const conduct = clamp(params.tubeConduct || 1, 0.5, 1.5);
      const fallSpeed = 0.5 / (1 + magnetStr * conduct * 0.4);
      const magnetY = tubeTop + 40 + (params.time * 70 * fallSpeed) % (tubeH - 50);
      ctx.fillStyle = '#e05050';
      ctx.fillRect(tubeX - 18, magnetY - 25, 36, 25);
      ctx.fillStyle = '#4050a0';
      ctx.fillRect(tubeX - 18, magnetY, 36, 25);
      ctx.fillStyle = '#fff';
      ctx.font = '12px sans-serif';
      ctx.textAlign = 'center';
      ctx.fillText('N', tubeX, magnetY - 10);
      ctx.fillText('S', tubeX, magnetY + 12);
      ctx.textAlign = 'left';

      const ringAlpha = 0.15 + magnetStr * conduct * 0.12;
      for (let i = 0; i < 4; i++) {
        const ringY = magnetY - 15 + i * 12;
        ctx.strokeStyle = `rgba(80,140,255,${ringAlpha + 0.1 * Math.sin(params.time * 2 + i)})`;
        ctx.lineWidth = 2 + magnetStr * 0.5;
        ctx.setLineDash([6, 4]);
        ctx.beginPath();
        ctx.ellipse(tubeX, ringY, 42 + conduct * 5, 12, 0, 0, Math.PI * 2);
        ctx.stroke();
        ctx.setLineDash([]);
      }
      ctx.fillStyle = '#3a4560';
      ctx.font = '13px Poppins, sans-serif';
      ctx.fillText(`磁铁×${magnetStr.toFixed(1)} 电导×${conduct.toFixed(1)} → 阻尼越大下落越慢`, 25, 38);
      ctx.fillText('楞次定律', 25, 58);
      ctx.restore();
    }

    function drawMechanicalEnergy(ctx, w, h, params) {
      ctx.save();
      ctx.fillStyle = '#f0f4f8';
      ctx.fillRect(0, 0, w, h);
      const m = params.mass || 1;
      const L_phys = 0.5 + (params.length || 80) / 80;
      const angle0 = (params.angle || 30) * Math.PI / 180;
      const omega = Math.sqrt(g / L_phys);
      const theta = angle0 * Math.cos(omega * params.time);
      const h_phys = L_phys * (1 - Math.cos(theta));
      const v_phys = L_phys * omega * Math.abs(Math.sin(omega * params.time));
      const ep = m * g * h_phys;
      const ek = 0.5 * m * v_phys * v_phys;
      const total = ep + ek;

      const pivotX = w * 0.5;
      const pivotY = h * 0.2;
      const scale = 95;
      const bobX = pivotX + scale * L_phys * Math.sin(theta);
      const bobY = pivotY + scale * L_phys * Math.cos(theta);

      ctx.strokeStyle = '#6b7b8e';
      ctx.lineWidth = 3;
      ctx.beginPath();
      ctx.moveTo(pivotX, pivotY);
      ctx.lineTo(bobX, bobY);
      ctx.stroke();
      ctx.fillStyle = '#3d5a6c';
      ctx.beginPath();
      ctx.arc(pivotX, pivotY, 8, 0, Math.PI * 2);
      ctx.fill();
      ctx.fillStyle = '#e8a030';
      ctx.beginPath();
      ctx.arc(bobX, bobY, 22, 0, Math.PI * 2);
      ctx.fill();
      ctx.strokeStyle = '#2d3142';
      ctx.lineWidth = 2;
      ctx.stroke();

      ctx.fillStyle = '#1f2a44';
      ctx.font = '13px Poppins, sans-serif';
      ctx.fillText(`E = E_k + E_p = 常量  (m=${m} kg, L≈${L_phys.toFixed(2)} m)`, 24, 42);
      ctx.fillText(`E_p = mgh = ${ep.toFixed(1)} J   E_k = ½mv² = ${ek.toFixed(1)} J`, 24, 62);
      ctx.fillText(`总机械能 E = ${total.toFixed(1)} J`, 24, 82);
      ctx.restore();
    }

    function drawPulley(ctx, w, h, params) {
      ctx.save();
      const grad = ctx.createLinearGradient(0, 0, w, h);
      grad.addColorStop(0, '#e8ecf4');
      grad.addColorStop(1, '#d8dce8');
      ctx.fillStyle = grad;
      ctx.fillRect(0, 0, w, h);
      const px = w * 0.5;
      const py = h * 0.2;
      const n = Math.max(1, Math.round(params.ropes || 2));
      const G = params.weight || 100;
      const F = G / n;
      const boxScale = 0.6 + (G / 250) * 0.5;
      const boxW = 60 * boxScale;
      const boxH = 44 * boxScale;
      const boxY = h * 0.52 + (n === 1 ? 15 : 0);
      const pulleyR = 26 + n * 2;

      ctx.shadowColor = 'rgba(0,0,0,0.25)';
      ctx.shadowBlur = 8;
      ctx.shadowOffsetY = 4;
      const rimGrad = ctx.createRadialGradient(px - 8, py - 8, 0, px, py, pulleyR + 4);
      rimGrad.addColorStop(0, '#b0b8c8');
      rimGrad.addColorStop(0.5, '#8a96a8');
      rimGrad.addColorStop(1, '#6a7688');
      ctx.fillStyle = rimGrad;
      ctx.beginPath();
      ctx.arc(px, py, pulleyR + 4, 0, Math.PI * 2);
      ctx.fill();
      ctx.strokeStyle = '#5a6478';
      ctx.lineWidth = 3;
      ctx.stroke();
      ctx.fillStyle = '#4a5568';
      ctx.beginPath();
      ctx.arc(px, py, 10, 0, Math.PI * 2);
      ctx.fill();
      ctx.shadowBlur = 0;
      ctx.shadowOffsetY = 0;
      for (let i = 0; i < n; i++) {
        const t = n === 1 ? 0.5 : i / (n - 1);
        const segX = px - pulleyR * 0.9 + t * (pulleyR * 1.8);
        const ropeGrad = ctx.createLinearGradient(segX, py, segX, boxY);
        ropeGrad.addColorStop(0, '#7a8a9e');
        ropeGrad.addColorStop(1, '#5a6a7e');
        ctx.strokeStyle = ropeGrad;
        ctx.lineWidth = 4 + n * 0.5;
        ctx.beginPath();
        ctx.moveTo(segX, py + pulleyR);
        ctx.lineTo(segX, boxY);
        ctx.stroke();
      }
      ctx.shadowColor = 'rgba(0,0,0,0.2)';
      ctx.shadowBlur = 6;
      ctx.shadowOffsetY = 3;
      ctx.fillStyle = '#6b5c4a';
      ctx.fillRect(px - boxW / 2, boxY, boxW, boxH);
      ctx.strokeStyle = '#4a3c2a';
      ctx.lineWidth = 2;
      ctx.strokeRect(px - boxW / 2, boxY, boxW, boxH);
      ctx.shadowBlur = 0;
      ctx.fillStyle = '#1f2a44';
      ctx.font = '12px Poppins, sans-serif';
      ctx.fillText(`G=${G} N`, px - 22, boxY + boxH / 2 + 4);
      const handX = px - 85;
      const handY = py + 48;
      ctx.strokeStyle = '#3d6bb5';
      ctx.lineWidth = 5;
      ctx.beginPath();
      ctx.moveTo(px - pulleyR, py + pulleyR * 0.6);
      ctx.lineTo(handX + 10, handY);
      ctx.stroke();
      ctx.fillStyle = '#4c7be5';
      ctx.font = 'bold 13px Poppins, sans-serif';
      ctx.fillText(`F = G/n = ${F.toFixed(0)} N`, handX - 48, handY - 12);
      ctx.fillStyle = '#1f2a44';
      ctx.font = '13px Poppins, sans-serif';
      ctx.fillText(`滑轮组 n=${n} 段绳  G=${G} N  →  F = G/${n} = ${F.toFixed(0)} N`, 24, 46);
      ctx.fillText('省力不省功  调节 n、G 观察拉力与重物大小', 24, 64);
      ctx.restore();
    }

    function drawLens(ctx, w, h, params) {
      ctx.save();
      ctx.fillStyle = '#f8fafc';
      ctx.fillRect(0, 0, w, h);
      const lensX = w * 0.5;
      const lensY = h * 0.5;
      const u = params.objectDist || 150;
      const f = params.focal || 80;
      const v = (u > f) ? (u * f) / (u - f) : 0;
      const pxPerCm = 2.2;
      const objH = 28;
      const objX = lensX - u * pxPerCm;
      const imgX = v > 0 ? lensX + v * pxPerCm : lensX + 50;
      const imgH = v > 0 ? objH * (v / u) : 0;

      ctx.strokeStyle = 'rgba(76,123,229,0.9)';
      ctx.lineWidth = 3;
      ctx.beginPath();
      ctx.moveTo(lensX, 0);
      ctx.lineTo(lensX, h);
      ctx.stroke();
      ctx.setLineDash([8, 6]);
      ctx.strokeStyle = 'rgba(100,100,100,0.5)';
      ctx.beginPath();
      ctx.moveTo(lensX - 25, lensY - 60);
      ctx.lineTo(lensX + 25, lensY + 60);
      ctx.moveTo(lensX - 25, lensY + 60);
      ctx.lineTo(lensX + 25, lensY - 60);
      ctx.stroke();
      ctx.setLineDash([]);
      ctx.fillStyle = 'rgba(200,220,255,0.4)';
      ctx.fillRect(lensX - 26, lensY - 62, 52, 124);
      ctx.strokeStyle = '#4c7be5';
      ctx.strokeRect(lensX - 26, lensY - 62, 52, 124);

      ctx.fillStyle = '#ff9b45';
      ctx.fillRect(objX - 6, lensY - objH, 12, objH);
      ctx.fillStyle = '#1f2a44';
      ctx.font = '11px Poppins, sans-serif';
      ctx.fillText('物', objX - 22, lensY - objH - 4);
      ctx.fillText(`u=${u} cm`, objX - 24, lensY + 20);

      if (v > 0) {
        ctx.fillStyle = '#4c7be5';
        ctx.fillRect(imgX - 6, lensY - imgH, 12, imgH);
        ctx.fillText('像', imgX + 10, lensY - imgH - 4);
        ctx.fillText(`v=${v.toFixed(0)} cm`, imgX - 20, lensY + 20);
        ctx.strokeStyle = 'rgba(255,100,80,0.7)';
        ctx.lineWidth = 2;
        ctx.setLineDash([4, 4]);
        ctx.beginPath();
        ctx.moveTo(objX, lensY - objH / 2);
        ctx.lineTo(lensX, lensY);
        ctx.lineTo(imgX, lensY - imgH / 2);
        ctx.stroke();
        ctx.setLineDash([]);
      }

      ctx.fillStyle = '#1f2a44';
      ctx.font = '12px Poppins, sans-serif';
      ctx.fillText(`1/u + 1/v = 1/f   (u=${u} cm, f=${f} cm)`, 24, 42);
      ctx.fillText(v > 0 ? `像距 v = uf/(u−f) = ${v.toFixed(0)} cm` : 'u ≤ f 成虚像', 24, 60);
      ctx.restore();
    }

    function drawJoule(ctx, w, h, params) {
      ctx.save();
      ctx.fillStyle = '#1a1d28';
      ctx.fillRect(0, 0, w, h);
      const I = params.current || 2;
      const R = params.resistance || 5;
      const t = params.timeJoule || 2;
      const Q = I * I * R * t;
      const heat = Math.min(1, 0.15 + Q / 1200);

      const coilX = w * 0.5;
      const coilY = h * 0.5;
      const grad = ctx.createRadialGradient(coilX, coilY, 0, coilX, coilY, 90);
      grad.addColorStop(0, `rgba(255,${80 + heat * 120},50,0.9)`);
      grad.addColorStop(0.6, `rgba(200,${60 + heat * 80},30,0.5)`);
      grad.addColorStop(1, 'rgba(80,40,20,0.2)');
      ctx.fillStyle = grad;
      ctx.beginPath();
      ctx.arc(coilX, coilY, 85, 0, Math.PI * 2);
      ctx.fill();
      ctx.strokeStyle = `rgba(255,${150 + heat * 80},80,0.8)`;
      ctx.lineWidth = 4;
      for (let i = 0; i < 8; i++) {
        ctx.beginPath();
        ctx.arc(coilX, coilY, 35 + i * 6, 0, Math.PI * 2);
        ctx.stroke();
      }
      ctx.fillStyle = '#e8ecf4';
      ctx.font = '14px Poppins, sans-serif';
      ctx.fillText(`Q = I² R t`, 24, 42);
      ctx.fillText(`I=${I} A  R=${R} Ω  t=${t} s  →  Q = I²Rt = ${Q.toFixed(0)} J`, 24, 64);
      ctx.fillText('电流越大、电阻越大、时间越长，发热越多', 24, 86);
      ctx.restore();
    }

    function drawParallel(ctx, w, h, params) {
      ctx.save();
      const r1 = params.r1 || 20;
      const r2 = params.r2 || 30;
      const u = params.voltage || 6;
      const invR = 1 / r1 + 1 / r2;
      const rTotal = 1 / invR;
      const i1 = u / r1;
      const i2 = u / r2;
      const iTotal = i1 + i2;
      const t = params.time || 0;
      const centerY = h * 0.42;
      const batX = 90;
      const topY = centerY - 72;
      const botY = centerY + 72;
      const junctL = 200;
      const junctR = 320;
      const wireTop = topY;
      const wireBot = botY;

      const bg = ctx.createLinearGradient(0, 0, 0, h);
      bg.addColorStop(0, '#e8eef6');
      bg.addColorStop(0.6, '#f0f4fa');
      bg.addColorStop(1, '#dce2ec');
      ctx.fillStyle = bg;
      ctx.fillRect(0, 0, w, h);
      ctx.fillStyle = 'rgba(220,230,245,0.5)';
      ctx.setLineDash([8, 6]);
      ctx.strokeStyle = 'rgba(76,123,229,0.2)';
      ctx.lineWidth = 2;
      ctx.strokeRect(20, 18, w - 40, h - 95);
      ctx.setLineDash([]);

      const resistToColor = (r) => {
        const t0 = clamp((r - 10) / 40, 0, 1);
        const red = Math.round(230 - t0 * 120);
        const green = Math.round(180 - t0 * 150);
        const blue = Math.round(200 - t0 * 80);
        return `rgb(${red},${green},${blue})`;
      };
      ctx.fillStyle = '#2d3548';
      ctx.fillRect(batX - 18, centerY - 28, 36, 56);
      ctx.strokeStyle = '#1a1f2e';
      ctx.lineWidth = 2;
      ctx.strokeRect(batX - 18, centerY - 28, 36, 56);
      ctx.fillStyle = '#4c7be5';
      ctx.font = 'bold 12px Poppins, sans-serif';
      ctx.fillText(`${u} V`, batX - 14, centerY + 4);
      ctx.fillStyle = '#1f2a44';
      ctx.font = '10px Poppins, sans-serif';
      ctx.fillText('电源', batX - 12, centerY - 36);

      ctx.strokeStyle = '#3d4f5f';
      ctx.lineWidth = 4;
      ctx.beginPath();
      ctx.moveTo(batX + 18, centerY);
      ctx.lineTo(junctL, centerY);
      ctx.lineTo(junctL, wireTop);
      ctx.lineTo(junctR, wireTop);
      ctx.lineTo(junctR, centerY);
      ctx.lineTo(junctL, centerY);
      ctx.lineTo(junctL, wireBot);
      ctx.lineTo(junctR, wireBot);
      ctx.lineTo(junctR, centerY);
      ctx.lineTo(batX - 18, centerY);
      ctx.stroke();

      const r1Color = resistToColor(r1);
      const r2Color = resistToColor(r2);
      const boxW = 52;
      const boxH = 28;
      ctx.shadowColor = 'rgba(0,0,0,0.15)';
      ctx.shadowBlur = 6;
      ctx.fillStyle = r1Color;
      ctx.fillRect(junctL + 24, wireTop - boxH / 2, boxW, boxH);
      ctx.strokeStyle = '#2d3142';
      ctx.lineWidth = 2;
      ctx.strokeRect(junctL + 24, wireTop - boxH / 2, boxW, boxH);
      ctx.fillStyle = '#1f2a44';
      ctx.font = 'bold 11px Poppins, sans-serif';
      ctx.fillText(`R₁=${r1}Ω`, junctL + 30, wireTop + 4);
      ctx.font = '9px Poppins, sans-serif';
      ctx.fillStyle = '#5a6478';
      ctx.fillText('阻碍电流', junctL + 26, wireTop + 18);
      ctx.fillStyle = r2Color;
      ctx.fillRect(junctL + 24, wireBot - boxH / 2, boxW, boxH);
      ctx.strokeRect(junctL + 24, wireBot - boxH / 2, boxW, boxH);
      ctx.fillStyle = '#1f2a44';
      ctx.font = 'bold 11px Poppins, sans-serif';
      ctx.fillText(`R₂=${r2}Ω`, junctL + 30, wireBot + 4);
      ctx.font = '9px Poppins, sans-serif';
      ctx.fillStyle = '#5a6478';
      ctx.fillText('阻碍电流', junctL + 26, wireBot + 18);
      ctx.shadowBlur = 0;

      const particleSpeed = 0.12 + iTotal * 0.04;
      const drawParticles = (x0, y0, x1, y1, count, brightness) => {
        const dx = x1 - x0;
        const dy = y1 - y0;
        const len = Math.hypot(dx, dy) || 1;
        const ux = dx / len;
        const uy = dy / len;
        for (let i = 0; i < count; i++) {
          const phase = (t * particleSpeed * 80 + i * (60 / count)) % (len + 30);
          const px = x0 + ux * phase;
          const py = y0 + uy * phase;
          if (phase <= len + 8) {
            const alpha = brightness * (0.5 + 0.5 * Math.sin(t * 3 + i));
            const r = 2.5 + (iTotal / 2) * 0.3;
            ctx.fillStyle = `rgba(76,140,255,${alpha})`;
            ctx.beginPath();
            ctx.arc(px, py, r, 0, Math.PI * 2);
            ctx.fill();
          }
        }
      };
      const mainCount = 14 + Math.round(iTotal * 4);
      drawParticles(batX + 18, centerY, junctL, centerY, mainCount, 0.9);
      drawParticles(junctR, centerY, batX - 18, centerY, mainCount, 0.9);
      drawParticles(junctL, wireTop, junctR, wireTop, Math.max(4, Math.round(i1 * 8)), 0.5 + i1 * 0.15);
      drawParticles(junctL, wireBot, junctR, wireBot, Math.max(4, Math.round(i2 * 8)), 0.5 + i2 * 0.15);
      drawParticles(junctL, centerY, junctL, wireTop, Math.max(3, Math.round(i1 * 6)), 0.5 + i1 * 0.12);
      drawParticles(junctL, wireBot, junctL, centerY, Math.max(3, Math.round(i2 * 6)), 0.5 + i2 * 0.12);
      drawParticles(junctR, wireTop, junctR, centerY, Math.max(3, Math.round(i1 * 6)), 0.5 + i1 * 0.12);
      drawParticles(junctR, centerY, junctR, wireBot, Math.max(3, Math.round(i2 * 6)), 0.5 + i2 * 0.12);

      const infoBoxX = w - 198;
      const infoBoxY = 20;
      const pulse = 0.92 + 0.08 * Math.sin(t * 5);
      ctx.fillStyle = `rgba(76,123,229,${pulse})`;
      ctx.fillRect(infoBoxX, infoBoxY, 176, 68);
      ctx.strokeStyle = 'rgba(76,123,229,0.5)';
      ctx.lineWidth = 2;
      ctx.strokeRect(infoBoxX, infoBoxY, 176, 68);
      ctx.fillStyle = '#1f2a44';
      ctx.font = 'bold 12px Poppins, sans-serif';
      ctx.fillText(`R总≈${rTotal.toFixed(1)} Ω`, infoBoxX + 10, infoBoxY + 22);
      ctx.fillText(`I总 = ${iTotal.toFixed(2)} A`, infoBoxX + 10, infoBoxY + 40);
      ctx.fillText(`I₁=${i1.toFixed(2)} A  I₂=${i2.toFixed(2)} A`, infoBoxX + 10, infoBoxY + 58);

      const sceneY = h - 72;
      ctx.fillStyle = '#a08060';
      ctx.fillRect(40, sceneY, 100, 50);
      ctx.fillStyle = '#c0a070';
      ctx.fillRect(44, sceneY + 4, 92, 42);
      ctx.fillStyle = '#4a4a4a';
      ctx.fillRect(70, sceneY + 20, 12, 28);
      ctx.fillStyle = '#6a6a6a';
      ctx.fillRect(72, sceneY + 18, 8, 6);
      const lampBright = clamp(iTotal / 1.2, 0, 1);
      const lampGlow = 8 + lampBright * 25;
      const lampR = 8 + lampBright * 4;
      ctx.shadowColor = `rgba(255,220,100,${0.4 + lampBright * 0.6})`;
      ctx.shadowBlur = lampGlow;
      ctx.fillStyle = lampBright <= 0.1 ? '#8a7a50' : `rgb(255,${Math.round(255 - lampBright * 80)},${Math.round(150 - lampBright * 100)})`;
      ctx.beginPath();
      ctx.arc(76, sceneY + 12, lampR, 0, Math.PI * 2);
      ctx.fill();
      ctx.shadowBlur = 0;
      ctx.fillStyle = '#1f2a44';
      ctx.font = '10px Poppins, sans-serif';
      ctx.fillText('台灯', 58, sceneY + 52);
      if (iTotal > 0.4) {
        ctx.fillStyle = lampBright > 0.5 ? '#2e7d32' : '#5a6478';
        ctx.font = '9px Poppins, sans-serif';
        ctx.fillText('电流↑ 灯更亮', 42, sceneY + 66);
      }
      ctx.fillStyle = '#3d4556';
      ctx.fillRect(180, sceneY + 15, 70, 40);
      ctx.fillStyle = '#2d3548';
      ctx.fillRect(184, sceneY + 19, 62, 32);
      ctx.fillStyle = '#1a1f2e';
      ctx.fillRect(188, sceneY + 23, 54, 20);
      ctx.fillText('电视', 198, sceneY + 52);
      ctx.fillStyle = '#5a5040';
      ctx.fillRect(300, sceneY + 25, 24, 28);
      ctx.fillStyle = '#7a7060';
      ctx.fillRect(304, sceneY + 28, 16, 22);
      ctx.fillText('插座', 298, sceneY + 52);
      ctx.fillStyle = '#5a6478';
      ctx.font = '11px Poppins, sans-serif';
      ctx.fillText('家庭并联：台灯与电视独立工作，电压相同', 28, sceneY - 6);
      ctx.restore();
    }

    function drawSpecificHeat(ctx, w, h, params) {
      ctx.save();
      ctx.fillStyle = '#f0f4f8';
      ctx.fillRect(0, 0, w, h);
      const c = params.specificHeat || 4.2;
      const m = params.mass || 1;
      const dT = params.deltaT || 20;
      const Q = c * m * dT;
      const beakerX = w * 0.5;
      const beakerBottom = h * 0.72;
      const fillHeight = 35 + (m / 3) * 45;
      const liquidTop = beakerBottom - fillHeight;
      const heatPhase = (params.time * 0.8) % 2;

      ctx.fillStyle = '#e8c870';
      ctx.beginPath();
      ctx.moveTo(beakerX - 50, beakerBottom + 25);
      ctx.lineTo(beakerX - 38, beakerBottom - 15);
      ctx.lineTo(beakerX + 38, beakerBottom - 15);
      ctx.lineTo(beakerX + 50, beakerBottom + 25);
      ctx.closePath();
      ctx.fill();
      ctx.strokeStyle = '#b89850';
      ctx.lineWidth = 2;
      ctx.stroke();
      for (let i = 0; i < 5; i++) {
        const yy = beakerBottom - 8 - i * 6 + Math.sin(params.time * 3 + i) * 2;
        ctx.fillStyle = `rgba(255,${150 - i * 25},80,${0.5 + heatPhase * 0.3})`;
        ctx.fillRect(beakerX - 35 + i * 3, yy, 8, 5);
      }
      ctx.fillStyle = '#8a9bab';
      ctx.lineWidth = 3;
      ctx.beginPath();
      ctx.moveTo(beakerX - 48, liquidTop);
      ctx.lineTo(beakerX - 38, beakerBottom - 5);
      ctx.lineTo(beakerX + 38, beakerBottom - 5);
      ctx.lineTo(beakerX + 48, liquidTop);
      ctx.closePath();
      ctx.stroke();
      const tempRed = Math.min(255, 180 + dT * 2);
      const tempColor = `rgba(255,${280 - tempRed},80,0.55)`;
      ctx.fillStyle = tempColor;
      ctx.fill();
      for (let i = 0; i < 8; i++) {
        const bx = beakerX - 30 + (params.time * 20 + i * 15) % 60;
        const by = liquidTop + 15 + (i % 3) * 12;
        if (by < beakerBottom - 15) {
          ctx.fillStyle = `rgba(255,255,255,${0.2 + 0.15 * Math.sin(params.time * 2 + i)})`;
          ctx.beginPath();
          ctx.arc(bx, by, 3, 0, Math.PI * 2);
          ctx.fill();
        }
      }
      const thermoX = beakerX + 55;
      const thermoH = 70;
      const level = 15 + (dT / 40) * thermoH + Math.sin(params.time) * 2;
      ctx.strokeStyle = '#4a5a6a';
      ctx.lineWidth = 4;
      ctx.strokeRect(thermoX - 6, beakerBottom - thermoH - 20, 12, thermoH + 10);
      ctx.fillStyle = '#e85a5a';
      ctx.fillRect(thermoX - 5, beakerBottom - 20 - level, 10, level);
      ctx.fillStyle = '#1f2a44';
      ctx.font = '10px Poppins, sans-serif';
      ctx.fillText('℃', thermoX + 10, beakerBottom - thermoH - 18);
      ctx.fillText(`${dT}°C`, thermoX - 22, beakerBottom - 22 - level);

      ctx.fillStyle = '#1f2a44';
      ctx.font = '13px Poppins, sans-serif';
      ctx.fillText(`Q = c × m × ΔT  c=${c}  m=${m} kg  ΔT=${dT}°C`, 24, 38);
      ctx.fillText(`Q = ${Q.toFixed(0)} kJ  调节 c、m、ΔT 观察液体体积与温度计`, 24, 56);
      ctx.fillText('比热容大 → 同温升吸热多', 24, 74);
      ctx.restore();
    }

    function drawSolidPressure(ctx, w, h, params) {
      ctx.save();
      ctx.fillStyle = '#f5f0e6';
      ctx.fillRect(0, 0, w, h);
      ctx.fillStyle = '#b8a88a';
      ctx.fillRect(0, h * 0.62, w, h * 0.38);
      const weight = params.weight || params.force || 600;
      const standMode = params.standMode !== undefined ? params.standMode : 0;
      const scenario = standMode === 1 ? 'one' : 'both';
      const singleArea = params.area || 0.02;
      const contactArea = scenario === 'one' ? singleArea : singleArea * 2;
      const F = weight;
      const S = contactArea;
      const P = F / S;
      const footX = w * 0.38;
      const groundY = h * 0.62;
      const size = Math.max(24, 50 - S * 800);
      const sink = Math.min(18, P / 5000);

      if (scenario === 'one') {
        ctx.fillStyle = '#4a5a6a';
        ctx.beginPath();
        ctx.ellipse(footX, groundY - size / 2, size * 0.6, size / 2, 0, 0, Math.PI * 2);
        ctx.fill();
        ctx.strokeStyle = '#3d4f5f';
        ctx.stroke();
      } else {
        const dx = 38;
        ctx.fillStyle = '#4a5a6a';
        ctx.beginPath();
        ctx.ellipse(footX - dx, groundY - size / 2, size * 0.6, size / 2, 0, 0, Math.PI * 2);
        ctx.ellipse(footX + dx, groundY - size / 2, size * 0.6, size / 2, 0, 0, Math.PI * 2);
        ctx.fill();
        ctx.strokeStyle = '#3d4f5f';
        ctx.stroke();
      }
      ctx.fillStyle = 'rgba(90,70,50,0.5)';
      ctx.beginPath();
      ctx.ellipse(footX, groundY + 6 + sink, size * 1.1, 10 + sink, 0, 0, Math.PI * 2);
      ctx.fill();
      ctx.fillStyle = '#1f2a44';
      ctx.font = '12px Poppins, sans-serif';
      ctx.fillText(`${scenario === 'one' ? '单脚' : '双脚'} S=${S.toFixed(2)} m²`, footX - 35, groundY - size - 10);
      ctx.fillText(`体重 F=${F} N`, footX - 28, groundY + 28 + sink);
      ctx.fillStyle = '#1f2a44';
      ctx.font = '13px Poppins, sans-serif';
      ctx.fillText(`P = F/S  (体重=${weight} N, 接触面积=${S.toFixed(2)} m²)`, 24, 38);
      ctx.fillText(`压强 P = ${P.toFixed(0)} Pa  ${scenario === 'one' ? '单脚着地压强更大' : '双脚分担压强'}`, 24, 56);
      ctx.fillText('生活：单脚/双脚、高跟鞋、履带坦克 都是改变 S 改变 P', 24, 74);
      ctx.restore();
    }

    function drawAmpere(ctx, w, h, params) {
      ctx.save();
      ctx.fillStyle = '#f0f4f8';
      ctx.fillRect(0, 0, w, h);
      const n = clamp(Math.round(params.turns || 8), 4, 16);
      const I = clamp(params.current || 1, 0.5, 3);
      const coilX = w * 0.5;
      const coilRadiusX = 72;
      const coilRadiusY = 14;
      const totalHeight = Math.min(n * 22, h * 0.55);
      const spacing = n > 1 ? totalHeight / (n - 1) : 0;
      const startY = h * 0.5 - totalHeight / 2;

      const wireWidth = 2 + I * 1.4;
      const wireAlpha = 0.5 + I * 0.2;
      ctx.strokeStyle = `rgba(76,123,229,${wireAlpha})`;
      ctx.lineWidth = wireWidth;
      for (let i = 0; i < n; i++) {
        const y = startY + i * spacing;
        ctx.beginPath();
        ctx.ellipse(coilX, y, coilRadiusX, coilRadiusY, 0, 0, Math.PI * 2);
        ctx.stroke();
      }
      ctx.fillStyle = '#2d3142';
      ctx.font = `${12 + Math.round(I)}px Poppins, sans-serif`;
      for (let i = 0; i < n; i++) {
        const y = startY + i * spacing;
        ctx.fillText('⊗', coilX - coilRadiusX - 6, y + 4);
        ctx.fillText('⊙', coilX + coilRadiusX - 4, y + 4);
      }

      const numLines = 4 + Math.round(I * 2.5);
      const lineAlpha = 0.12 + I * 0.14;
      const lineWidth = 0.8 + I * 0.5;
      const fieldScale = 0.8 + I * 0.25;
      ctx.setLineDash([5, 6]);
      for (let k = 0; k < numLines; k++) {
        const r0 = (25 + k * (55 / Math.max(numLines - 1, 1))) * fieldScale;
        const r1 = r0 * (0.4 + 0.15 * Math.sin(params.time + k * 0.7));
        ctx.strokeStyle = `rgba(76,123,229,${lineAlpha * (0.8 + 0.2 * Math.sin(params.time * 0.5 + k))})`;
        ctx.lineWidth = lineWidth;
        ctx.beginPath();
        for (let a = 0; a <= Math.PI * 2; a += 0.08) {
          const r = r1 + (r0 - r1) * Math.abs(Math.sin(a * 2));
          const x = coilX + r * Math.cos(a);
          const y = h * 0.5 + r * Math.sin(a) * 0.35;
          if (a === 0) ctx.moveTo(x, y);
          else ctx.lineTo(x, y);
        }
        ctx.closePath();
        ctx.stroke();
      }
      ctx.setLineDash([]);

      ctx.fillStyle = '#1f2a44';
      ctx.font = '13px Poppins, sans-serif';
      ctx.fillText('安培定则：右手握螺线管，四指→电流 拇指→N极', 24, 38);
      ctx.fillText(`匝数 n=${n} → 螺线管长度  电流 I=${I.toFixed(2)} A → 导线粗细与磁感线密度`, 24, 56);
      ctx.fillText(`磁场 B∝nI，磁感线数量与亮度随 I 增加`, 24, 74);
      ctx.restore();
    }

    function drawFriction(ctx, w, h, params) {
      ctx.save();
      ctx.fillStyle = '#f8f6f2';
      ctx.fillRect(0, 0, w, h);
      const groundY = h * 0.72;
      ctx.fillStyle = '#b8ac98';
      ctx.fillRect(0, groundY, w, h - groundY);
      for (let i = 0; i < 40; i++) {
        ctx.fillStyle = `rgba(140,130,110,${0.3 + (params.mu || 0.4) * 0.4})`;
        ctx.fillRect((i * 28) % w, groundY + 2 + (i % 3) * 4, 6, 3);
      }
      const mu = clamp(params.mu || 0.4, 0.1, 0.9);
      const m = params.mass || 2;
      const Fapp = params.appliedForce || 6;
      const N = m * g;
      const FfMax = mu * N;
      const moving = Fapp > FfMax;
      const Ff = moving ? FfMax : Math.min(Fapp, FfMax);
      const a = moving ? (Fapp - FfMax) / m : 0;
      const blockW = 72;
      const blockH = 48;
      const baseX = w * 0.18;
      const disp = moving ? (params.time * 6 * Math.sqrt(a + 0.1)) % (w * 0.42) : 0;
      const blockX = baseX + disp;
      const blockY = groundY - blockH;

      ctx.fillStyle = '#6b7c8d';
      ctx.fillRect(blockX, blockY, blockW, blockH);
      ctx.strokeStyle = '#4a5a6a';
      ctx.lineWidth = 2;
      ctx.strokeRect(blockX, blockY, blockW, blockH);
      ctx.fillStyle = 'rgba(255,255,255,0.9)';
      ctx.font = '12px Poppins, sans-serif';
      ctx.fillText(`m = ${m} kg`, blockX + blockW / 2 - 22, blockY + blockH / 2 + 4);

      const arrowY = blockY + blockH / 2;
      const arrowLen = 26;
      const handX = blockX + blockW + 45;
      ctx.strokeStyle = '#5a4a3a';
      ctx.lineWidth = 4;
      ctx.beginPath();
      ctx.moveTo(blockX + blockW, arrowY);
      ctx.lineTo(handX - 8, arrowY);
      ctx.stroke();
      drawArrow(ctx, blockX + blockW, arrowY, blockX + blockW + arrowLen * Math.min(Fapp / 14, 1.4), arrowY, '#2e7dd0', 4);
      ctx.fillStyle = '#1f2a44';
      ctx.font = '11px Poppins, sans-serif';
      ctx.fillText(`F 拉 = ${Fapp} N`, blockX + blockW + 30, arrowY - 8);
      drawArrow(ctx, blockX, arrowY, blockX - arrowLen * Math.min(Ff / 10, 1.3), arrowY, '#c62828', 4);
      ctx.fillText(`F 摩擦 = ${Ff.toFixed(1)} N`, blockX - 78, arrowY + 4);
      drawArrow(ctx, blockX + blockW / 2, blockY + blockH, blockX + blockW / 2, blockY + blockH + 20, '#455a64', 3);
      ctx.fillText('N', blockX + blockW / 2 + 10, blockY + blockH + 26);
      drawArrow(ctx, blockX + blockW / 2, blockY, blockX + blockW / 2, blockY - 16, '#455a64', 3);
      ctx.fillText('G', blockX + blockW / 2 - 24, blockY - 6);

      const barX = w * 0.72;
      const barW = 22;
      const barH = 90;
      ctx.fillStyle = '#e0e0e0';
      ctx.fillRect(barX, h * 0.28, barW, barH);
      ctx.fillStyle = '#2e7dd0';
      const appH = (Fapp / 20) * barH;
      ctx.fillRect(barX + 2, h * 0.28 + barH - appH, barW - 4, appH);
      ctx.fillStyle = '#c62828';
      const fH = (Ff / 20) * barH;
      ctx.fillRect(barX + 2, h * 0.28 + barH - fH, barW - 4, Math.min(fH, barH - 4));
      ctx.fillStyle = '#1f2a44';
      ctx.font = '10px Poppins, sans-serif';
      ctx.fillText('力', barX - 4, h * 0.26);
      ctx.fillText('F拉', barX + barW + 2, h * 0.28 + barH - appH + 4);
      ctx.fillText('F摩', barX + barW + 2, h * 0.28 + barH - fH + 4);

      ctx.fillStyle = '#1f2a44';
      ctx.font = '13px Poppins, sans-serif';
      ctx.fillText(`F_f = μN = μmg  (μ=${mu.toFixed(2)}, N=${N.toFixed(0)} N)  参考 PhET 摩擦力`, 24, 38);
      ctx.fillText(`最大静摩擦 F_f,max = ${FfMax.toFixed(1)} N  →  ${moving ? '滑动 a = ' + a.toFixed(2) + ' m/s²' : '静止（F拉 = F摩擦）'}`, 24, 56);
      ctx.restore();
    }

    const ELEMENT_SYMBOLS = ['', 'H', 'He', 'Li', 'Be', 'B', 'C', 'N', 'O', 'F', 'Ne'];
    function drawBuildAtom(ctx, w, h, params) {
      ctx.save();
      ctx.fillStyle = '#0d1117';
      ctx.fillRect(0, 0, w, h);
      const p = clamp(Math.round(params.protons || 6), 1, 10);
      const n = clamp(Math.round(params.neutrons || 6), 0, 14);
      const e = clamp(Math.round(params.electrons || 6), 0, 12);
      const massNumber = p + n;
      const charge = p - e;
      const symbol = ELEMENT_SYMBOLS[p] || '?';
      const cx = w * 0.5;
      const cy = h * 0.5;
      const nucleusR = 16 + (p + n) * 1.2;
      ctx.fillStyle = 'rgba(220,80,80,0.95)';
      ctx.beginPath();
      ctx.arc(cx, cy, nucleusR, 0, Math.PI * 2);
      ctx.fill();
      ctx.strokeStyle = 'rgba(255,120,120,0.6)';
      ctx.lineWidth = 1;
      ctx.stroke();
      for (let i = 0; i < p; i++) {
        const ang = (i / p) * Math.PI * 2 + params.time * 0.1;
        ctx.fillStyle = '#ff6b6b';
        ctx.beginPath();
        ctx.arc(cx + nucleusR * 0.4 * Math.cos(ang), cy + nucleusR * 0.4 * Math.sin(ang), 4, 0, Math.PI * 2);
        ctx.fill();
      }
      for (let i = 0; i < n; i++) {
        const ang = (i / Math.max(n, 1)) * Math.PI * 2 + params.time * 0.08 + 0.5;
        ctx.fillStyle = '#9ca3af';
        ctx.beginPath();
        ctx.arc(cx + nucleusR * 0.35 * Math.cos(ang), cy + nucleusR * 0.35 * Math.sin(ang), 3.5, 0, Math.PI * 2);
        ctx.fill();
      }
      const shellRadii = [42, 70, 100];
      const perShell = [Math.min(e, 2), Math.min(Math.max(e - 2, 0), 6), Math.max(e - 8, 0)];
      let idx = 0;
      for (let shell = 0; shell < 3; shell++) {
        const num = perShell[shell];
        const r = shellRadii[shell];
        for (let j = 0; j < num; j++) {
          const angle = params.time * 0.25 + (idx++) * (Math.PI * 2 / Math.max(num, 1));
          const ex = cx + r * Math.cos(angle);
          const ey = cy - r * Math.sin(angle) * 0.55;
          ctx.fillStyle = '#58a6ff';
          ctx.beginPath();
          ctx.arc(ex, ey, 5, 0, Math.PI * 2);
          ctx.fill();
          ctx.strokeStyle = 'rgba(100,180,255,0.5)';
          ctx.lineWidth = 1;
          ctx.stroke();
        }
      }
      ctx.textAlign = 'left';
      ctx.fillStyle = '#e6edf3';
      ctx.font = 'bold 22px Poppins, sans-serif';
      ctx.fillText(symbol, 24, 38);
      const chargeStr = charge === 0 ? '' : (charge > 0 ? `⁺${charge === 1 ? '' : charge}` : `⁻${charge === -1 ? '' : -charge}`);
      if (chargeStr) {
        ctx.font = '14px Poppins, sans-serif';
        ctx.fillText(chargeStr, 24 + ctx.measureText(symbol).width + 4, 38);
      }
      ctx.font = '13px Poppins, sans-serif';
      ctx.fillText(`质量数 A = p + n = ${massNumber}`, 24, 58);
      ctx.fillText(`净电荷 = p − e = ${charge}  ${charge > 0 ? '阳离子' : charge < 0 ? '阴离子' : '中性原子'}  参考 PhET 建构原子`, 24, 76);
      ctx.restore();
    }

    function drawCapacitorLab(ctx, w, h, params) {
      ctx.save();
      ctx.fillStyle = '#e8ecf4';
      ctx.fillRect(0, 0, w, h);
      const area = clamp(params.area || 1, 0.3, 2);
      const sep = clamp(params.separation || 0.5, 0.2, 1.2);
      const V = clamp(params.voltage || 9, 0, 18);
      const C_rel = area / sep;
      const Q_rel = C_rel * V;
      const U_energy = 0.5 * C_rel * V * V;
      const cx = w * 0.5;
      const cy = h * 0.52;
      const plateW = 50 + area * 40;
      const plateD = 28;
      const gapPx = 18 + sep * 32;
      const skew = 0.22;

      ctx.fillStyle = '#1a1d28';
      ctx.fillRect(w * 0.12, h * 0.5 - 32, 26, 64);
      ctx.fillStyle = '#4c7be5';
      ctx.fillRect(w * 0.12 + 5, h * 0.5 - 26, 8, 52);
      ctx.fillStyle = '#e85a5a';
      ctx.fillRect(w * 0.12 + 13, h * 0.5 - 26, 8, 52);
      ctx.fillStyle = '#1f2a44';
      ctx.font = '10px Poppins, sans-serif';
      ctx.fillText(`${V} V`, w * 0.1, h * 0.5 + 42);

      const topPlateY = cy - gapPx / 2 - plateD;
      const botPlateY = cy + gapPx / 2;
      ctx.save();
      ctx.translate(cx, topPlateY + plateD / 2);
      ctx.transform(1, skew, 0, 1, 0, 0);
      ctx.fillStyle = '#e8e8ec';
      ctx.fillRect(-plateW / 2, -plateD / 2, plateW, plateD);
      ctx.strokeStyle = '#a0a8b8';
      ctx.lineWidth = 2;
      ctx.strokeRect(-plateW / 2, -plateD / 2, plateW, plateD);
      ctx.fillStyle = '#2d3142';
      ctx.font = 'bold 14px Poppins, sans-serif';
      ctx.fillText('+', -6, 5);
      ctx.restore();
      ctx.save();
      ctx.translate(cx, botPlateY + plateD / 2);
      ctx.transform(1, -skew, 0, 1, 0, 0);
      ctx.fillStyle = '#e0e0e4';
      ctx.fillRect(-plateW / 2, -plateD / 2, plateW, plateD);
      ctx.strokeStyle = '#a0a8b8';
      ctx.strokeRect(-plateW / 2, -plateD / 2, plateW, plateD);
      ctx.fillStyle = '#2d3142';
      ctx.fillText('−', -6, 5);
      ctx.restore();
      ctx.strokeStyle = 'rgba(76,123,229,0.45)';
      ctx.lineWidth = 2;
      const nLines = 3 + Math.round(V / 4);
      for (let i = 0; i < nLines; i++) {
        const x = cx - plateW / 3 + (i / Math.max(nLines - 1, 1)) * (plateW / 1.5);
        ctx.beginPath();
        ctx.moveTo(x, topPlateY + plateD);
        ctx.lineTo(x, botPlateY);
        ctx.stroke();
      }
      ctx.fillStyle = '#1f2a44';
      ctx.font = '11px Poppins, sans-serif';
      ctx.fillText('极板间距', cx + plateW / 2 + 12, cy - 4);
      ctx.beginPath();
      ctx.moveTo(cx + plateW / 2 + 4, topPlateY + plateD);
      ctx.lineTo(cx + plateW / 2 + 4, botPlateY);
      ctx.stroke();
      ctx.fillText(`${(sep * 6).toFixed(1)} mm`, cx + plateW / 2 + 8, cy + 4);
      ctx.fillText('极板面积', cx - plateW / 2 - 38, topPlateY - 8);
      ctx.fillText(`${Math.round(area * 200)} mm²`, cx - plateW / 2 - 42, topPlateY + 6);

      ctx.fillStyle = 'rgba(255,255,255,0.95)';
      ctx.fillRect(w - 142, 26, 135, 82);
      ctx.strokeStyle = '#8a9bab';
      ctx.strokeRect(w - 142, 26, 135, 82);
      ctx.fillStyle = '#1f2a44';
      ctx.font = '12px Poppins, sans-serif';
      ctx.fillText('电容 C ∝ A/d', w - 136, 46);
      ctx.fillText('电荷 Q = C·U', w - 136, 64);
      ctx.fillText(`电压 U = ${V} V`, w - 136, 82);
      ctx.fillText(`储能 W ∝ ${U_energy.toFixed(0)}`, w - 136, 100);
      ctx.restore();
    }

    function drawGeometricOptics(ctx, w, h, params) {
      ctx.save();
      ctx.fillStyle = '#fafcff';
      ctx.fillRect(0, 0, w, h);
      const u = params.objDist || 120;
      const f = params.focalLen || 60;
      const objH = params.objHeight || 25;
      const lensX = w * 0.52;
      const scale = 2.0;
      const objX = lensX - u * scale / 2;
      const v = u > f ? (u * f) / (u - f) : 0;
      const imgX = v > 0 ? lensX + v * scale / 2 : lensX + 35;
      const imgH = v > 0 ? objH * (v / u) : 0;
      const centerY = h * 0.5;
      const focalLeft = lensX - f * scale / 2;
      const focalRight = lensX + f * scale / 2;

      ctx.setLineDash([6, 6]);
      ctx.strokeStyle = 'rgba(0,0,0,0.25)';
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.moveTo(0, centerY);
      ctx.lineTo(w, centerY);
      ctx.stroke();
      ctx.setLineDash([]);
      ctx.fillStyle = 'rgba(0,0,0,0.5)';
      ctx.font = '11px Poppins, sans-serif';
      ctx.fillText('主光轴', lensX - 60, centerY - 8);

      ctx.fillStyle = 'rgba(200,220,255,0.55)';
      ctx.fillRect(lensX - 18, centerY - 72, 36, 144);
      ctx.strokeStyle = '#4c7be5';
      ctx.lineWidth = 2;
      ctx.strokeRect(lensX - 18, centerY - 72, 36, 144);
      ctx.fillStyle = '#1f2a44';
      ctx.font = '10px Poppins, sans-serif';
      ctx.fillText('F', focalLeft - 6, centerY + 4);
      ctx.fillText('F\'', focalRight + 2, centerY + 4);
      ctx.beginPath();
      ctx.moveTo(focalLeft, centerY - 6);
      ctx.lineTo(focalLeft, centerY + 6);
      ctx.stroke();
      ctx.beginPath();
      ctx.moveTo(focalRight, centerY - 6);
      ctx.lineTo(focalRight, centerY + 6);
      ctx.stroke();

      ctx.fillStyle = '#e65100';
      ctx.fillRect(objX - 5, centerY - objH, 10, objH);
      ctx.fillStyle = '#1f2a44';
      ctx.fillText('物', objX - 20, centerY - objH - 4);
      ctx.fillText(`u=${u}`, objX - 14, centerY + 20);
      if (v > 0) {
        ctx.fillStyle = '#1565c0';
        ctx.fillRect(imgX - 5, centerY - imgH, 10, imgH);
        ctx.fillText('像', imgX + 10, centerY - imgH - 4);
        ctx.fillText(`v=${v.toFixed(0)}`, imgX - 12, centerY + 20);
        ctx.strokeStyle = 'rgba(230,81,0,0.7)';
        ctx.setLineDash([3, 4]);
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(objX, centerY - objH / 2);
        ctx.lineTo(lensX, centerY - objH / 2);
        ctx.lineTo(imgX, centerY - imgH / 2);
        ctx.stroke();
        ctx.strokeStyle = 'rgba(21,101,192,0.7)';
        ctx.beginPath();
        ctx.moveTo(objX, centerY - objH / 2);
        ctx.lineTo(lensX, centerY);
        ctx.lineTo(imgX, centerY + imgH / 2);
        ctx.stroke();
        ctx.strokeStyle = 'rgba(76,175,80,0.7)';
        ctx.beginPath();
        ctx.moveTo(objX, centerY + objH / 2);
        ctx.lineTo(lensX, centerY);
        ctx.lineTo(imgX, centerY - imgH / 2);
        ctx.stroke();
        ctx.setLineDash([]);
      }
      ctx.fillStyle = '#1f2a44';
      ctx.font = '12px Poppins, sans-serif';
      ctx.fillText('几何光学：三条特殊光线  1/u + 1/v = 1/f  参考 PhET Geometric Optics', 24, 36);
      ctx.fillText(`物高 h=${objH}  像高 h\'=${v > 0 ? (objH * v / u).toFixed(0) : '—'}  放大率 m = v/u = ${v > 0 ? (v / u).toFixed(2) : '—'}`, 24, 54);
      ctx.restore();
    }

    const principles = [
      {
        id: 'newton',
        name: '牛顿第二定律',
        category: '力学',
        formula: 'F = m \\times a',
        formulaDetail: '判断合力方向后，把所有力作矢量合成得到 F，再用 F 与质量 m 推算加速度 a；若只沿一维运动，可直接代符号计算。',
        summary: '超市里的“空车 VS 满载车”清楚说明：在相同推力下，质量越大加速越慢。牛顿第二定律把“受力”与“运动状态改变”紧密相连，是分析一切动力学问题的核心工具。',
        teachingPoints: [
          '先画受力图并标注方向，再列 F = m·a 的分量形式。',
          '始终保持单位一致，推荐用牛顿(N)、千克(kg)、米每二次方秒(m/s²)。'
        ],
        formulaSteps: [
          '第一步：列受力方程，明确合力 F 的大小与方向。',
          '第二步：把质量 m 换算成 kg，必要时注意 kg↔g 的换算。',
          '第三步：代入 a = F / m，写出数值与方向说明。'
        ],
        sliders: [
          { id: 'force', label: '拉力 F (N)', min: 1, max: 10, step: 0.5, value: 6, unit: 'N' },
          { id: 'mass', label: '质量 m (kg)', min: 1, max: 5, step: 0.5, value: 2, unit: 'kg' }
        ],
        getDetails: (p) => `实时加速度 a = ${(p.force / p.mass).toFixed(2)} m/s²`,
        practice: {
          prompt: '调节 F 与 m，使加速度达到目标 a*',
          unit: 'm/s²',
          targets: [1.5, 2, 2.5, 3.2, 3.8],
          tolerance: 0.15,
          getCurrent: (p) => p.force / p.mass
        },
        textbook: '参考人民教育出版社《普通高中物理 必修第一册》第2章：教材先进行受力分析，再把合力沿坐标轴分解并代入 F=ma，强调单位统一和矢量方向说明。课堂拓展常结合推箱子、公交起步等实例，帮助学生理解“力越大，加速越快”的规律。',
        animationDesc: '超市真实场景：两辆购物车（空车与满载）并排，两人用相同大小的力向前推。空车迅速加速、满载车缓慢挪动，地面上用半透明箭头标出合力 F 与加速度 a，旁边实时显示 a = F/m 的数值。空车与满载车位移差随时间拉大，体现“相同力下质量越大加速度越小”。',
        realityPoint: '超市购物车、推力相等、位移对比、加速度公式可视化。',
        draw: drawNewton
      },
      {
        id: 'reaction',
        name: '作用力与反作用力',
        category: '力学',
        formula: '\\vec{F}_{AB} = -\\vec{F}_{BA}',
        formulaDetail: '两个物体相互作用时，成对力大小相等、方向相反，作用在不同物体上。火箭/气球通过喷出气体获得反冲，从而产生加速度。',
        summary: '松开气球口的瞬间，喷出的气体向后，气球向前。牛顿第三定律提醒我们：想要“前进”，就得对外界施加反向推力。',
        teachingPoints: [
          '分清“作用对象”，切勿把一对力画在同一受力图上。',
          '反作用力并不会抵消作用力，它们分别影响两个物体的运动。'
        ],
        sliders: [
          { id: 'pressure', label: '气体压力 (kPa)', min: 1, max: 5, step: 0.2, value: 3, unit: 'kPa' },
          { id: 'mass', label: '气球质量 (g)', min: 5, max: 30, step: 1, value: 12, unit: 'g' }
        ],
        getDetails: (p) => `气流推力≈${(p.pressure * 35).toFixed(1)} N，反作用力等值反向`,
        practice: {
          prompt: '调节气压与气球质量，让加速度≈6 m/s²',
          unit: 'm/s²',
          targets: [6],
          tolerance: 0.3,
          getCurrent: (p) => (p.pressure * 35) / p.mass
        },
        animationDesc: '松开气球口：气体向后喷出，气球向前飞出。用一对箭头标出作用力与反作用力 F_AB = -F_BA，推力越大、质量越小，加速度越大。',
        realityPoint: '气球反冲、火箭原理、作用力与反作用力。',
        draw: drawActionReaction
      },
      {
        id: 'sound',
        name: '声音的产生与传播',
        category: '声学',
        formula: 'v = f \\lambda \\quad \\Rightarrow \\quad \\lambda = \\frac{v}{f}',
        formulaDetail: '波速 v、频率 f、波长 λ 三者满足 v = fλ。物体振动频率 f 决定音高，振幅决定响度。空气中声速约 340 m/s，水中约 1500 m/s；温度升高声速略增。音叉振动推动空气形成纵波（疏密波），位移满足 y = A sin(2πft)。',
        summary: '敲击音叉后，音叉臂按固有频率振动，推动空气形成疏密相间的声波；若把音叉柄触碰水面，会看到圆形波纹——声音需要介质传播，真空中无法传声。',
        teachingPoints: [
          '频率 f 越高音调越尖锐，振幅 A 越大声音越响亮。',
          '声速与介质有关：固体 > 液体 > 气体；空气中 v ≈ 340 m/s。',
          '波长 λ = v/f，同一介质中频率越高波长越短。'
        ],
        sliders: [
          { id: 'frequency', label: '音叉频率 f (Hz)', min: 200, max: 800, step: 20, value: 440, unit: 'Hz' },
          { id: 'amplitude', label: '振幅倍数', min: 0.6, max: 1.6, step: 0.1, value: 1.0, unit: '×' }
        ],
        getDetails: (p) => `波长 λ ≈ ${(340 / p.frequency).toFixed(2)} m`,
        practice: {
          prompt: '让声波波长约等于 0.75 m',
          unit: 'm',
          targets: [0.75],
          tolerance: 0.02,
          getCurrent: (p) => 340 / p.frequency,
          format: (val) => `${val.toFixed(2)} m`
        },
        animationDesc: '一个真实的物理实验室桌面，一个音叉被小锤敲击后，发出清晰的“嗡”声。音叉两臂快速振动（用轻微动态模糊可视化）。音叉柄接触水面时，水面激起同心圆状波纹向外扩散。同时，空气中用半透明的蓝色声波显示：疏密相间的球面波从音叉向四周传播，到达观察者耳朵。背景有各种实验器材。微距特写，高速摄影捕捉振动细节，4K。',
        realityPoint: '真实音叉、小锤、水面波纹、实验室环境、振动可见模糊。',
        draw: drawSoundLab
      },
      {
        id: 'resonance',
        name: '共振实验',
        category: '声学',
        formula: 'f_{驱动} = f_{0} \\Rightarrow \\text{振幅最大（共振）}',
        formulaDetail: '当驱动频率 f_驱动 等于系统固有频率 f₀ 时，每周期外界做功与振动同相，能量持续输入，振幅急剧增大（共振）。阻尼越小共振峰越尖锐；过大振幅可能导致结构破坏（如塔科马海峡大桥风致振动）。',
        summary: '歌唱家唱到酒杯的固有频率时，杯缘剧烈振动，甚至会碎裂。共振在音乐（共鸣箱）、医学（MRI）中有应用，但工程上需避开危险频率。',
        teachingPoints: [
          '共振条件：f_驱动 ≈ f₀；频率差 Δf 越小，振幅越大。',
          '阻尼越小共振峰越尖锐；加阻尼可降低峰值、拓宽频带。',
          '桥梁、机床、建筑物都需做固有频率分析与避振设计。'
        ],
        sliders: [
          { id: 'voiceFreq', label: '歌声频率 (Hz)', min: 300, max: 1200, step: 10, value: 900, unit: 'Hz' },
          { id: 'glassFreq', label: '酒杯固有频率 (Hz)', min: 600, max: 1100, step: 10, value: 850, unit: 'Hz' }
        ],
        getDetails: (p) => `频率差 Δf = ${(Math.abs(p.voiceFreq - p.glassFreq)).toFixed(0)} Hz`,
        practice: {
          prompt: '调节歌声频率，使 Δf ≤ 10 Hz，触发“碎杯”共振',
          unit: 'Hz',
          targets: [0],
          tolerance: 10,
          type: 'difference',
          targetLabel: 'Δf → 0',
          getCurrent: (p) => p.voiceFreq - p.glassFreq,
          format: (val) => `${val.toFixed(1)} Hz`
        },
        animationDesc: '一个真实的音乐会舞台，一位歌唱家对着一个精致的高脚水晶酒杯唱出高音。慢动作特写：随着歌声频率接近酒杯固有频率，酒杯开始剧烈振动（边缘可见动态模糊），内部红酒产生驻波。当歌声达到共振频率时，酒杯“砰”一声炸裂成碎片，红酒飞溅，碎片在空中缓慢旋转。舞台灯光照射下碎片闪闪发光。观众惊讶表情背景虚化。高速摄影，1000fps，电影感。',
        realityPoint: '真实舞台、歌唱家、水晶酒杯、红酒、碎片飞溅、灯光反射。',
        draw: drawResonance
      },
      {
        id: 'buoyancy',
        name: '浮力（阿基米德）',
        category: '流体与压强',
        formula: 'F_{浮} = ρ_{液} \\times g \\times V_{排}',
        formulaDetail: '浸在流体中的物体所受浮力 F_浮 = ρ_液 g V_排，方向竖直向上。ρ_物 < ρ_液 时上浮直至漂浮（F_浮 = G）；ρ_物 > ρ_液 时下沉；ρ_物 = ρ_液 时可悬浮。浮力本质等于“被排开液体”的重力。',
        summary: '阿基米德原理说明浮力来自被排开液体的重量。比较 F_浮 与重力即可判断沉浮与露出液面高度，是船舶与潜艇设计的基础。',
        teachingPoints: [
          '比较浮力与重力即可判断运动趋势；悬浮时 F_浮 = G。',
          '漂浮时 ρ_物/ρ_液 = V_排/V_总，可求浸入体积比。',
          'V_排 要用立方米，密度用 kg/m³，g≈10 N/kg 计算。'
        ],
        formulaSteps: [
          '1) 把体积换算为 m³，密度换算为 kg/m³。',
          '2) 代入 F浮 = ρ液 g V排 求浮力，另算 G = ρ物 g V排。',
          '3) 比较 F浮 与 G，判断上浮/下沉或悬浮。'
        ],
        sliders: [
          { id: 'density', label: '物体密度 ρ (g/cm³)', min: 0.5, max: 2, step: 0.1, value: 0.9, unit: 'g/cm³' },
          { id: 'volume', label: '排开体积 V (L)', min: 0.5, max: 2.5, step: 0.1, value: 1.2, unit: 'L' }
        ],
        getDetails: (p) => {
          const volumeM3 = p.volume / 1000;
          const buoy = 1000 * g * volumeM3;
          const weight = p.density * 1000 * g * volumeM3;
          return `浮力≈${buoy.toFixed(1)}N，重力≈${weight.toFixed(1)}N → ${buoy >= weight ? '上浮' : '下沉'}`;
        },
        practice: {
          prompt: '让浮力与重力几乎相等，体验“悬浮”状态',
          unit: 'N',
          targets: [0],
          tolerance: 0.5,
          type: 'difference',
          targetLabel: '浮力 - 重力 → 0',
          getCurrent: (p) => {
            const volumeM3 = p.volume / 1000;
            const buoy = 1000 * g * volumeM3;
            const weight = p.density * 1000 * g * volumeM3;
            return buoy - weight;
          },
          format: (val) => `${val.toFixed(1)}N`
        },
        textbook: '参考人教版《义务教育物理 八年级下册》浮力章节：教材通过“木块漂浮、铁块下沉”实验推导 F浮=ρ液gV排，并配合“阿基米德原理”历史故事强调浮力来源于排开液体的重量。典型题目会让学生先求排水体积，再比较浮力与重力判断沉浮。',
        animationDesc: '真实水槽中的小船或木块：调节物体密度与排水体积，用竖直箭头标出浮力 F_浮 = ρ_液 g V_排 与重力 G；ρ_物 < ρ_液 时上浮、ρ_物 > ρ_液 时下沉，悬浮时二力相等。可观察吃水深度与稳定性。',
        realityPoint: '船舶、木块漂浮、排水体积、浮力与重力比较。',
        draw: drawBuoyancy
      },
      {
        id: 'bernoulli',
        name: '伯努利原理：吹纸实验',
        category: '流体力学',
        formula: 'P + \\frac{1}{2}ρ v^{2} = 常量',
        formulaDetail: '沿流线流动时，速度越大，压强越小。两张纸中间气流速度大，压强下降，外侧压强将它们推向一起。',
        summary: '人们直觉以为往中间吹气会把纸吹开，伯努利原理告诉我们恰恰相反：中间气流变快→压强降低→外侧压强把纸吸近。',
        teachingPoints: [
          '必须是平稳流动的流体才满足伯努利方程。',
          '风筝、飞机机翼等都利用了“流速大→压强小”。'
        ],
        sliders: [
          { id: 'flow', label: '吹气速度 (m/s)', min: 2, max: 12, step: 0.5, value: 6, unit: 'm/s' }
        ],
        getDetails: (p) => `中间压强下降≈${(0.5 * 1.2 * p.flow * p.flow).toFixed(0)} Pa`,
        practice: {
          prompt: '把吹气速度调到 8 m/s 以上，观察纸张迅速靠拢',
          unit: 'm/s',
          targets: [8],
          tolerance: 0.2,
          getCurrent: (p) => p.flow
        },
        animationDesc: '一个真实的教室场景，一个人手持两张平行的A4纸，向中间吹气。两张纸没有分开，反而相互吸引靠近。用半透明的蓝色气流线可视化：纸中间气流密集流速快（蓝色更深），两侧气流稀疏流速慢（浅蓝）。纸面微微颤动。背景有黑板、课桌椅。自然光，特写镜头，4K。',
        realityPoint: '真实教室、A4纸、吹气动作、纸面互动、气流可视化。',
        draw: drawBernoulli
      },
      {
        id: 'lever',
        name: '杠杆原理',
        category: '力学',
        formula: 'F_{1} \\times L_{1} = F_{2} \\times L_{2}',
        formulaDetail: '把力和力臂按“力矩=力×到支点的垂直距离”配对，左侧与右侧力矩相等即可平衡。',
        summary: '杠杆告诉我们“省力换距离”。改变力臂长度，家庭中的钳子、撬棍都能轻松放大力量，背后都是同一个力矩守恒思想。',
        teachingPoints: [
          '注意力臂必须是到支点的垂直距离，而不是沿杆子的长度。',
          '若存在多个力，记得分别计算并求和，才能判断转向。'
        ],
        sliders: [
          { id: 'leftForce', label: '左侧力 F₁ (N)', min: 1, max: 10, step: 0.5, value: 4, unit: 'N' },
          { id: 'leftArm', label: '左力臂 L₁ (m)', min: 1, max: 5, step: 0.5, value: 3, unit: 'm' }
        ],
        getDetails: (p) => `右侧平衡力 F₂ = ${(p.leftForce * p.leftArm / 3).toFixed(2)} N (L₂=3m)`,
        practice: {
          prompt: '让右侧需要的平衡力接近 5 N',
          unit: 'N',
          targets: [5],
          tolerance: 0.1,
          getCurrent: (p) => p.leftForce * p.leftArm / 3
        },
        textbook: '参考苏科版《九年级物理》杠杆单元：教材以跷跷板、扳手为案例，强调力臂必须垂直测量，并用“力矩=力×力臂”解释平衡条件 F₁L₁=F₂L₂。课后习题常引导学生判断省力、费力杠杆并计算未知力或力臂。',
        animationDesc: '真实跷跷板场景：左侧小孩坐得离支点远、右侧小孩离支点近。用半透明力臂线段与箭头标出 F₁、L₁ 与 F₂、L₂，杠杆随力矩差缓慢倾斜；当 F₁L₁ = F₂L₂ 时杠杆保持水平。可调节左侧力与力臂，观察平衡与失衡。',
        realityPoint: '跷跷板、力臂垂直距离、力矩平衡、省力与费力。',
        draw: drawLever
      },
      {
        id: 'pressure',
        name: '液体压强（帕斯卡定律）',
        category: '流体与压强',
        formula: 'P = P_0 + ρ g h',
        formulaDetail: '静止液体中某点压强 P = P_0 + ρgh，其中 P_0 为液面处压强（如大气压），h 为该点深度。同种液体同深度压强相等，与容器形状无关；压力在封闭液体中向各方向等效传递（帕斯卡定律）。',
        summary: '液体压强只与密度、深度和液面压强有关。帕斯卡定律说明压力在液体中向各方向等效传递，是液压机、注射器、潜水与大坝设计的物理基础。',
        teachingPoints: [
          'P = ρgh 中 h 为竖直深度，ρ 用 kg/m³，g≈10 N/kg。',
          '潜水越深 h 越大，压强越大；若液面有外加压强 P_0，整体加 P_0。',
          '帕斯卡定律：密闭液体中一处受压，各处压强等量增加。'
        ],
        formulaSteps: [
          '① 把密度写成 kg/m³、深度写成 m；',
          '② 套用 P = ρ g h，必要时加上额外外压；',
          '③ 可换算为 kPa 方便与大气压比较。'
        ],
        sliders: [
          { id: 'density', label: '液体密度 ρ (g/cm³)', min: 0.8, max: 1.3, step: 0.05, value: 1.0, unit: 'g/cm³' },
          { id: 'depth', label: '深度 h (m)', min: 0.5, max: 15, step: 0.5, value: 6, unit: 'm' }
        ],
        getDetails: (p) => {
          const pressure = p.density * 1000 * g * p.depth;
          return `底部压强≈${(pressure / 1000).toFixed(1)} kPa`;
        },
        practice: {
          prompt: '通过调节 ρ 与 h，让底部压强≈120 kPa',
          unit: 'Pa',
          targets: [120000],
          tolerance: 6000,
          targetLabel: '≈120 kPa',
          getCurrent: (p) => p.density * 1000 * g * p.depth,
          format: (val) => `${(val / 1000).toFixed(1)} kPa`
        },
        textbook: '参考湘教版《物理》九年级“压强与液压机”章节：书中用连通器和液压举重机演示 P=ρgh，强调“在同一水平面压强相等”，并通过帕斯卡定律推导小面积输入可放大输出力。实验步骤会记录液面高度、压强表读数并分析安全阀作用。',
        animationDesc: '真实潜水/水族箱场景：潜水员或传感器在不同深度处，用半透明压强计与色块表示 P = P₀ + ρgh，深度越大颜色越深（压强越大）。可调节液体密度与深度，观察压强数值变化。',
        realityPoint: '潜水深度、压强计、液体密度、帕斯卡定律。',
        draw: drawPressure
      },
      {
        id: 'submarine',
        name: '浮力：潜水艇上浮/下潜',
        category: '流体力学',
        formula: 'F_{浮} = ρ_{水} g V_{排}',
        formulaDetail: '通过调节压载舱的进水量改变排水体积，增大或减小浮力。浮力与重力的差决定潜艇是上浮、悬浮还是下潜。',
        summary: '潜艇向舱内注水，整体密度增大→下潜；向舱内压入空气，排出海水→密度降低→上浮。浮力控制完全依赖排水体积。',
        teachingPoints: [
          '悬浮条件：浮力=重力；这时密度与海水密度相等。',
          '潜艇调姿还会配合艏尾压载，保持平衡。'
        ],
        sliders: [
          { id: 'ballast', label: '压载舱注水百分比', min: 0, max: 1, step: 0.02, value: 0.55, unit: '×' }
        ],
        getDetails: (p) => p.ballast > 0.5 ? '当前密度>海水 → 下潜' : '当前密度<海水 → 上浮',
        practice: {
          prompt: '找到压载舱约 50% 的临界点，实现悬浮',
          unit: '%',
          targets: [0.5],
          tolerance: 0.02,
          getCurrent: (p) => p.ballast,
          format: (val) => `${(val * 100).toFixed(0)}%`
        },
        animationDesc: '一个真实的水族馆大型玻璃水箱，一艘玩具潜水艇模型。特写观察：潜水艇水舱注水时，模型变重下沉，周围水流形成涡旋；水舱排水时（用压缩空气），气泡从艇身排出，模型上浮。用半透明蓝色浮力箭头表示：下沉时重力大于浮力，上浮时浮力大于重力。背景有真实鱼类游过。水下摄影视角，自然光影透过水面，4K。',
        realityPoint: '真实水族馆、玩具潜艇、气泡、鱼类、水下光影、水流涡旋。',
        draw: drawSubmarine
      },
      {
        id: 'surface',
        name: '表面张力：水黾行走',
        category: '流体力学',
        formula: 'F_{max} = 2σL',
        formulaDetail: '水面像被拉紧的薄膜，张力 σ 与接触周长 L 决定水面能承受的最大支撑力。',
        summary: '水黾足尖压出小坑却不破水面，因为水面张力形成的“弹性膜”提供向上的支撑力，远远超过它的体重。',
        teachingPoints: [
          '水面张力会随温度、杂质变化，弱化后水黾就会下沉。',
          '沾上洗涤剂会破坏表面张力，使昆虫失去支撑。'
        ],
        sliders: [
          { id: 'mass', label: '水黾质量 (g)', min: 0.01, max: 0.08, step: 0.005, value: 0.03, unit: 'g' },
          { id: 'tension', label: '张力 σ (mN/m)', min: 30, max: 80, step: 2, value: 60, unit: 'mN/m' }
        ],
        getDetails: (p) => `可支持最大质量≈${(p.tension * 0.0002).toFixed(2)} g`,
        practice: {
          prompt: '调节质量与张力，让昆虫恰好“临界漂浮”',
          unit: 'g',
          targets: [0],
          tolerance: 0.005,
          type: 'difference',
          targetLabel: '支撑力 - 重力 ≈ 0',
          getCurrent: (p) => (p.tension * 0.0002) - p.mass,
          format: (val) => `${val.toFixed(3)} g`
        },
        animationDesc: '一个真实的夏日池塘微距镜头，一只水黾（水蜘蛛）在水面上轻盈滑行。它的足尖压出微小的凹坑但不会刺破水面，凹坑周围的水面反射着天空和荷叶倒影。用半透明的网状结构可视化水面张力：足尖处网格下凹但未断裂。一滴露珠从荷叶滚落，激起微小涟漪。阳光折射，波光粼粼。高速微距摄影，4K。',
        realityPoint: '真实池塘、水黾昆虫、荷叶露珠、水面倒影、自然光线。',
        draw: drawSurfaceTension
      },
      {
        id: 'reflection',
        name: '光的反射定律',
        category: '光学',
        formula: '∠i = ∠r',
        formulaDetail: '入射角 i 与反射角 r 均以法线为基准测量，在光滑平面镜上相等。入射光线、反射光线与法线共面；光路可逆。粗糙表面发生漫反射，每条微面仍满足该定律。',
        summary: '镜子迷宫里，激光每撞一次镜子都会严格遵守“入射角=反射角”，于是光束能被“折来折去”直到射中目标。抓住法线参照，就能规划多次反射的完整路径。',
        teachingPoints: [
          '构造法线，让角度测量更直观。',
          '光路可逆：反射光折返后会沿原路回到光源。'
        ],
        sliders: [
          { id: 'angle', label: '入射角 θi (°)', min: 0, max: 80, step: 1, value: 35, unit: '°' }
        ],
        getDetails: (p) => `入射角 = 反射角 = ${(p.angle != null ? p.angle : 35).toFixed(0)}°`,
        practice: {
          prompt: '把入射角调到 45° 体验等角反射',
          unit: '°',
          targets: [45],
          tolerance: 1,
          getCurrent: (p) => p.angle
        },
        textbook: '参考北师大版《物理》必修第一册几何光学部分：教材用光束盒实验验证“入射光、反射光、法线在同一平面内，且∠i=∠r”，并提醒学生使用量角器以法线为基准测角。延伸例题包括潜望镜与反光镜设计。',
        animationDesc: '真实光学实验台：激光从左侧射向平面镜，入射光与反射光用不同颜色标出，法线为虚线。可调节入射角，反射角实时随之相等。',
        realityPoint: '激光笔、平面镜、法线、入射角等于反射角。',
        extraPractice: [
          { prompt: '入射角为 30° 时，反射角为多少？', answer: '反射角等于入射角，为 30°。' },
          { prompt: '利用光路可逆解释：为什么你能在镜中看到别人，别人也能看到你？', answer: '你发出的光经镜面反射进入对方眼睛；光路可逆，对方发出的光经镜面反射也进入你的眼睛。' },
          { prompt: '潜望镜中光经过两次反射，画出光路并说明每面镜上入射角与反射角的关系。', answer: '两次反射均满足入射角等于反射角；两镜面平行时，出射光与入射光平行。' }
        ],
        draw: drawReflection
      },
      {
        id: 'refraction',
        name: '光的折射定律',
        category: '光学',
        formula: 'n_1 \\sin\\theta_1 = n_2 \\sin\\theta_2',
        formulaDetail: '斯涅尔定律：光从折射率 n₁ 的介质进入 n₂ 时，n₁sinθ₁ = n₂sinθ₂。光密→光疏时折射角大于入射角，可能全反射。折射率 n = c/v，与波长有关（色散）。',
        summary: '水杯中的筷子“折断”是光线在水-空气界面折射所致。掌握斯涅尔定律可预测折射角与全反射条件。',
        teachingPoints: [
          '画法线并标注折射角，避免把角度画错边。',
          '判断光线是否“向法线靠拢”取决于速度是否变慢。'
        ],
        sliders: [
          { id: 'angle', label: '入射角 θ₁ (°)', min: 0, max: 80, step: 1, value: 30, unit: '°' }
        ],
        getDetails: (p) => {
          const theta2 = Math.asin(clamp((n1 / n2) * Math.sin(toRad(p.angle)), -0.999, 0.999));
          return `折射角 θ₂ ≈ ${(theta2 * 180 / Math.PI).toFixed(1)}°`;
        },
        practice: {
          prompt: '寻找折射角 22° 左右所需的入射角',
          unit: '°',
          targets: [22],
          tolerance: 1,
          getCurrent: (p) => (Math.asin(clamp((n1 / n2) * Math.sin(toRad(p.angle)), -0.999, 0.999)) * 180 / Math.PI)
        },
        textbook: '参考人教版《普通高中物理 必修第二册》第3章：教材用玻璃砖和激光演示折射，推导 n₁sinθ₁=n₂sinθ₂，并讨论水-空气界面“向法线靠拢”或“背离法线”的判断。课本还介绍全反射与光纤通讯的联系，强调材料折射率数据表的使用。',
        animationDesc: '真实水杯与筷子：筷子斜插入装水玻璃杯，露出水面部分与水中部分“错位”，用入射光线与折射光线标出 n₁sinθ₁ = n₂sinθ₂，可调节入射角观察折射角变化。',
        realityPoint: '水杯、筷子、折射率、向法线偏折。',
        draw: drawRefraction
      },
      {
        id: 'ohm',
        name: '欧姆定律',
        category: '电学',
        formula: 'U = I \\times R',
        formulaDetail: '只要知道其中任意两个量即可推得第三个量。注意单位：1V/1Ω = 1A。',
        summary: '欧姆定律让电路分析从“猜测”变成“计算”。无论是灯泡、电脑还是生产线上的直流电机，只要知道电阻和电压，就能估算亮度、转速与发热量。',
        teachingPoints: [
          '串并联电路可先化简总电阻，再应用欧姆定律。',
          '实验中保持导线接触良好，电流表应串联。',
          '课件延伸：电脑、风扇、电灯等负载要核对额定电流后再接入电路。'
        ],
        formulaSteps: [
          'Ⅰ. 如果未知 R，先化简求出等效电阻。',
          'Ⅱ. 根据需要求 I 或 U：I = U/R 或 U = I·R。',
          'Ⅲ. 核对量纲：1V/1Ω = 1A。'
        ],
        sliders: [
          { id: 'voltage', label: '电压 U (V)', min: 1, max: 12, step: 1, value: 6, unit: 'V' },
          { id: 'resistance', label: '电阻 R (Ω)', min: 1, max: 100, step: 1, value: 20, unit: 'Ω' }
        ],
        getDetails: (p) => `电流 I = ${(p.voltage / p.resistance).toFixed(2)} A`,
        practice: {
          prompt: '调节 U 或 R，让电流达到 0.40 A',
          unit: 'A',
          targets: [0.4],
          tolerance: 0.03,
          getCurrent: (p) => p.voltage / p.resistance
        },
        textbook: '参考人民教育出版社《普通高中物理 必修第一册》第4章：欧姆定律实验通过电流表、电压表记录多组数据，绘制 U-I 图像并得到直线关系，进而写出 U=IR。教材强调连线方式、电表量程切换与误差分析，同时联系家电铭牌理解额定电流。',
        animationDesc: '真实电路实验板：电池、灯泡、电机、电阻与电流表串联，调节电压或电阻时电流表指针与灯泡亮度、电机转速同步变化，用 I = U/R 实时显示。',
        realityPoint: '电池、灯泡、电流表、欧姆定律 I=U/R。',
        draw: drawOhm
      },
      {
        id: 'series',
        name: '简单串联电路',
        category: '电学',
        formula: 'R_{总} = R_{1} + R_{2} + \\cdots',
        formulaDetail: '串联元件相同电流，等效电阻直接相加；路上任一点的电压降与电阻成正比。',
        summary: '串联电路像“流水线”——电流大小处处相等。掌握串联规律，可计算灯泡亮度、风扇转速以及工厂中的串联传感器是否安全运行。',
        teachingPoints: [
          '求电流时先计算总电阻，再代入 I = U / R总。',
          '若想知道某段电压，可按分压关系 U段 = I × R段。',
          '课堂提示：串联接入灯泡+电机时，电流相等，亮度和转速由总电阻决定。'
        ],
        sliders: [
          { id: 'r1', label: '电阻 R₁ (Ω)', min: 1, max: 60, step: 1, value: 15, unit: 'Ω' },
          { id: 'r2', label: '电阻 R₂ (Ω)', min: 1, max: 60, step: 1, value: 30, unit: 'Ω' },
          { id: 'voltage', label: '电压 U (V)', min: 1, max: 12, step: 1, value: 5, unit: 'V' }
        ],
        getDetails: (p) => {
          const total = p.r1 + p.r2;
          const current = p.voltage / total;
          return `总电阻=${total.toFixed(1)}Ω，电流=${current.toFixed(2)}A`;
        },
        practice: {
          prompt: '让总电阻等于 70 Ω，观察电流变化',
          unit: 'Ω',
          targets: [70],
          tolerance: 1,
          getCurrent: (p) => p.r1 + p.r2
        },
        textbook: '参考鲁科版《九年级物理》电路章节：教材将串联电路比作同一路径的水流，列出 R总=R₁+R₂，强调电流处处相等、电压按电阻比值分配。课本实验通过串联灯泡测亮度，并让学生计算各段电压以检验理论。',
        animationDesc: '真实串联电路：电池、灯泡、电阻箱、电机串联，电流表显示同一电流 I，调节总电阻时 I = U/(R₁+R₂) 变化，灯泡亮度与电机转速同步改变。',
        realityPoint: '串联灯泡、电阻箱、电流处处相等、总电阻相加。',
        draw: drawSeries
      },
      {
        id: 'capacitor',
        name: '电容充放电（闪光灯）',
        category: '电学',
        formula: 'Q = C \\times U',
        formulaDetail: '电容充电时电流随时间呈指数衰减，时间常数 τ = R · C；放电瞬间可释放强光或脉冲电流。',
        summary: '相机闪光灯会先让电容器缓慢充电，指示灯逐渐变亮；按下快门后电容瞬间释放储能，产生刺眼闪光。',
        teachingPoints: [
          '充电阶段 i(t) = (U/R)·e^{-t/RC}，越大的 R 或 C 充电越慢。',
          '放电阶段能量 W = 0.5 · C · U²，会瞬间转化为光和热。',
          '课本常用此模型解释“慢充快放”的电子闪光电路。'
        ],
        formulaSteps: [
          '① 将 C 换算为法拉 (F)，R 换算为欧姆 (Ω)。',
          '② 求时间常数 τ = R · C，约等于充电 63% 所需时间。',
          '③ 放电时电容电压按 e^{-t/RC} 迅速下降，可估算闪光持续时间。'
        ],
        sliders: [
          { id: 'capacitance', label: '电容 C (mF)', min: 100, max: 800, step: 50, value: 400, unit: 'mF' },
          { id: 'resistance', label: '充电电阻 R (kΩ)', min: 1, max: 20, step: 1, value: 6, unit: 'kΩ' }
        ],
        getDetails: (p) => {
          const tau = (p.resistance * 1000) * (p.capacitance / 1000);
          return `时间常数 τ ≈ ${tau.toFixed(2)} s`;
        },
        practice: {
          prompt: '调出 τ≈2 s 的闪光充电配置',
          unit: 's',
          targets: [2],
          tolerance: 0.2,
          getCurrent: (p) => (p.resistance * 1000) * (p.capacitance / 1000)
        },
        textbook: '相机闪光灯电路由高压电源、电容和氙气灯管组成。按下充电按钮后，电容经限流电阻缓慢充电；指示灯亮起表示电压到达触发阈值。按下快门时，触发器导通，让电容瞬间向氙气灯管放电，快速释放全部能量，形成耀眼闪光。',
        animationDesc: '真实相机/闪光灯电路：电容缓慢充电（τ=RC），电压表与指示灯显示充电进度；充满后触发闪光，瞬间放电，LED 闪亮。用半透明电荷流与 τ 公式标注。',
        realityPoint: '电容、充电曲线、时间常数 τ=RC、闪光放电。',
        draw: drawCapacitor
      },
      {
        id: 'fuse',
        name: '短路与保险丝熔断',
        category: '电学',
        formula: 'I = \\frac{U}{R}, \\quad P = I^{2} R',
        formulaDetail: '短路时 R 极小，电流远超保险丝额定值，产生的热量 I²R 让细金属丝熔化，从而切断电路。',
        summary: '在实验台上故意短接灯泡，可以看到保险丝瞬间炽热并断开，灯泡立刻熄灭，防止电池或导线被烧坏。',
        teachingPoints: [
          '家用保险丝或断路器按额定电流选择，防止线路过载。',
          '短路意味着负载电阻近似为零，I = U/R 会极大。',
          '课本强调实验时需佩戴护目镜，避免火花和烟雾伤害。'
        ],
        formulaSteps: [
          'Ⅰ. 根据 I = U/R 估算实际电流大小。',
          'Ⅱ. 对比保险丝额定电流 I额，若 I > I额 将在短时间内熔断。',
          'Ⅲ. 熔断后电路开路，灯泡或电机不再通电。'
        ],
        sliders: [
          { id: 'voltage', label: '电源电压 U (V)', min: 3, max: 18, step: 1, value: 9, unit: 'V' },
          { id: 'load', label: '负载等效电阻 R (Ω)', min: 1, max: 40, step: 1, value: 15, unit: 'Ω' },
          { id: 'fuseRating', label: '保险丝额定电流 (A)', min: 0.5, max: 5, step: 0.1, value: 2, unit: 'A' }
        ],
        getDetails: (p) => {
          const current = p.voltage / Math.max(p.load, 0.1);
          return current > p.fuseRating
            ? `I≈${current.toFixed(2)}A > I额 → 熔断`
            : `I≈${current.toFixed(2)}A (安全)`;
        },
        practice: {
          prompt: '让 I 接近额定值但不过载',
          unit: 'A',
          targets: [2],
          tolerance: 0.2,
          getCurrent: (p) => p.voltage / Math.max(p.load, 0.1)
        },
        textbook: '教材中常用“保险丝”说明家庭电路安全原理：当电路短路或负载过多时，电流迅速增大，细金属丝发热熔化并开路，保护其他电器。透明保险丝管方便观察熔断后的烟雾和金属蒸汽痕迹，同时提醒实验要佩戴护目镜。',
        animationDesc: '真实保险丝演示：电源、负载与保险丝串联，调节负载使 I 超过额定值时保险丝发热、闪烁后熔断，电路断开，用 I=U/R 与额定电流对比说明过载保护。',
        realityPoint: '保险丝、额定电流、过载熔断、电路保护。',
        draw: drawFuse
      },
      {
        id: 'coulomb',
        name: '库仑定律',
        category: '静电学',
        formula: 'F = k \\times \\frac{|q_{1} q_{2}|}{r^{2}}',
        formulaDetail: '把电荷换算成库仑 (μC → ×10⁻⁶C)，距离用米，代入常数 k=8.99×10⁹ N·m²/C²，可得静电力大小。正负号决定吸引或排斥。',
        summary: '库仑定律是静电学的“牛顿引力定律”。它告诉我们：两个带电体越近、带电量越大，作用力越显著。学校里的“验电器”就是利用这个原理观察排斥。',
        teachingPoints: [
          '电荷量的符号影响力的方向，大小取绝对值。',
          '常把微库仑换算成库仑再进行计算，避免数量级错误。'
        ],
        formulaSteps: [
          '① 将 μC 转换成 C（×10⁻⁶）。',
          '② 量出 r（米），代入 F = k|q₁q₂|/r²。',
          '③ 判断符号：同号排斥、异号相吸。'
        ],
        sliders: [
          { id: 'q1', label: '电荷 q₁ (μC)', min: -5, max: 5, step: 0.5, value: 3, unit: 'μC' },
          { id: 'q2', label: '电荷 q₂ (μC)', min: -5, max: 5, step: 0.5, value: -2, unit: 'μC' },
          { id: 'distance', label: '间距 r (m)', min: 0.3, max: 1.5, step: 0.1, value: 0.8, unit: 'm' }
        ],
        getDetails: (p) => {
          const force = kElectro * Math.abs(p.q1 * 1e-6 * p.q2 * 1e-6) / Math.pow(p.distance, 2);
          return `静电力≈${force.toFixed(3)} N (${p.q1 * p.q2 >= 0 ? '排斥' : '吸引'})`;
        },
        practice: {
          prompt: '配对 q₁, q₂, r，让静电力接近 0.20 N',
          unit: 'N',
          targets: [0.2],
          tolerance: 0.02,
          getCurrent: (p) => kElectro * Math.abs(p.q1 * 1e-6 * p.q2 * 1e-6) / Math.pow(p.distance, 2),
          format: (val) => `${val.toFixed(2)}N`
        },
        textbook: '参考《普通高中物理 选择性必修 第二册》静电场章节：教材介绍库仑扭秤实验，得出 F=k|q₁q₂|/r²，并讨论真空中的介电常数。例题要求把微库仑换算为库仑，同时分析力的方向与矢量表示，延伸到电场强度和等势面概念。',
        animationDesc: '两个带电小球在光滑面上，用箭头表示库仑力 F = k|q₁q₂|/r²；调节电荷或距离，观察斥力/引力大小与方向变化，同种电荷相斥、异种电荷相吸。',
        realityPoint: '点电荷、库仑力、距离平方反比、扭秤实验。',
        draw: drawCoulomb
      },
      {
        id: 'energy',
        name: '重力势能',
        category: '力学',
        formula: 'E_{p} = m \\times g \\times h',
        formulaDetail: '先确定参考零势能位置，再把质量、重力加速度和高度相乘即可得到储能大小。',
        summary: '势能体现“所处位置蕴含的能量”。储存的势能越多，释放时越能做功。例如水库、水塔以及跳水运动都离不开这一公式。',
        teachingPoints: [
          '高度一定要以同一个参考平面为基准。',
          '若题目给出势能变化，可直接代入 ΔEp = m g Δh。'
        ],
        sliders: [
          { id: 'mass', label: '质量 m (kg)', min: 1, max: 5, step: 0.5, value: 2.5, unit: 'kg' },
          { id: 'height', label: '高度 h (m)', min: 1, max: 10, step: 0.5, value: 6, unit: 'm' }
        ],
        getDetails: (p) => `Ep = ${(p.mass * g * p.height).toFixed(1)} J`,
        practice: {
          prompt: '调整 m、h 让重力势能约等于 150 J',
          unit: 'J',
          targets: [150],
          tolerance: 5,
          getCurrent: (p) => p.mass * g * p.height
        },
        textbook: '参考人教版《物理》必修第一册第3章：书中以举重运动员、蓄水池为例说明势能的参考平面选择，并给出 Ep=mgh 的推导。教材提醒在同一问题中要约定零势能面，练习题常结合能量守恒判断势能与动能的转化。',
        animationDesc: '真实起重机/水塔场景：重物被吊起至不同高度 h，用 Ep = mgh 实时显示势能；高度越高势能越大，释放后转化为动能。可调节质量与高度观察数值变化。',
        realityPoint: '起重机、高度 h、重力势能 Ep=mgh、零势能面。',
        draw: drawEnergy
      },
      {
        id: 'momentum',
        name: '动量守恒',
        category: '力学',
        formula: 'm_{1} v_{1} + m_{2} v_{2} = 常量',
        formulaDetail: '在无外力或外力可忽略时，碰撞前后的动量矢量和相同；把方向用正负号表示即可套用。',
        summary: '动量守恒让碰撞分析更简单：不用思考力的细节，只需关注“碰前=碰后”。这也是火箭喷气推进和冰上推人的原因。',
        teachingPoints: [
          '一维问题用正负号表示方向即可。',
          '若碰撞完全弹性，还可以额外列能量守恒求速度。'
        ],
        sliders: [
          { id: 'mass1', label: '小车 A 质量 (kg)', min: 1, max: 5, step: 0.5, value: 2, unit: 'kg' },
          { id: 'mass2', label: '小车 B 质量 (kg)', min: 1, max: 5, step: 0.5, value: 3, unit: 'kg' },
          { id: 'v1', label: 'A 初速度 (m/s)', min: 1, max: 15, step: 1, value: 8, unit: 'm/s' }
        ],
        getDetails: (p) => {
          const v1p = ((p.mass1 - p.mass2) / (p.mass1 + p.mass2)) * p.v1;
          const v2p = (2 * p.mass1 / (p.mass1 + p.mass2)) * p.v1;
          return `碰后 v₁′≈${v1p.toFixed(2)}m/s, v₂′≈${v2p.toFixed(2)}m/s`;
        },
        practice: {
          prompt: '把两车质量调成近似相等，体验速度“交换”',
          unit: 'kg',
          targets: [0],
          tolerance: 0.1,
          type: 'difference',
          targetLabel: 'm₁ - m₂ → 0',
          getCurrent: (p) => p.mass1 - p.mass2,
          format: (val) => `${val.toFixed(2)}kg`
        },
        textbook: '参考人教版《普通高中物理 必修第二册》第5章动量：教材通过气垫导轨实验验证 m₁v₁+m₂v₂ 恒定，并指出在完全弹性碰撞中速度会“对换”。课本练习鼓励学生使用矢量方向和正负号，理解爆炸、火箭喷气也遵循动量守恒。',
        animationDesc: '真实气垫导轨/光滑轨道：两小车相向或同向运动，碰撞前后用箭头标出速度与动量，碰撞瞬间动量守恒 m₁v₁+m₂v₂ = 常量；可调节质量与初速观察碰后速度。',
        realityPoint: '气垫导轨、碰撞、动量守恒、速度交换。',
        draw: drawMomentum
      },
      {
        id: 'circular',
        name: '匀速圆周运动',
        category: '力学',
        formula: 'a_{c} = \\frac{v^{2}}{r} = \\omega^{2} r \\quad (\\omega = v/r)',
        formulaDetail: '线速度 v 与角速度 ω 满足 v = ωr。速度方向时刻改变，需要向心加速度 a_c = v²/r = ω²r，由合力提供（如绳拉力、摩擦力）。周期 T = 2πr/v = 2π/ω。',
        summary: '雨伞旋转时水滴沿切线飞出（惯性）；维持圆周运动需要指向圆心的合力——向心力。a_c = v²/r 表明 v 越大、r 越小，所需向心力越大。',
        teachingPoints: [
          '向心力是合力的效果，不是与重力、拉力并列的“第三种力”。',
          '角速度 ω = v/r，周期 T = 2π/ω；切线方向速度不变，法向有加速度。',
          '离心力是非惯性系中的惯性力，在惯性系中只分析向心力即可。'
        ],
        sliders: [
          { id: 'speed', label: '线速度 v (m/s)', min: 1, max: 20, step: 1, value: 8, unit: 'm/s' },
          { id: 'radius', label: '半径 r (m)', min: 1, max: 10, step: 0.5, value: 4, unit: 'm' }
        ],
        getDetails: (p) => `a_c = ${(p.speed * p.speed / p.radius).toFixed(2)} m/s²`,
        practice: {
          prompt: '让向心加速度接近 10 m/s²',
          unit: 'm/s²',
          targets: [10],
          tolerance: 0.5,
          getCurrent: (p) => p.speed * p.speed / p.radius
        },
        textbook: '参考沪科版《物理》必修第二册匀速圆周运动章节：教材强调“速度方向时刻改变，需要向心力”，推导 a=v²/r，并配合甩石实验、杯中硬币实验说明向心力来源。例题常将重力、绳拉力或静摩擦提供的向心力联系起来。 ',
        animationDesc: '雨伞旋转甩水滴：伞缘水滴做圆周运动，脱离时沿切线飞出；用 a_c = v²/r 与切线方向箭头标出向心力与速度，可调节线速度与半径观察向心加速度变化。',
        realityPoint: '雨伞、切线飞出、向心力、ω=v/r。',
        draw: drawCircular
      },
      {
        id: 'projectile',
        name: '斜抛运动',
        category: '力学',
        formula: [
          'x = v_x t \\quad (\\text{水平匀速})',
          'y = v_y t - \\frac{1}{2}gt^2 \\quad (\\text{竖直匀变速})',
          'R = \\frac{v^2 \\sin(2\\theta)}{g} \\quad (\\text{射程})'
        ],
        formulaDetail: '初速分解 v_x = v cos θ，v_y = v sin θ。水平匀速、竖直匀变速；飞行时间 T = 2v_y/g，最大高度 H = v_y²/(2g)，射程 R = v²sin(2θ)/g。θ=45° 时射程最大。',
        summary: '斜抛可分解为水平匀速与竖直上抛的叠加。掌握飞行时间、最高点与射程公式，即可分析炮弹、投篮、喷泉等轨迹。',
        teachingPoints: [
          '水平方向：x = v_x t；竖直方向：y = v_y t − ½gt²，落地时 y = 0 得 T = 2v_y/g。',
          '最高点 v_y = 0，可得 H = v_y²/(2g)；射程 R = v_x·T = v²sin(2θ)/g。',
          '同一高度发射与落地时，45° 射程最远；若起落点不等高需重新列式。'
        ],
        sliders: [
          { id: 'speed', label: '初速度 v (m/s)', min: 5, max: 25, step: 1, value: 15, unit: 'm/s' },
          { id: 'angle', label: '发射角 θ (°)', min: 10, max: 80, step: 1, value: 40, unit: '°' }
        ],
        getDetails: (p) => {
          const angle = toRad(p.angle);
          const range = (p.speed * p.speed * Math.sin(2 * angle)) / g;
          const H = (p.speed * p.speed * Math.sin(angle) * Math.sin(angle)) / (2 * g);
          return `射程 R≈${range.toFixed(1)} m，最大高度 H≈${H.toFixed(1)} m`;
        },
        practice: {
          prompt: '尝试让射程达到 20 m',
          unit: 'm',
          targets: [20],
          tolerance: 1.5,
          getCurrent: (p) => (p.speed * p.speed * Math.sin(2 * toRad(p.angle))) / g
        },
        textbook: '参考人教版《物理》必修第二册第3章抛体运动：教材先分解初速度，再列出水平匀速、竖直自由落体两个方程，推导出射程 R=v²sin2θ/g 与最高点高度。课后题结合投球、炮弹、消防水枪，提醒学生注意角度换算与时间求解。',
        animationDesc: '真实炮台或投球场景：炮弹/球从原点以初速 v、仰角 θ 抛出，轨迹为抛物线 x = v_x t、y = v_y t − ½gt²；圆柱靶标固定在场地最右端，可调节 v 与 θ 观察射程、最高点与是否命中。实时显示飞行时间、最大高度与射程 R。',
        realityPoint: '炮弹/投篮、抛物线轨迹、射程公式、45° 最远。',
        draw: drawProjectile
      },
      {
        id: 'harmonic',
        name: '简谐振动（弹簧）',
        category: '波动与声',
        formula: 'x(t) = A \\sin(\\omega t + \\varphi) \\quad \\omega = 2\\pi f = \\sqrt{k/m}',
        formulaDetail: '回复力 F = -kx 推出运动方程满足 x = A sin(ωt+φ)，其中角频率 ω = √(k/m)，周期 T = 2π/ω = 2π√(m/k)。振幅 A 由初始条件决定；速度 v = Aω cos(ωt+φ)，最大动能与势能相等，机械能守恒。',
        summary: '简谐振动是力学与波动的基础模型：弹簧振子、单摆（小角）、交流电都可用正弦描述。能量在动能与势能间周期转换，总机械能守恒。',
        teachingPoints: [
          '位移 x、速度 v、加速度 a 相位依次差 90°；v 最大时 x=0，a 最大时在端点。',
          'ω = 2πf，T = 1/f = 2π√(m/k)；质量越大或 k 越小，周期越长。',
          '能量 E = ½kA² = ½mv_max²，在振动过程中守恒。'
        ],
        sliders: [
          { id: 'amplitude', label: '振幅 A (px)', min: 20, max: 80, step: 5, value: 40, unit: 'px' },
          { id: 'frequency', label: '频率 f (Hz)', min: 0.5, max: 2, step: 0.1, value: 1.2, unit: 'Hz' }
        ],
        getDetails: (p) => `ω = ${(2 * Math.PI * p.frequency).toFixed(2)} rad/s`,
        practice: {
          prompt: '把振幅设为 60 px，体验能量变化',
          unit: 'px',
          targets: [60],
          tolerance: 1,
          getCurrent: (p) => p.amplitude
        },
        textbook: '参考浙教版《物理》选修“波动”模块：教材用弹簧振子推导 x=A sin(ωt+φ)，并指出 ω=√(k/m)。实验部分要求测量周期、画出位移-时间图像，同时讨论能量在动能与势能之间往返转换，是研究机械波的基础模型。',
        animationDesc: '弹簧振子或单摆：物体在平衡位置两侧做 x = A sin(ωt) 的往复运动，用位移-时间曲线与箭头标出速度与加速度相位关系；可调节振幅与频率观察周期变化。',
        realityPoint: '弹簧振子、单摆、简谐运动、ω=2πf。',
        draw: drawHarmonic
      },
      {
        id: 'wave',
        name: '波的叠加',
        category: '波动与声',
        formula: 'y = y_{1} + y_{2}',
        formulaDetail: '同一介质中，多列波的位移可直接相加；若频率或相位不同，会形成干涉条纹或拍频。',
        summary: '波的叠加让我们理解噪声抵消耳机、激光干涉仪的工作方式。学会分析相对相位后，复杂的波形也能分解成简单正弦。',
        teachingPoints: [
          '同相位叠加最强，反相位会抵消。',
          '拍频 f拍 = |f₁ - f₂|，可用来调音。'
        ],
        sliders: [
          { id: 'frequency', label: '频率 f (Hz)', min: 1, max: 5, step: 0.2, value: 2.4, unit: 'Hz' },
          { id: 'amplitude', label: '振幅 A (px)', min: 10, max: 60, step: 5, value: 35, unit: 'px' }
        ],
        getDetails: (p) => `最大叠加振幅≈${(p.amplitude * 1.8).toFixed(1)} px`,
        practice: {
          prompt: '让两列波频率=3 Hz，观察稳定花纹',
          unit: 'Hz',
          targets: [3],
          tolerance: 0.1,
          getCurrent: (p) => p.frequency
        },
        textbook: '参考人教版《普通高中物理 选择性必修 第一册》波动章节：教材用波动示踪仪展示“同一介质中位移可叠加”，推导干涉与拍频公式，并通过水波、声波实验让学生观察相位差。课后题要求画出合成波形并分析加强或相消条件。',
        animationDesc: '两列波在同一绳上传播：y = y₁ + y₂ 叠加，同相位加强、反相位相消；用波形动画与拍频 f拍 = |f₁−f₂| 标注，可调节频率与振幅观察合成波形。',
        realityPoint: '波的叠加、干涉、拍频、噪声抵消耳机。',
        draw: drawWave
      },
      {
        id: 'doppler',
        name: '多普勒效应',
        category: '波动与声',
        formula: 'f\' = f \\times \\frac{v}{v \\mp v_s} \\quad (声源动)',
        formulaDetail: '声源相对介质运动时：靠近听者用 f′ = f·v/(v−v_s)，频率升高；远离用 f′ = f·v/(v+v_s)，频率降低。v 为声速，v_s 为声源速率。观察者运动时公式形式不同，但都是“相对靠近则频率变高”。光的多普勒导致红移/蓝移，用于测速与宇宙学。',
        summary: '声源靠近时波长被“压缩”，听者接收频率变高；远离时频率变低。救护车驶过时的音调变化、雷达测速、天体红移都基于多普勒效应。',
        teachingPoints: [
          '声源靠近：分母 v−v_s，f′ > f；声源远离：分母 v+v_s，f′ < f。',
          '观察者运动时公式为 f′ = f·(v±v_o)/v，需与声源运动区分。',
          '光波同样有多普勒效应，红移表示远离、蓝移表示靠近。'
        ],
        sliders: [
          { id: 'sourceSpeed', label: '声源速度 vₛ (m/s)', min: 0, max: 60, step: 5, value: 20, unit: 'm/s' },
          { id: 'frequency', label: '原频率 f (Hz)', min: 220, max: 660, step: 20, value: 440, unit: 'Hz' }
        ],
        getDetails: (p) => {
          const c = 340;
          const front = p.frequency * (c / (c - p.sourceSpeed));
          const back = p.frequency * (c / (c + p.sourceSpeed));
          return `前方≈${front.toFixed(0)}Hz，后方≈${back.toFixed(0)}Hz`;
        },
        practice: {
          prompt: '将声源速度调到 30 m/s，感受频率增幅',
          unit: 'm/s',
          targets: [30],
          tolerance: 2,
          getCurrent: (p) => p.sourceSpeed
        },
        textbook: '参考北师大版《物理》必修第三册波动章节：教材通过警笛实验和气柱共鸣装置说明多普勒效应，写出 f′=f·v/(v±vₛ)，并讨论声源靠近或远离时的频率变化。高阶内容还扩展到光的红移、雷达测速等应用场景。',
        animationDesc: '一个真实的城市街道场景，一辆鸣笛的救护车从远处驶来，经过镜头，然后驶向远处。用彩色声波可视化：声源前方声波密集（波长变短，频率高，蓝色表示），后方声波稀疏（波长变长，频率低，红色表示）。同时，观众能“看到”声音音调的变化：接近时尖锐，远离时低沉。街道上有行人、车辆、建筑。实景拍摄风格，自然光影，4K。',
        realityPoint: '真实救护车、城市街景、行人车辆、多普勒效应直观可视化。',
        draw: drawDoppler
      },
      {
        id: 'thermal',
        name: '热胀冷缩',
        category: '热学',
        formula: '\\Delta L = \\alpha \\times L_{0} \\times \\Delta T',
        formulaDetail: '线膨胀系数 α 描述单位长度的伸长率，记得把 ΔT 换成摄氏度或开尔文。',
        summary: '桥梁接缝、铁轨缝隙都与热胀冷缩有关。只要温度升高，固体就会延伸；热胀的量随材质和温差线性增长。',
        teachingPoints: [
          '计算时要将毫米与米统一到同一单位。',
          '若材料复合，可分别计算再求和。'
        ],
        sliders: [
          { id: 'deltaT', label: '温差 ΔT (°C)', min: 0, max: 80, step: 5, value: 30, unit: '°C' },
          { id: 'alpha', label: '线膨胀系数 α (×10⁻⁶/°C)', min: 5, max: 25, step: 1, value: 12, unit: '×10⁻⁶' }
        ],
        getDetails: (p) => `ΔL(1m)≈${(p.alpha * 1e-6 * p.deltaT * 1000).toFixed(2)} mm`,
        practice: {
          prompt: '调节 α 与 ΔT 令 ΔL ≈ 1.2 mm',
          unit: 'mm',
          targets: [1.2],
          tolerance: 0.1,
          getCurrent: (p) => p.alpha * 1e-6 * p.deltaT * 1000
        },
        textbook: '参考粤教版《物理》九年级热学部分：教材通过加热铁环、铁棒实验说明热胀冷缩规律 ΔL=αL₀ΔT，列出不同材料的线膨胀系数表格，并提醒桥梁、铁路需预留伸缩缝。练习题常要求根据温差估算缝隙大小或判断卡死风险。',
        animationDesc: '铁轨或桥梁接缝：加热前后长度变化 ΔL = α L₀ ΔT 用刻度尺与温差计可视化，不同材料线膨胀系数不同，接缝预留不足会导致挤压变形。',
        realityPoint: '铁轨接缝、线膨胀系数、温差、伸缩缝。',
        draw: drawThermal
      },
      {
        id: 'energyFlow',
        name: '热对流能量流',
        category: '热学',
        formula: 'Q \\propto \\Delta T',
        formulaDetail: '温差越大，热对流越剧烈；实际计算需考虑面积、流速等因素，这里用波形高度代表热流强度。',
        summary: '在湖面或暖气片旁，你能感到空气缓慢流动。热对流将热能从高温区搬到低温区，是天气与海洋环流的重要驱动力。',
        teachingPoints: [
          '加热底部、上冷下热更容易形成对流。',
          '温差变小或密闭空间对流会被抑制。'
        ],
        sliders: [
          { id: 'tempDiff', label: '温差 ΔT (°C)', min: 5, max: 30, step: 1, value: 12, unit: '°C' }
        ],
        getDetails: (p) => `振幅代表热流强度，ΔT=${p.tempDiff.toFixed(0)}°C`,
        practice: {
          prompt: '把温差设为 20°C，观察热流加剧',
          unit: '°C',
          targets: [20],
          tolerance: 1,
          getCurrent: (p) => p.tempDiff
        },
        textbook: '参考沪科版《物理》八年级“热传递”内容：教材把热对流描述为“密度差导致流体整体流动”，示范暖气片、海陆风的形成过程，并强调温差越大，对流越强。课后探究要求绘制热流线并比较传导、辐射三种方式。',
        animationDesc: '暖气片或热水杯：热空气上升、冷空气下沉形成对流环，用半透明热流线表示 Q ∝ ΔT，温差越大热流越强；可与传导、辐射对比。',
        realityPoint: '暖气片、热对流、温差、海陆风。',
        draw: drawEnergyFlow
      },
      {
        id: 'magnetic',
        name: '洛伦兹力（带电粒子）',
        category: '电磁与现代物理',
        formula: 'F = q \\times v \\times B \\times \\sin θ',
        formulaDetail: '当速度与磁场垂直时，洛伦兹力大小最大，方向可用左手定则判断，提供向心力让粒子弯曲。',
        summary: '磁场会让带电粒子转弯，这是回旋加速器、显像管偏转的基础。只要记住速度越快、磁场越强，轨迹越紧。',
        teachingPoints: [
          '若速度与磁场平行，洛伦兹力为零。',
          '圆轨道半径 r = m v / (|q| B)，质量越大越难弯。'
        ],
        sliders: [
          { id: 'velocity', label: '速度 v (m/s)', min: 1, max: 20, step: 1, value: 8, unit: 'm/s' },
          { id: 'magneticField', label: '磁感应强度 B (T)', min: 0.1, max: 1, step: 0.1, value: 0.5, unit: 'T' }
        ],
        getDetails: (p) => `F = ${(p.velocity * p.magneticField).toFixed(2)} N (取 q=1C, θ=90°)`,
        practice: {
          prompt: '让洛伦兹力达到 6 N，观察轨迹收紧',
          unit: 'N',
          targets: [6],
          tolerance: 0.3,
          getCurrent: (p) => p.velocity * p.magneticField
        },
        textbook: '参考人教版《普通高中物理 选择性必修 第三册》电磁学单元：教材用带电粒子进入匀强磁场的实验推导 F=qvBsinθ，并说明向心力提供者就是洛伦兹力。书中配有质谱仪、回旋加速器等案例，指导学生根据 q、v、B 计算轨道半径。',
        animationDesc: '带电粒子射入匀强磁场：洛伦兹力 F=qvB 提供向心力，粒子做圆周运动；调节 v 或 B 观察轨道半径变化，用左手定则标出力方向。',
        realityPoint: '洛伦兹力、匀强磁场、质谱仪、回旋加速器。',
        draw: drawMagnetic
      },
      {
        id: 'induction',
        name: '电磁感应（法拉第）',
        category: '电磁与现代物理',
        formula: '|\\varepsilon| = N \\times \\frac{\\Delta Φ}{\\Delta t}',
        formulaDetail: '线圈内磁通量变化越快，感应电动势越大。ΔΦ 可近似看成 B·A，若磁体移动更快或匝数更多，感应电压随之增加。',
        summary: '发电机、磁悬浮列车都依赖电磁感应：动能→电能的关键就是“磁通变化”。本示意用磁铁穿过线圈来展示电压脉冲的大小。',
        teachingPoints: [
          '只有磁通量变化时才产生感应电动势。',
          '楞次定律说明感应电流方向总是阻碍原变化。'
        ],
        formulaSteps: [
          '1. 先求磁通量 Φ = B·A·cosθ 或其变化量 ΔΦ；',
          '2. 感应电动势大小 |ε| = N · ΔΦ / Δt；',
          '3. 用楞次定律判定方向（本示意用色块提示方向）。'
        ],
        sliders: [
          { id: 'speed', label: '磁体移动速度 (m/s)', min: 0.2, max: 2, step: 0.1, value: 0.8, unit: 'm/s' },
          { id: 'turns', label: '线圈匝数 N', min: 20, max: 150, step: 5, value: 60, unit: '匝' }
        ],
        getDetails: (p) => `感应电动势≈${(p.turns * p.speed * 0.04).toFixed(2)} V (示意)`,
        practice: {
          prompt: '调节速度与匝数，让感应电压≈4 V',
          unit: 'V',
          targets: [4],
          tolerance: 0.3,
          getCurrent: (p) => p.turns * p.speed * 0.04,
          format: (val) => `${val.toFixed(2)}V`
        },
        textbook: '参考人教版《普通高中物理 必修第三册》第6章电磁感应：教材通过移动磁铁与线圈实验发现磁通量变化产生感应电动势，写出 ε=N·ΔΦ/Δt，并引入楞次定律判断电流方向。课本还展示手摇发电机、磁悬浮列车等应用。',
        animationDesc: '磁铁快速插入/抽出线圈：电流表指针偏转，用 ε = N·ΔΦ/Δt 与楞次定律标出感应电流方向；磁铁运动越快、匝数越多，感应电动势越大。',
        realityPoint: '磁铁、线圈、电流表、楞次定律、发电机。',
        draw: drawInduction
      },
      {
        id: 'photoelectric',
        name: '光电效应',
        category: '近代物理',
        formula: 'E_k = hf - W_0',
        formulaDetail: '光具有粒子性，光子能量 E = hf。当光子能量大于金属逸出功 W₀ 时，可打出光电子，最大动能 E_k = hf − W₀。',
        summary: '紫外光照射金属铯极板，光子撞击金属表面打出光电子，形成光电流。说明光具有粒子性，是量子力学的重要实验基础。',
        teachingPoints: ['光子能量 E = hf，与频率成正比。', '存在截止频率：f < W₀/h 时无光电子。', '光强只影响光电子数目，不影响最大动能。'],
        sliders: [
          { id: 'frequency', label: '入射光频率 f (×10¹⁴ Hz)', min: 5, max: 12, step: 0.5, value: 8, unit: '' },
          { id: 'intensity', label: '光强倍数', min: 1, max: 5, step: 0.5, value: 2.5, unit: '×' },
          { id: 'workFunction', label: '逸出功 W₀ (eV)', min: 2, max: 5, step: 0.3, value: 3.5, unit: 'eV' }
        ],
        getDetails: (p) => {
          const hasPhoto = (p.frequency || 8) > (p.workFunction || 3.5) * 0.4;
          return hasPhoto ? `hf > W₀ → 有光电流，光强×${(p.intensity || 1).toFixed(1)}` : 'hf < W₀ → 无光电子';
        },
        practice: {
          prompt: '调节频率使超过截止频率（有光电流）',
          unit: '',
          targets: [0.5],
          tolerance: 0.4,
          getCurrent: (p) => (p.frequency || 8) - (p.workFunction || 3.5) * 0.4
        },
        extraPractice: [
          { prompt: '若逸出功 W₀ = 2.5 eV，截止频率约为多少 Hz？（h≈4.14×10⁻¹⁵ eV·s）', answer: 'f₀ = W₀/h ≈ 6×10¹⁴ Hz。' },
          { prompt: '光强加倍时，光电流和最大初动能如何变化？', answer: '光电流约加倍；最大初动能不变（由频率决定）。' }
        ],
        animationDesc: '一个真实的真空光电管实验装置，紫外光照射到金属铯极板上。用金色光子粒子流可视化：一个个光子撞击金属表面，瞬间打出蓝色电子粒子（光电子），电子飞向阳极，电路中产生电流（电流表指针摆动）。金属表面微观结构清晰（原子晶格排列）。背景有真空泵、电源。实验室环境，特写，4K。',
        realityPoint: '真实光电管、真空装置、紫外灯、电流表、实验室器材。',
        draw: drawPhotoelectric
      },
      {
        id: 'atomicLevel',
        name: '原子能级跃迁',
        category: '近代物理',
        formula: '\\Delta E = E_n - E_m = hf',
        formulaDetail: '电子从高能级 E_n 跃迁到低能级 E_m 时，释放光子，能量差 ΔE = hf 决定光子频率。',
        summary: '霓虹灯发光原理：电子在氖原子能级间跃迁，每次落到低能级就释放一个特定频率的光子，大量光子汇聚成可见光。',
        teachingPoints: ['能级差决定发射光子的频率。', '不同元素有不同特征光谱。', '吸收与发射过程互为逆过程。'],
        sliders: [
          { id: 'voltage', label: '激发电压 U (V)', min: 80, max: 200, step: 10, value: 120, unit: 'V' },
          { id: 'current', label: '灯管电流 (mA)', min: 5, max: 30, step: 1, value: 15, unit: 'mA' }
        ],
        getDetails: (p) => `U=${(p.voltage || 120).toFixed(0)}V → 电子获得能量跃迁发光`,
        practice: {
          prompt: '让激发电压达到 150 V',
          unit: 'V',
          targets: [150],
          tolerance: 8,
          getCurrent: (p) => p.voltage || 120
        },
        extraPractice: [
          { prompt: '霓虹灯发光的物理过程是什么？', answer: '电子在电场中加速获得能量，与氖原子碰撞使其跃迁，跃迁回低能级时发射光子。' }
        ],
        animationDesc: '一个真实的夜晚城市街道，霓虹灯招牌“CAFE”发出鲜艳的红光。微距特写霓虹灯管内部：微观动画可视化电子在氖原子能级间跳跃，每次从高能级掉落到低能级，就释放一个红色光子。无数光子汇聚成明亮光束射出玻璃管。玻璃管表面有轻微灰尘和划痕，真实老化质感。背景是模糊的城市夜景。超写实，微距，4K。',
        realityPoint: '真实霓虹灯招牌、玻璃管质感、城市夜景、灰尘细节。',
        draw: drawAtomicLevel
      },
      {
        id: 'fission',
        name: '核裂变链式反应',
        category: '近代物理',
        formula: '^{235}U + n \\to 碎片 + 2\\sim3n + 能量',
        formulaDetail: '铀-235 吸收慢中子后分裂成两个较轻的核（碎片），同时释放 2～3 个中子和大量能量。新中子可继续引发其他铀核裂变，形成链式反应。',
        summary: '核电站利用可控链式反应：控制棒吸收多余中子，使反应维持在临界状态，将核能转化为热能再发电。',
        teachingPoints: ['链式反应条件：一个裂变产生的中子能引发下一次裂变。', '慢中子更易被 U-235 俘获。', '控制棒（镉、硼）吸收中子以调节反应强度。'],
        sliders: [
          { id: 'controlRod', label: '控制棒插入程度 (%)', min: 0, max: 100, step: 5, value: 40, unit: '%' },
          { id: 'reactivity', label: '反应强度 (示意)', min: 0.5, max: 2, step: 0.1, value: 1, unit: '×' }
        ],
        getDetails: (p) => `控制棒${(p.controlRod || 40).toFixed(0)}% → ${p.controlRod > 60 ? '反应减弱' : '链式反应持续'}`,
        practice: {
          prompt: '将控制棒插入 70% 使反应减弱',
          unit: '%',
          targets: [70],
          tolerance: 5,
          getCurrent: (p) => p.controlRod || 40
        },
        extraPractice: [
          { prompt: '控制棒在核反应堆中的作用是什么？', answer: '吸收中子，降低反应性，使链式反应可控或停堆。' }
        ],
        animationDesc: '一个真实的核电站控制室背景（虚化），前景是一个反应堆模型。微距进入燃料棒内部：一个铀-235原子核被慢中子（蓝色粒子）撞击后，分裂成两个较小的原子核（碎片），同时释放2-3个新的中子（黄色粒子）和大量能量（闪光）。新中子继续撞击其他铀核，形成链式反应。反应堆冷却剂气泡流动。真实金属质感，热成像颜色显示温度升高。教育纪录片风格，4K。',
        realityPoint: '真实控制室背景、反应堆模型、金属质感、热成像、气泡流动。',
        draw: drawFission
      },
      {
        id: 'gravityOrbit',
        name: '万有引力与轨道',
        category: '天文与宇宙',
        formula: 'F = G \\frac{Mm}{r^2} \\quad 向心力 \\Rightarrow 椭圆轨道',
        formulaDetail: '万有引力提供向心力，使行星沿椭圆轨道绕太阳运行。开普勒三定律描述轨道形状与周期。',
        summary: '地球绕太阳公转的向心力来自万有引力。从太空视角可见精确的椭圆轨道、引力线与地球表面的云层、大陆轮廓。',
        teachingPoints: ['引力与距离平方成反比。', '椭圆轨道：近日点快、远日点慢。', '开普勒第三定律：T² ∝ a³。'],
        sliders: [
          { id: 'eccentricity', label: '轨道偏心率 e', min: 0.1, max: 0.85, step: 0.05, value: 0.6, unit: '' },
          { id: 'orbitSpeed', label: '公转速度 (相对)', min: 0.05, max: 0.3, step: 0.02, value: 0.15, unit: '×' }
        ],
        getDetails: (p) => `偏心率 e=${(p.eccentricity || 0.6).toFixed(2)}，T²∝a³`,
        practice: {
          prompt: '将轨道偏心率调到 0.5',
          unit: '',
          targets: [0.5],
          tolerance: 0.06,
          getCurrent: (p) => p.eccentricity || 0.6
        },
        extraPractice: [
          { prompt: '开普勒第三定律 T²∝a³ 中 a 是什么？', answer: 'a 是椭圆轨道的半长轴。' }
        ],
        animationDesc: '从太空真实视角看太阳系，太阳发出强烈的光和热，地球在精确的椭圆轨道上运行。用半透明的引力线可视化：太阳和地球之间有多条动态引力线（类似拉伸的橡皮筋），表示引力相互作用。地球表面大陆轮廓、云层、极光清晰可见。太阳耀斑活动。背景是深邃星空，星星有真实闪烁。NASA级画质，4K，慢速运动。',
        realityPoint: '真实天体纹理（NASA素材风格）、太阳耀斑、星空、引力可视化。',
        draw: drawGravityOrbit
      },
      {
        id: 'blackHole',
        name: '黑洞引力透镜',
        category: '天文与宇宙',
        formula: '光线在强引力场中弯曲 \\Rightarrow 爱因斯坦环',
        formulaDetail: '广义相对论：强引力场使时空弯曲，光线沿测地线传播因而发生偏折。黑洞附近可形成多重像与爱因斯坦环。',
        summary: '背景星系的星光经过黑洞附近时被强烈弯曲，形成扭曲的像和爱因斯坦环，是验证广义相对论的重要现象。',
        teachingPoints: ['引力透镜强度与质量分布有关。', '吸积盘与相对论性喷流是黑洞的观测特征。', '事件视界内光无法逃逸。'],
        sliders: [
          { id: 'mass', label: '黑洞质量 (相对)', min: 0.5, max: 1.5, step: 0.1, value: 1, unit: '×' },
          { id: 'diskBright', label: '吸积盘亮度', min: 0.5, max: 1.5, step: 0.1, value: 1, unit: '×' }
        ],
        getDetails: (p) => `质量系数 ${(p.mass || 1).toFixed(1)} → 引力透镜强度`,
        practice: {
          prompt: '将黑洞质量系数调到 1.2',
          unit: '×',
          targets: [1.2],
          tolerance: 0.1,
          getCurrent: (p) => p.mass || 1
        },
        extraPractice: [
          { prompt: '什么是爱因斯坦环？', answer: '背景光源发出的光被黑洞等大质量天体弯曲，形成环状或弧状像。' }
        ],
        animationDesc: '真实深空场景，一个恒星质量黑洞（黑色球体，周围有吸积盘）位于前景。远处背景星系的星光经过黑洞附近时，光线被明显弯曲，形成多个扭曲的像和爱因斯坦环。吸积盘物质高速旋转，发出炽热光芒，相对论性喷流从两极射出。星光闪烁，宇宙尘埃云飘过。电影级太空画面，4K，超写实。',
        realityPoint: '真实宇宙场景风格、吸积盘细节、星光、爱因斯坦环现象。',
        draw: drawBlackHole
      },
      {
        id: 'hydroPower',
        name: '能量转换：水力发电',
        category: '综合应用',
        formula: 'E_{势} \\to E_{动} \\to E_{机械} \\to E_{电}',
        formulaDetail: '水库中的重力势能随水流下落转化为动能，冲击水轮机转化为机械能，发电机将机械能转化为电能。',
        summary: '水坝蓄水抬升势能，泄流时势能→动能→水轮机转动→发电机输出电能。能量流可视化帮助理解各环节转换。',
        teachingPoints: ['势能 mgh、动能 ½mv²、功率 P = Fv。', '效率 = 输出电功率 / 输入水功率。', '抽水蓄能电站可反向储能。'],
        sliders: [
          { id: 'flow', label: '水流量 (相对)', min: 0.5, max: 3, step: 0.2, value: 1.5, unit: '×' },
          { id: 'head', label: '水头高度 (相对)', min: 0.6, max: 1.4, step: 0.1, value: 1, unit: '×' }
        ],
        getDetails: (p) => `流量×${(p.flow || 1).toFixed(1)} → 势能→动能→电能`,
        practice: {
          prompt: '将水流量调到 2.0 倍',
          unit: '×',
          targets: [2],
          tolerance: 0.15,
          getCurrent: (p) => p.flow || 1.5
        },
        extraPractice: [
          { prompt: '水力发电中势能如何转化为电能？', answer: '水从高处落下，势能→动能；冲击水轮机→机械能；发电机→电能。' }
        ],
        animationDesc: '一个真实的大型水坝场景，水流从高处倾泻而下冲击水轮机。能量流可视化：用不同颜色光流表示能量形式——上游水库（蓝色，重力势能）、水流下落（绿色，动能增加）、水轮机旋转（黄色，机械能）、发电机输出电线（红色，电能）。水花飞溅，彩虹出现。无人机航拍视角加内部微距切换，真实大坝环境，4K。',
        realityPoint: '真实水坝、水流、水花、彩虹、无人机视角。',
        draw: drawHydroPower
      },
      {
        id: 'eddyCurrent',
        name: '电磁阻尼',
        category: '综合应用',
        formula: '磁通变化 \\Rightarrow 涡电流 \\Rightarrow 阻碍相对运动',
        formulaDetail: '磁铁在铜管中下落时，管壁内产生感应涡电流，涡电流的磁场阻碍磁铁运动，使磁铁缓慢下落。',
        summary: '磁铁在铜管中比自由落体慢得多。涡电流在非磁性金属中产生，消耗动能转化为热能，应用于磁阻尼、电磁制动。',
        teachingPoints: ['楞次定律：感应效果阻碍原因。', '涡电流在块状导体中形成闭合回路。', '铝管、铜管均可演示，非铁磁性。'],
        sliders: [
          { id: 'magnetStrength', label: '磁铁强度 (相对)', min: 0.5, max: 1.5, step: 0.1, value: 1, unit: '×' },
          { id: 'tubeConduct', label: '管壁电导 (相对)', min: 0.5, max: 1.5, step: 0.1, value: 1, unit: '×' }
        ],
        getDetails: (p) => `磁铁×${(p.magnetStrength || 1).toFixed(1)} → 涡流阻尼越大下落越慢`,
        practice: {
          prompt: '将磁铁强度调到 1.2 倍',
          unit: '×',
          targets: [1.2],
          tolerance: 0.1,
          getCurrent: (p) => p.magnetStrength || 1
        },
        extraPractice: [
          { prompt: '为什么磁铁在铜管中下落变慢？', answer: '磁铁运动使管壁产生涡电流，涡电流磁场阻碍磁铁运动（楞次定律）。' }
        ],
        animationDesc: '一个真实的物理实验，一根长铜管竖直固定，一块强磁铁从管口释放。慢动作显示：磁铁缓慢下落，比自由落体慢得多。用半透明的蓝色涡电流线可视化：磁铁周围产生环形感应电流，这些电流产生磁场抵抗磁铁运动。铜管表面金属光泽，有轻微氧化痕迹。背景有实验员手持磁铁准备。特写，4K，慢动作。',
        realityPoint: '真实铜管、强磁铁、金属质感、实验员手部。',
        draw: drawEddyCurrent
      },
      {
        id: 'mechanicalEnergy',
        name: '机械能守恒',
        category: '力学',
        formula: 'E = E_k + E_p = \\text{常量} \\quad E_p = mgh \\quad E_k = \\frac{1}{2}mv^2',
        formulaDetail: '只有重力（或弹力）做功时，系统机械能守恒。单摆摆动过程中动能与势能相互转化，总和不变。',
        summary: '单摆从高处释放：最高点势能最大、动能为零；最低点动能最大、势能为零。E = Ek + Ep 始终不变，是分析过山车、摆球等问题的核心。',
        teachingPoints: [
          '零势能面要统一选取（通常选最低点或地面）。',
          '若存在摩擦力或空气阻力，机械能会逐渐减少。',
          '列式：E初 = E末 或 ΔEk = −ΔEp。'
        ],
        sliders: [
          { id: 'mass', label: '摆球质量 m (kg)', min: 0.5, max: 3, step: 0.1, value: 1, unit: 'kg' },
          { id: 'length', label: '摆长 (相对)', min: 60, max: 160, step: 10, value: 80, unit: '' },
          { id: 'angle', label: '初始摆角 (°)', min: 15, max: 50, step: 5, value: 30, unit: '°' }
        ],
        getDetails: (p) => {
          const L = 0.5 + (p.length || 80) / 80;
          const angle0 = (p.angle || 30) * Math.PI / 180;
          const hMax = L * (1 - Math.cos(angle0));
          const epMax = (p.mass || 1) * g * hMax;
          return `E = E_k + E_p 常量，最大势能≈${epMax.toFixed(1)} J`;
        },
        practice: {
          prompt: '让最大势能接近 2.0 J',
          unit: 'J',
          targets: [2],
          tolerance: 0.3,
          getCurrent: (p) => {
            const L = 0.5 + (p.length || 80) / 80;
            const angle0 = (p.angle || 30) * Math.PI / 180;
            const hMax = L * (1 - Math.cos(angle0));
            return (p.mass || 1) * g * hMax;
          }
        },
        extraPractice: [
          { prompt: '单摆从最高点摆到最低点，动能如何变化？', answer: '势能转化为动能，最低点动能最大。' }
        ],
        textbook: '参考人教版《物理》必修第二册机械能守恒：教材用自由落体、单摆推导只有重力做功时 E_k + E_p 不变，强调“选零势能面”和“无摩擦”条件。',
        animationDesc: '单摆摆动：实时显示 E_p = mgh、E_k = ½mv² 与总机械能 E；最高点势能大、最低点动能大，总和不变。可调节质量、摆长、初角观察。',
        realityPoint: '单摆、过山车、荡秋千、动能势能转化。',
        draw: drawMechanicalEnergy
      },
      {
        id: 'pulley',
        name: '滑轮组（省力）',
        category: '力学',
        formula: 'F = \\frac{G}{n} \\quad (n \\text{ 为承担重物的绳股数})',
        formulaDetail: '动滑轮与定滑轮组合：承担重物的绳子股数 n 越多，所需拉力 F 越小，但绳端移动距离是重物移动距离的 n 倍，不省功。',
        summary: '建筑工地用滑轮组吊重物：几股绳拉，拉力就变为重力的几分之一，但拉绳的长度要成倍增加。',
        teachingPoints: [
          '数清“承担重物”的绳股数 n，F = G/n（不计滑轮重和摩擦）。',
          '省力不省功：F·s拉 = G·h物。',
          '定滑轮改方向，动滑轮省力。'
        ],
        sliders: [
          { id: 'weight', label: '重物 G (N)', min: 50, max: 200, step: 10, value: 100, unit: 'N' },
          { id: 'ropes', label: '绳股数 n', min: 1, max: 4, step: 1, value: 2, unit: '股' }
        ],
        getDetails: (p) => `F = G/n = ${((p.weight || 100) / Math.max(1, Math.round(p.ropes || 2))).toFixed(0)} N`,
        practice: {
          prompt: '让拉力 F 达到 40 N（调节 G 或 n）',
          unit: 'N',
          targets: [40],
          tolerance: 4,
          getCurrent: (p) => (p.weight || 100) / Math.max(1, Math.round(p.ropes || 2))
        },
        textbook: '参考苏科版《九年级物理》简单机械：教材用实验得出 F = G/n，强调 n 的数法及“省力不省功”。',
        animationDesc: '滑轮组吊重物：标出 G、n 股绳与拉力 F = G/n；调节 G 与 n 观察拉力变化。',
        realityPoint: '吊车、升降机、绳股数、省力。',
        extraPractice: [
          { prompt: '重物 G = 120 N，用 3 股绳承担，不计滑轮重与摩擦，求所需拉力 F。', answer: 'F = G/n = 120/3 = 40 N。' },
          { prompt: '为什么说滑轮组“省力不省功”？', answer: '拉力 F = G/n 变小，但绳端移动距离 s = n·h（h 为重物上升高度），所以 F·s = G·h，功不变。' },
          { prompt: '怎样数“承担重物的绳股数”n？', answer: '数从动滑轮（或重物）出发、直接拉重物或动滑轮的绳子段数，与定滑轮相连的不算。' }
        ],
        draw: drawPulley
      },
      {
        id: 'lens',
        name: '凸透镜成像',
        category: '光学',
        formula: '\\frac{1}{u} + \\frac{1}{v} = \\frac{1}{f}',
        formulaDetail: '物距 u、像距 v、焦距 f 满足透镜成像公式。u > 2f 成倒立缩小实像；f < u < 2f 成倒立放大实像；u < f 成正立放大虚像。',
        summary: '照相机、投影仪、放大镜都用到凸透镜。物距改变，像距和像的大小随之改变，公式 1/u + 1/v = 1/f 统一描述。',
        teachingPoints: [
          '实像：光屏可接；虚像：正立、同侧、放大。',
          '物距 u 从无穷远减小：像从焦点附近移远，先缩小后放大。',
          '一倍焦距分虚实，二倍焦距分大小。'
        ],
        sliders: [
          { id: 'objectDist', label: '物距 u (cm)', min: 90, max: 250, step: 10, value: 150, unit: 'cm' },
          { id: 'focal', label: '焦距 f (cm)', min: 60, max: 100, step: 5, value: 80, unit: 'cm' }
        ],
        getDetails: (p) => {
          const u = p.objectDist || 150;
          const f = p.focal || 80;
          const v = u > f ? (u * f) / (u - f) : 0;
          return v > 0 ? `1/u+1/v=1/f → v=${v.toFixed(0)} cm` : 'u≤f 成虚像';
        },
        practice: {
          prompt: '让像距 v 达到 120 cm',
          unit: 'cm',
          targets: [120],
          tolerance: 10,
          getCurrent: (p) => {
            const u = p.objectDist || 150;
            const f = p.focal || 80;
            return u > f ? (u * f) / (u - f) : 0;
          }
        },
        extraPractice: [
          { prompt: '物距 u > 2f 时，像的特点是什么？', answer: '成倒立、缩小的实像，像距 f < v < 2f。' }
        ],
        textbook: '参考人教版《物理》八年级凸透镜成像：教材用蜡烛、凸透镜、光屏探究 u、v、f 关系，归纳 1/u+1/v=1/f 与成像规律。',
        animationDesc: '凸透镜光路：物、透镜、像与三条典型光线；实时标出 u、v、f 与公式。调节物距观察像距与像的虚实、大小。',
        realityPoint: '照相机、投影仪、放大镜、物距像距。',
        draw: drawLens
      },
      {
        id: 'joule',
        name: '焦耳定律',
        category: '电学',
        formula: 'Q = I^2 R t',
        formulaDetail: '电流通过导体产生的热量 Q 与电流 I 的平方、电阻 R 和通电时间 t 成正比。电流越大、电阻越大，发热越明显。',
        summary: '电热器、电烙铁、保险丝熔断都遵循焦耳定律。实验中用电阻丝通电，可见发热变红，Q = I²Rt 定量描述。',
        teachingPoints: [
          'Q 单位焦耳(J)，常换算为卡或用于电热功率 P = I²R。',
          '串联时电流相同，电阻大的发热多；并联时电压相同，电阻小的发热多。',
          '安全用电：防止导线过载发热引发火灾。'
        ],
        sliders: [
          { id: 'current', label: '电流 I (A)', min: 0.5, max: 5, step: 0.25, value: 2, unit: 'A' },
          { id: 'resistance', label: '电阻 R (Ω)', min: 2, max: 12, step: 1, value: 5, unit: 'Ω' },
          { id: 'timeJoule', label: '通电时间 t (s)', min: 1, max: 10, step: 0.5, value: 2, unit: 's' }
        ],
        getDetails: (p) => `Q = I²Rt = ${((p.current || 2) ** 2 * (p.resistance || 5) * (p.timeJoule || 2)).toFixed(0)} J`,
        practice: {
          prompt: '让发热量 Q 达到 100 J',
          unit: 'J',
          targets: [100],
          tolerance: 8,
          getCurrent: (p) => (p.current || 2) ** 2 * (p.resistance || 5) * (p.timeJoule || 2)
        },
        extraPractice: [
          { prompt: '为什么保险丝会在电流过大时熔断？', answer: 'Q = I²Rt，电流过大时发热量剧增，保险丝熔点低故熔断切断电路。' }
        ],
        textbook: '参考人教版《物理》九年级焦耳定律：教材通过实验得出 Q ∝ I²、Q ∝ R、Q ∝ t，写出 Q = I²Rt，并联系电热器、保险丝。',
        animationDesc: '电阻丝通电发热：电流 I、电阻 R 越大，线圈越红；实时显示 Q = I²Rt 与热量。',
        realityPoint: '电热器、保险丝、导线发热、I²R。',
        draw: drawJoule
      },
      {
        id: 'parallel',
        name: '简单并联电路',
        category: '电学',
        formula: '\\frac{1}{R_{总}} = \\frac{1}{R_1} + \\frac{1}{R_2} \\quad I_{总} = I_1 + I_2',
        formulaDetail: '并联各支路电压相等，总电流等于各支路电流之和；等效电阻满足 1/R总 = 1/R₁ + 1/R₂，R总 小于任一支路电阻。',
        summary: '家庭电路用电器多为并联：各用电器电压相同、互不影响，总电流为各支路电流之和。',
        teachingPoints: [
          '先求 1/R总 = 1/R₁ + 1/R₂，再求 R总。',
          '各支路电流 I₁ = U/R₁，I₂ = U/R₂，I总 = I₁ + I₂。',
          '并联电阻越并越小；总电流越大，用电器（如台灯）越亮。'
        ],
        sliders: [
          { id: 'r1', label: '电阻 R₁ (Ω)', min: 10, max: 50, step: 5, value: 20, unit: 'Ω', ticks: [10, 20, 30, 40, 50] },
          { id: 'r2', label: '电阻 R₂ (Ω)', min: 10, max: 50, step: 5, value: 30, unit: 'Ω', ticks: [10, 20, 30, 40, 50] },
          { id: 'voltage', label: '电压 U (V)', min: 3, max: 12, step: 1, value: 6, unit: 'V', ticks: [3, 6, 9, 12] }
        ],
        getDetails: (p) => {
          const r1 = p.r1 || 20;
          const r2 = p.r2 || 30;
          const u = p.voltage || 6;
          const rt = 1 / (1 / r1 + 1 / r2);
          const iTotal = u / rt;
          return `R总≈${rt.toFixed(1)} Ω  I总=${iTotal.toFixed(2)} A`;
        },
        practice: {
          prompt: '让总电流达到 2 A',
          unit: 'A',
          targets: [2],
          tolerance: 0.08,
          getCurrent: (p) => {
            const r1 = p.r1 || 20;
            const r2 = p.r2 || 30;
            const u = p.voltage || 6;
            const rt = 1 / (1 / r1 + 1 / r2);
            return u / rt;
          },
          format: (v) => `${v.toFixed(2)} A`
        },
        textbook: '参考鲁科版《九年级物理》并联电路：教材用电流表测各支路与干路电流，得出 I总 = I₁ + I₂，并推导 1/R总 = 1/R₁ + 1/R₂。',
        animationDesc: '两电阻并联：电池、干路与两支路，电流流动光点、电阻热力图、家庭场景；调节 R₁、R₂、U 观察 R总与电流分配。',
        realityPoint: '家庭电路、并联用电器、总电流分流。',
        draw: drawParallel
      },
      {
        id: 'specificHeat',
        name: '比热容与吸热',
        category: '热学',
        formula: 'Q = c \\times m \\times \\Delta T',
        formulaDetail: '比热容 c 表示单位质量物质升高 1°C 吸收的热量。水比热容大（约 4.2×10³ J/(kg·°C)），所以升温慢、吸热多，适合做冷却剂。',
        summary: '同样加热，海水比沙滩升温慢，因为水的比热容大。Q = cmΔT 是热量计算的核心公式。',
        teachingPoints: [
          'c 与物质种类有关，水、酒精等需查表。',
          'ΔT 为温度变化（升温取正），单位要统一为 °C 或 K。',
          'Q 单位焦耳，与功、能一致。'
        ],
        sliders: [
          { id: 'specificHeat', label: '比热容 c (kJ/(kg·°C))', min: 2, max: 5, step: 0.2, value: 4.2, unit: '' },
          { id: 'mass', label: '质量 m (kg)', min: 0.5, max: 3, step: 0.1, value: 1, unit: 'kg' },
          { id: 'deltaT', label: '温升 ΔT (°C)', min: 5, max: 40, step: 5, value: 20, unit: '°C' }
        ],
        getDetails: (p) => `Q = cmΔT = ${((p.specificHeat || 4.2) * (p.mass || 1) * (p.deltaT || 20)).toFixed(0)} kJ`,
        practice: {
          prompt: '让吸热量 Q 达到 80 kJ',
          unit: 'kJ',
          targets: [80],
          tolerance: 6,
          getCurrent: (p) => (p.specificHeat || 4.2) * (p.mass || 1) * (p.deltaT || 20)
        },
        extraPractice: [
          { prompt: '为什么沿海地区昼夜温差比内陆小？', answer: '水的比热容大，白天吸热、夜晚放热多，温度变化慢。' }
        ],
        textbook: '参考人教版《物理》九年级比热容：教材用“同质量水与沙子加热对比”引入比热容，写出 Q = cmΔT，并解释沿海昼夜温差小。',
        animationDesc: '烧杯加热：调节 c、m、ΔT，显示 Q = cmΔT；比热容大则“同温升吸热多”。',
        realityPoint: '海水与沙滩、冷却剂、暖气用水、Q=cmΔT。',
        draw: drawSpecificHeat
      },
      {
        id: 'solidPressure',
        name: '固体压强',
        category: '流体与压强',
        formula: 'P = \\frac{F}{S}',
        formulaDetail: '压强 P 等于垂直作用在物体表面的压力 F 与受力面积 S 的比值。同一压力下，面积越小压强越大。',
        summary: '刀刃锋利、履带坦克、滑雪板都是为了改变受力面积从而改变压强：切菜要利、走泥地要宽。',
        teachingPoints: [
          'F 为垂直压力（N），S 为受力面积（m²），P 单位 Pa。',
          '增大压强：增大 F 或减小 S；减小压强：减小 F 或增大 S。',
          '与液体压强 P = ρgh 区分：固体压强由外力与接触面决定。'
        ],
        sliders: [
          { id: 'weight', label: '体重/压力 F (N)', min: 300, max: 800, step: 50, value: 600, unit: 'N' },
          { id: 'area', label: '单脚面积 S (m²)', min: 0.01, max: 0.05, step: 0.005, value: 0.02, unit: 'm²' },
          { id: 'standMode', label: '站立 0=双脚 1=单脚', min: 0, max: 1, step: 1, value: 0, unit: '' }
        ],
        getDetails: (p) => {
          const S = p.standMode === 1 ? (p.area || 0.02) : (p.area || 0.02) * 2;
          return `P = F/S = ${((p.weight || p.force || 600) / S).toFixed(0)} Pa`;
        },
        practice: {
          prompt: '让压强 P 达到 25000 Pa',
          unit: 'Pa',
          targets: [25000],
          tolerance: 1500,
          getCurrent: (p) => {
            const S = p.standMode === 1 ? (p.area || 0.02) : (p.area || 0.02) * 2;
            return (p.weight || p.force || 600) / S;
          }
        },
        textbook: '参考人教版《物理》八年级压强：教材用“压力一定时，接触面积越小，效果越明显”引入 P = F/S，并举例刀、履带、滑雪板。',
        animationDesc: '脚踩沙地：同一体重，脚尖着地陷得深（S 小 P 大）、整脚着地陷得浅；标出 F、S、P = F/S。',
        realityPoint: '刀刃、履带、滑雪板、压强与面积。',
        extraPractice: [
          { prompt: '体重 600 N 的人，单脚站立时接触面积 0.02 m²，求对地面的压强。', answer: 'P = F/S = 600/0.02 = 30000 Pa。' },
          { prompt: '为什么坦克要装履带而不是轮子？', answer: '履带增大了与地面的接触面积 S，在压力 F 一定时压强 P = F/S 变小，不易陷进泥地。' },
          { prompt: '刀刃为什么要磨得很薄？', answer: '减小受力面积 S，在压力 F 一定时压强 P 增大，更容易切开物体。' }
        ],
        draw: drawSolidPressure
      },
      {
        id: 'ampere',
        name: '安培定则（通电螺线管）',
        category: '电磁与现代物理',
        formula: '右手握螺线管 \\quad 四指 \\to I \\quad 拇指 \\to N \\text{ 极}',
        formulaDetail: '通电螺线管相当于条形磁铁：电流方向与 N、S 极关系由安培定则判断；管内磁感线近似均匀，管外形成闭合曲线。',
        summary: '电磁铁、继电器、喇叭都用到通电螺线管。右手定则一握，就能判断 N 极和磁感线方向。',
        teachingPoints: [
          '安培定则：右手握螺线管，四指指向电流方向，拇指指向 N 极。',
          '电流越大、匝数越多，磁场越强。',
          '磁感线闭合：管内从 S 到 N，管外从 N 到 S。'
        ],
        sliders: [
          { id: 'turns', label: '匝数 (相对)', min: 4, max: 16, step: 2, value: 8, unit: '' },
          { id: 'current', label: '电流 I (A)', min: 0.5, max: 3, step: 0.25, value: 1, unit: 'A' }
        ],
        getDetails: (p) => `匝数×电流 → 磁场强弱，拇指指向 N 极`,
        practice: {
          prompt: '让电流达到 2 A',
          unit: 'A',
          targets: [2],
          tolerance: 0.2,
          getCurrent: (p) => p.current || 1
        },
        extraPractice: [
          { prompt: '安培定则中，四指和拇指分别表示什么？', answer: '四指指向电流方向，拇指指向 N 极。' }
        ],
        textbook: '参考人教版《物理》九年级电与磁：教材用铁屑显示螺线管磁场，引入安培定则判断 N 极与磁感线方向。',
        animationDesc: '通电螺线管与磁感线：电流方向用 ⊗⊙ 标出，管内外磁感线闭合；调节匝数与电流观察磁场强弱。',
        realityPoint: '电磁铁、继电器、喇叭、右手定则。',
        draw: drawAmpere
      },
      {
        id: 'friction',
        name: '摩擦力',
        category: '力学',
        formula: 'F_f = \\mu N \\quad (N = mg)',
        formulaDetail: '滑动摩擦力 F_f = μN，N 为正压力（水平面时 N=mg）。最大静摩擦力 F_f,max = μ_s·N；当外力 F_app > F_f,max 时物体开始滑动，之后 F_f = μ_k·N。',
        summary: '参考 PhET 摩擦力仿真：调节拉力、质量、摩擦系数，观察木块何时开始滑动及滑动时的加速度。摩擦力方向始终与相对运动（或趋势）方向相反。',
        teachingPoints: [
          '静摩擦：F_app ≤ μ_s N 时物体静止，F_f 与 F_app 等大反向。',
          '动摩擦：F_f = μ_k N，一般 μ_k ≤ μ_s。',
          '合力 F_net = F_app − F_f，加速度 a = F_net / m。'
        ],
        sliders: [
          { id: 'appliedForce', label: '拉力 F (N)', min: 0, max: 20, step: 1, value: 6, unit: 'N' },
          { id: 'mass', label: '质量 m (kg)', min: 1, max: 5, step: 0.5, value: 2, unit: 'kg' },
          { id: 'mu', label: '摩擦系数 μ', min: 0.1, max: 0.9, step: 0.05, value: 0.4, unit: '' }
        ],
        getDetails: (p) => {
          const N = (p.mass || 2) * g;
          const FfMax = (p.mu || 0.4) * N;
          const moving = (p.appliedForce || 6) > FfMax;
          return moving ? `滑动 a=${(((p.appliedForce || 6) - FfMax) / (p.mass || 2)).toFixed(2)} m/s²` : '静止 F_f = F拉';
        },
        practice: {
          prompt: '让木块刚好开始滑动（拉力略大于最大静摩擦）',
          unit: 'N',
          targets: [8],
          tolerance: 0.8,
          getCurrent: (p) => (p.mu || 0.4) * (p.mass || 2) * g
        },
        extraPractice: [
          { prompt: '静摩擦力与滑动摩擦力有何区别？', answer: '静摩擦随外力变化直到最大值；滑动摩擦 F_f = μ_k N，一般略小于最大静摩擦。' }
        ],
        textbook: '参考人教版《物理》八年级摩擦力：教材用弹簧测力计拉木块得出 F_f = μN，区分静摩擦与滑动摩擦，并说明增大压力或粗糙程度可增大摩擦。',
        animationDesc: '参考 PhET 摩擦力：木块置于水平面，调节拉力、质量、μ；箭头标出拉力与摩擦力，F拉>μN 时木块滑动，显示 a=(F−F_f)/m。',
        realityPoint: '推箱子、刹车、鞋底花纹、摩擦系数。',
        draw: drawFriction
      },
      {
        id: 'buildAtom',
        name: '原子模型（建构原子）',
        category: '近代物理',
        formula: '\\text{质量数 } A = p + n \\quad \\text{电荷 } = (p - e)e',
        formulaDetail: '原子核由质子 p 与中子 n 组成，核外电子数 e 决定元素化学性质。质子数决定元素种类；p=e 为中性原子，p>e 为阳离子，p<e 为阴离子。',
        summary: '参考 PhET 建构原子：添加质子、中子、电子，观察元素符号、质量数、电荷。质子数决定元素（H、He、C…），电子数决定是否带电。',
        teachingPoints: [
          '质子数 = 原子序数 = 元素种类。',
          '质量数 A = 质子数 + 中子数；同位素：同 p 不同 n。',
          '电荷 = (p − e)e，离子带电量与得失电子数有关。'
        ],
        sliders: [
          { id: 'protons', label: '质子数 p', min: 1, max: 10, step: 1, value: 6, unit: '' },
          { id: 'neutrons', label: '中子数 n', min: 0, max: 14, step: 1, value: 6, unit: '' },
          { id: 'electrons', label: '电子数 e', min: 0, max: 12, step: 1, value: 6, unit: '' }
        ],
        getDetails: (p) => {
          const sym = ['', 'H', 'He', 'Li', 'Be', 'B', 'C', 'N', 'O', 'F', 'Ne'][clamp(Math.round(p.protons || 6), 1, 10)] || '?';
          const charge = (p.protons || 6) - (p.electrons || 6);
          return `${sym}  A=${(p.protons || 6) + (p.neutrons || 6)}  ${charge > 0 ? '+' + charge : charge}价`;
        },
        practice: {
          prompt: '构造一个碳原子（6 质子、6 中子、6 电子）',
          unit: '',
          targets: [0],
          tolerance: 0,
          getCurrent: (p) => Math.abs((p.protons || 6) - 6) + Math.abs((p.neutrons || 6) - 6) + Math.abs((p.electrons || 6) - 6)
        },
        extraPractice: [
          { prompt: '同位素的定义是什么？', answer: '质子数相同、中子数不同的同一元素的不同核素。' }
        ],
        textbook: '参考人教版《化学》九年级物质构成：原子由原子核（质子+中子）与核外电子构成；质子数决定元素，电子数决定带电情况。',
        animationDesc: '参考 PhET 建构原子：核内 p、n 数量，核外电子绕核；显示元素符号、质量数 A、电荷（中性/离子）。',
        realityPoint: '元素周期表、同位素、离子。',
        draw: drawBuildAtom
      },
      {
        id: 'capacitorLab',
        name: '电容器实验（平行板）',
        category: '电学',
        formula: 'C = \\varepsilon_0 \\frac{A}{d} \\quad Q = C U',
        formulaDetail: '平行板电容器电容 C = ε₀A/d，与极板面积 A 成正比、与板间距 d 成反比。充电后 Q = CU，板间为匀强电场。参考 PhET 电容器实验。',
        summary: '调节极板面积、板间距、电压，观察电容 C 与带电量 Q 的变化。面积越大、间距越小，C 越大；U 越大，Q 越大。',
        teachingPoints: [
          'C 只与几何和介质有关，与 Q、U 无关。',
          'Q = CU；充电后断开电源则 Q 不变，改变 d 会改变 U。',
          '板间电场 E = U/d，方向由正极指向负极。'
        ],
        sliders: [
          { id: 'area', label: '极板面积 (相对)', min: 0.3, max: 2, step: 0.1, value: 1, unit: '×' },
          { id: 'separation', label: '板间距 (相对)', min: 0.2, max: 1.2, step: 0.1, value: 0.5, unit: '×' },
          { id: 'voltage', label: '电压 U (V)', min: 0, max: 18, step: 1, value: 9, unit: 'V' }
        ],
        getDetails: (p) => `C∝A/d  Q=CU  U=${p.voltage || 9}V 调节 A、d 观察 C 与 Q`,
        practice: {
          prompt: '让电压 U 达到 12 V',
          unit: 'V',
          targets: [12],
          tolerance: 0.5,
          getCurrent: (p) => p.voltage || 9
        },
        extraPractice: [
          { prompt: '平行板电容 C 与面积 A、板间距 d 的关系？', answer: 'C ∝ A，C ∝ 1/d，即 C = ε₀A/d。' }
        ],
        textbook: '参考高中物理选修：平行板电容 C=ε₀A/d，与面积成正比、与间距成反比；Q=CU。PhET 电容器实验可直观调节 A、d、U。',
        animationDesc: '参考 PhET 电容器实验：两平行板、+/− 电荷分布，板间电场线；调节面积、间距、电压，观察 C 与 Q 变化。',
        realityPoint: '平行板电容、极板面积、板间距、Q=CV。',
        draw: drawCapacitorLab
      },
      {
        id: 'geometricOptics',
        name: '几何光学（透镜成像）',
        category: '光学',
        formula: '\\frac{1}{u} + \\frac{1}{v} = \\frac{1}{f} \\quad m = \\frac{v}{u} = \\frac{h\'}{h}',
        formulaDetail: '凸透镜三条特殊光线：平行于主光轴→过焦点；过光心→方向不变；过焦点→平行于主光轴。像距 v 由 1/u+1/v=1/f 求，放大率 m=v/u。',
        summary: '参考 PhET 几何光学：放置物体、调节物距与焦距，画三条光线确定像的位置与大小。实像倒立、虚像正立。',
        teachingPoints: [
          '一倍焦距分虚实，二倍焦距分大小。',
          '实像可成在光屏上，虚像与物同侧、正立放大。',
          '放大率 m = v/u = 像高/物高。'
        ],
        sliders: [
          { id: 'objDist', label: '物距 u (相对)', min: 40, max: 180, step: 10, value: 120, unit: '' },
          { id: 'focalLen', label: '焦距 f (相对)', min: 30, max: 90, step: 5, value: 60, unit: '' },
          { id: 'objHeight', label: '物高 h (相对)', min: 10, max: 40, step: 5, value: 25, unit: '' }
        ],
        getDetails: (p) => {
          const u = p.objDist || 120;
          const f = p.focalLen || 60;
          const v = u > f ? (u * f) / (u - f) : 0;
          return v > 0 ? `v=${v.toFixed(0)}  m=${(v/u).toFixed(2)}` : 'u≤f 成虚像';
        },
        practice: {
          prompt: '让像距 v 达到 90（物距与焦距配合）',
          unit: '',
          targets: [90],
          tolerance: 8,
          getCurrent: (p) => {
            const u = p.objDist || 120;
            const f = p.focalLen || 60;
            return u > f ? (u * f) / (u - f) : 0;
          }
        },
        extraPractice: [
          { prompt: '放大率 m = v/u 的物理意义？', answer: '像距与物距之比，等于像高与物高之比。' }
        ],
        textbook: '参考人教版《物理》八年级凸透镜成像：三条特殊光线作光路图，1/u+1/v=1/f，实像虚像、放大缩小与物距关系。PhET 几何光学可交互作图。',
        animationDesc: '参考 PhET 几何光学：物、透镜、三条特殊光线交于像点；标出 u、v、f 与放大率 m。',
        realityPoint: '照相机、投影仪、放大镜、光路图。',
        draw: drawGeometricOptics
      },
      { id: 'freeFall', name: '自由落体', category: '力学', formula: 'v = gt \\quad h = \\frac{1}{2}gt^2', formulaDetail: '初速为零、只受重力的匀加速直线运动。加速度 a = g ≈ 9.8 m/s²；瞬时速度 v = gt（与时间成正比）；下落高度 h = ½gt²（与 t² 成正比）。同一地点 g 与物体质量无关。', summary: '从静止下落的物体：时间 t 越大，速度 v 越大、下落高度 h 越大。刻度尺与轨迹直观显示 h、v 随 t 的变化。', teachingPoints: ['v = gt：1 秒末约 9.8 m/s，2 秒末约 19.6 m/s。', 'h = ½gt²：3 秒约下落 44 m。', '调节 t 观察小球位置与速度的对应关系。'], sliders: [{ id: 'timeFall', label: '下落时间 t (s)', min: 0.5, max: 4, step: 0.25, value: 2, unit: 's' }], getDetails: (p) => { const t = p.timeFall || 2; return `v=${(g*t).toFixed(1)} m/s  h=${(0.5*g*t*t).toFixed(1)} m`; }, practice: { prompt: '让 2 秒末速度接近 19.6 m/s', unit: 'm/s', targets: [19.6], tolerance: 0.5, getCurrent: (p) => g * (p.timeFall || 2) }, extraPractice: [{ prompt: '自由落体 3 秒下落多高？', answer: 'h = ½gt² ≈ 0.5×9.8×9 ≈ 44.1 m。' }], animationDesc: '带刻度尺的竖直下落：调节 t 看小球位置与轨迹，实时显示 v=gt、h=½gt²。', draw: drawFreeFall },
      { id: 'hooke', name: '胡克定律', category: '力学', formula: 'F = kx', formulaDetail: '在弹性限度内，弹簧弹力 F 与形变量 x（伸长或压缩量）成正比：F = kx。k 为劲度系数，单位 N/m，与材料、匝数、粗细有关。弹力方向与形变方向相反。', summary: '弹簧秤、缓冲器、减震器都遵循 F = kx。调节 k 或 x，弹簧伸长与弹力同步变化，直观体现正比关系。', teachingPoints: ['x 为相对自然长度的形变量。', 'k 大表示“硬”弹簧，相同 x 下 F 大。', '弹性限度内成立，超过则发生塑性形变。'], sliders: [{ id: 'k', label: '劲度系数 k (N/m)', min: 20, max: 100, step: 10, value: 50, unit: 'N/m' }, { id: 'x', label: '形变量 x (cm)', min: 0, max: 20, step: 1, value: 10, unit: 'cm' }], getDetails: (p) => `F = kx = ${((p.k || 50) * (p.x || 10) / 100).toFixed(1)} N`, practice: { prompt: '让弹力 F 达到 4 N', unit: 'N', targets: [4], tolerance: 0.3, getCurrent: (p) => (p.k || 50) * (p.x || 10) / 100 }, extraPractice: [{ prompt: '两根弹簧串联与并联，等效 k 如何？', answer: '串联 1/k = 1/k₁+1/k₂；并联 k = k₁+k₂。' }], animationDesc: '弹簧一端固定、一端挂物块：调节 x 弹簧伸长变化，调节 k 匝数变化，显示 F=kx。', draw: drawHooke },
      { id: 'power', name: '功率', category: '力学', formula: 'P = \\frac{W}{t} = Fv', formulaDetail: '功率 P 表示做功快慢，定义 P = W/t，单位瓦特(W)=焦耳/秒。当恒力 F 与速度 v 同向时，P = Fv：力大或速度快，功率都变大。汽车额定功率一定时，上坡需大 F 则 v 必减小。', summary: '同一辆车：拉力 F 大或速度 v 大，功率 P = Fv 就大。动画中小车移动速度随 v 变化，拉力箭头大小随 F 变化。', teachingPoints: ['P = Fv 仅当 F 与 v 同向时成立。', '额定功率下，F 与 v 成反比。', '调节 F、v 观察 P 与小车运动快慢。'], sliders: [{ id: 'forceP', label: '力 F (N)', min: 10, max: 100, step: 10, value: 50, unit: 'N' }, { id: 'velocity', label: '速度 v (m/s)', min: 0.5, max: 5, step: 0.5, value: 2, unit: 'm/s' }], getDetails: (p) => `P = Fv = ${((p.forceP || 50) * (p.velocity || 2)).toFixed(0)} W`, practice: { prompt: '让功率 P 达到 100 W', unit: 'W', targets: [100], tolerance: 8, getCurrent: (p) => (p.forceP || 50) * (p.velocity || 2) }, extraPractice: [{ prompt: '汽车上坡为什么要换低挡？', answer: 'P 一定时，F 与 v 成反比；低挡获得更大牵引力 F。' }], animationDesc: '水平面上受拉力的小车：F 大则拉力箭头大，v 大则小车移动快，P=Fv 实时显示。', draw: drawPower },
      { id: 'pendulum', name: '单摆周期', category: '力学', formula: 'T = 2\\pi\\sqrt{\\frac{L}{g}}', formulaDetail: '小角度（约 θ < 10°）单摆的周期 T = 2π√(L/g)：只与摆长 L 和重力加速度 g 有关，与摆球质量、振幅无关。摆越长 T 越大、摆动越慢；测 T、L 可反推 g。', summary: '摆钟利用单摆等时性。调节 L：摆长越长，周期 T 越大，动画中摆球摆动越慢，直观体现 T ∝ √L。', teachingPoints: ['T 与 √L 成正比，与 √g 成反比。', 'T 与质量 m、振幅 A 无关。', '调节 L 观察摆动快慢与周期数值。'], sliders: [{ id: 'lengthP', label: '摆长 L (m)', min: 0.5, max: 2, step: 0.1, value: 1, unit: 'm' }], getDetails: (p) => { const L = p.lengthP || 1; return `T = 2π√(L/g) ≈ ${(2*Math.PI*Math.sqrt(L/g)).toFixed(2)} s`; }, practice: { prompt: '让周期 T 达到 2.0 s', unit: 's', targets: [2], tolerance: 0.08, getCurrent: (p) => 2 * Math.PI * Math.sqrt((p.lengthP || 1) / g) }, extraPractice: [{ prompt: '单摆从赤道移到两极，周期如何变？', answer: 'g 增大，T 减小。' }], animationDesc: '单摆摆动：摆长 L 驱动绳长与周期，L 大则摆动慢、T 大，公式 T=2π√(L/g) 实时对应。', draw: drawPendulum },
      { id: 'totalReflection', name: '全反射', category: '光学', formula: '\\sin C = \\frac{n_2}{n_1} \\quad (n_1 > n_2)', formulaDetail: '光从光密介质（n₁ 大）射向光疏介质（n₂ 小）时，折射角大于入射角。当入射角等于临界角 C 时折射角为 90°；入射角 ≥ C 时发生全反射，无折射光。sin C = n₂/n₁。', summary: '光纤、潜水看水面、棱镜都用到全反射。调节 n₁、n₂ 可改变临界角 C；动画中画出临界方向与反射光路。', teachingPoints: ['仅当 n₁ > n₂ 时才有临界角。', 'n₁ 越大或 n₂ 越小，C 越小，越易全反射。', '调节 n₁、n₂ 观察 C 的数值变化。'], sliders: [{ id: 'n1', label: '入射介质 n₁', min: 1.3, max: 1.6, step: 0.1, value: 1.5, unit: '' }, { id: 'n2', label: '折射介质 n₂', min: 1, max: 1.3, step: 0.1, value: 1, unit: '' }], getDetails: (p) => { const n1 = p.n1 || 1.5, n2 = p.n2 || 1; const C = n1 > n2 ? Math.asin(n2/n1) * 180 / Math.PI : 90; return `临界角 C ≈ ${C.toFixed(1)}°`; }, practice: { prompt: '让临界角接近 42°', unit: '°', targets: [42], tolerance: 2, getCurrent: (p) => { const n1 = p.n1 || 1.5, n2 = p.n2 || 1; return n1 > n2 ? Math.asin(n2/n1) * 180 / Math.PI : 90; } }, extraPractice: [{ prompt: '为什么水中气泡看起来特别亮？', answer: '光从水进入气泡（空气）时可能发生全反射。' }], animationDesc: '光密→光疏界面：入射光、临界角方向与反射光；n₁、n₂ 改变时临界角 C 随之变化。', draw: drawTotalReflection },
      { id: 'resistivity', name: '电阻定律', category: '电学', formula: 'R = \\rho \\frac{L}{S}', formulaDetail: '均匀导体电阻 R = ρ·L/S：ρ 为电阻率（材料与温度），L 为长度，S 为横截面积。同材料下 R 与 L 成正比、与 S 成反比。', summary: '同材料导线：越长电阻越大，越细（S 小）电阻越大。动画中导线长度与粗细随 L、S 变化，直观体现 R ∝ L/S。', teachingPoints: ['ρ 与材料、温度有关；单位 Ω·m。', 'R ∝ L：长度加倍则 R 加倍。', 'R ∝ 1/S：截面积加倍则 R 减半。'], sliders: [{ id: 'lengthR', label: '长度 L (相对)', min: 0.5, max: 2, step: 0.25, value: 1, unit: '×' }, { id: 'areaS', label: '横截面积 S (相对)', min: 0.5, max: 2, step: 0.25, value: 1, unit: '×' }], getDetails: (p) => `R ∝ L/S = ${((p.lengthR || 1) / (p.areaS || 1)).toFixed(2)} (相对)`, practice: { prompt: '让 R 相对值达到 1.5', unit: '×', targets: [1.5], tolerance: 0.1, getCurrent: (p) => (p.lengthR || 1) / (p.areaS || 1) }, extraPractice: [{ prompt: '同样材料，细而长的导线与短而粗的导线，哪个电阻大？', answer: '细而长：L 大、S 小，R 大。' }], animationDesc: '导线长度 ∝ L、粗细 ∝ S：调节 L、S 观察导线形状变化，理解 R∝L、R∝1/S。', draw: drawResistivity },
      { id: 'conduction', name: '热传导', category: '热学', formula: 'Q = \\frac{\\lambda A \\Delta T}{d} t', formulaDetail: '稳态热传导：热流（单位时间传热）与导热系数 λ、面积 A、温差 ΔT 成正比，与厚度 d 成反比。傅里叶定律：热流 ∝ ΔT/d。保温要减小热流：选 λ 小或 d 大。', summary: '同一材料：温差大或墙薄则热流大；墙厚则热流小。动画中墙体厚度与温差可调，热流箭头数量体现 Φ ∝ ΔT/d。', teachingPoints: ['λ 单位 W/(m·K)；傅里叶定律热流 ∝ ΔT/d。', 'd 大或 λ 小则热流小，保温好。', '调节 ΔT、d 观察热流强弱变化。'], sliders: [{ id: 'tempDiff', label: '温差 ΔT (°C)', min: 10, max: 60, step: 5, value: 30, unit: '°C' }, { id: 'thickness', label: '厚度 d (相对)', min: 0.5, max: 2, step: 0.25, value: 1, unit: '×' }], getDetails: (p) => `热流 ∝ ΔT/d = ${((p.tempDiff || 30) / (p.thickness || 1)).toFixed(0)}`, practice: { prompt: '让热流强度（ΔT/d）达到 40', unit: '', targets: [40], tolerance: 3, getCurrent: (p) => (p.tempDiff || 30) / (p.thickness || 1) }, extraPractice: [{ prompt: '冬天为什么穿羽绒服保暖？', answer: '羽绒间有空气，导热差；等效 d 大、λ 小，热流小。' }], animationDesc: '墙体两侧温差 ΔT、厚度 d：热端→冷端温度渐变，热流箭头数量随 ΔT/d 变化。', draw: drawConduction },
      { id: 'workEnergy', name: '动能定理', category: '力学', formula: 'W_{合} = \\Delta E_k = \\frac{1}{2}mv^2 - \\frac{1}{2}mv_0^2', formulaDetail: '合外力对物体做的总功等于物体动能的变化：W_合 = ΔE_k = ½mv² − ½mv₀²。加速时 W>0 动能增加，减速时 W<0 动能减少。与路径无关，只与初、末速度有关。', summary: '初速 v₀、末速 v 决定动能变化 ΔE_k，合外力做功 W_合 = ΔE_k。动画中物块在轨道上，显示 E_k初、E_k末与 W。', teachingPoints: ['W_合 = E_k末 − E_k初，与路径无关。', 'W > 0 动能增加，W < 0 动能减少。', '调节 m、v₀、v 观察 W 与动能变化。'], sliders: [{ id: 'massW', label: '质量 m (kg)', min: 1, max: 5, step: 0.5, value: 2, unit: 'kg' }, { id: 'v0', label: '初速 v₀ (m/s)', min: 0, max: 10, step: 1, value: 0, unit: 'm/s' }, { id: 'vEnd', label: '末速 v (m/s)', min: 2, max: 12, step: 1, value: 6, unit: 'm/s' }], getDetails: (p) => { const m = p.massW || 2, v0 = p.v0 || 0, v = p.vEnd || 6; const W = 0.5 * m * (v*v - v0*v0); return `W_合 = ΔE_k = ${W.toFixed(1)} J`; }, practice: { prompt: '让合外力做功达到 36 J', unit: 'J', targets: [36], tolerance: 3, getCurrent: (p) => 0.5 * (p.massW || 2) * ((p.vEnd || 6)**2 - (p.v0 || 0)**2) }, extraPractice: [{ prompt: '刹车时动能去哪了？', answer: '摩擦力做负功，动能转化为内能（发热）。' }], animationDesc: '轨道上物块：初速 v₀、末速 v 对应 E_k初、E_k末，W=ΔE_k 实时显示，调节参数看变化。', draw: drawWorkEnergy },
      { id: 'impulse', name: '冲量', category: '力学', formula: 'I = F \\Delta t \\quad \\Delta p = F \\Delta t', formulaDetail: '冲量 I = F·Δt：力与作用时间的乘积，单位 N·s。冲量等于物体动量的变化：I = Δp。安全气囊、缓冲垫通过延长 Δt 减小平均力 F，从而减小冲击。', summary: '力 F 大或作用时间 Δt 大，冲量 I 就大，动量变化大。动画中力箭头大小体现 F，作用区间宽度体现 Δt，I=F·Δt 实时显示。', teachingPoints: ['I = Δp：冲量等于动量变化（动量定理）。', '缓冲：Δt 大则 F 小，I 不变。', '调节 F、Δt 观察 I 与图示变化。'], sliders: [{ id: 'forceI', label: '力 F (N)', min: 10, max: 100, step: 10, value: 50, unit: 'N' }, { id: 'dt', label: '作用时间 Δt (s)', min: 0.1, max: 1, step: 0.1, value: 0.5, unit: 's' }], getDetails: (p) => `I = FΔt = ${((p.forceI || 50) * (p.dt || 0.5)).toFixed(1)} N·s`, practice: { prompt: '让冲量 I 达到 30 N·s', unit: 'N·s', targets: [30], tolerance: 2, getCurrent: (p) => (p.forceI || 50) * (p.dt || 0.5) }, extraPractice: [{ prompt: '为什么跳高要垫厚垫子？', answer: '延长落地时间 Δt，减小地面对人的作用力 F。' }], animationDesc: '受力物体：力箭头大小 ∝ F，作用时间宽度 ∝ Δt，I=F·Δt 与图示对应。', draw: drawImpulse },
      { id: 'density', name: '密度', category: '流体与压强', formula: '\\rho = \\frac{m}{V}', formulaDetail: '密度 ρ = m/V，单位 kg/m³（或 g/cm³），表示单位体积的质量，是物质的特性。同体积下 ρ 大则质量大；同质量下 ρ 大则体积小。浮沉与 ρ_物、ρ_液 比较有关。', summary: 'ρ = m/V：质量大或体积小则密度大。动画中烧杯液高体现体积，浸入物块大小/颜色与密度关联，ρ 实时显示。', teachingPoints: ['ρ 与物质、状态、温度有关。', 'ρ_物 > ρ_液 下沉，ρ_物 < ρ_液 上浮。', '调节 m、V 观察 ρ 与物块表现。'], sliders: [{ id: 'massD', label: '质量 m (kg)', min: 0.5, max: 5, step: 0.5, value: 2, unit: 'kg' }, { id: 'volume', label: '体积 V (L)', min: 0.5, max: 5, step: 0.25, value: 2, unit: 'L' }], getDetails: (p) => `ρ = m/V = ${((p.massD || 2) / (p.volume || 2)).toFixed(2)} kg/L`, practice: { prompt: '让密度达到 1.0 kg/L（如纯水）', unit: 'kg/L', targets: [1], tolerance: 0.1, getCurrent: (p) => (p.massD || 2) / (p.volume || 2) }, extraPractice: [{ prompt: '冰能浮在水上，说明什么？', answer: 'ρ_冰 < ρ_水；水结冰时体积膨胀。' }], animationDesc: '烧杯液高 ∝ V，浸入物块：ρ=m/V 显示，物块大小/颜色与密度关联，调节 m/V 看变化。', draw: drawDensity }
    ];

    function drawFreeFall(ctx, w, h, params) {
      ctx.save();
      const t = params.timeFall || 2;
      const v = g * t;
      const y = 0.5 * g * t * t;
      const maxH = 0.5 * g * 16;
      const scaleY = (h * 0.65) / maxH;
      const originY = h * 0.12;
      const groundY = h * 0.88;
      const ballScreenY = originY + Math.min(y * scaleY / 2, groundY - originY - 24);
      ctx.fillStyle = '#b8d4f0';
      ctx.fillRect(0, 0, w, groundY);
      ctx.fillStyle = '#6b5344';
      ctx.fillRect(0, groundY, w, h - groundY);
      const rulerX = w * 0.5 + 55;
      for (let i = 0; i <= 80; i += 10) {
        const yy = originY + (i / 80) * (groundY - originY);
        ctx.strokeStyle = i % 20 === 0 ? '#2d3142' : '#7a8aa6';
        ctx.lineWidth = i % 20 === 0 ? 2 : 1;
        ctx.beginPath();
        ctx.moveTo(rulerX, yy);
        ctx.lineTo(rulerX + (i % 20 === 0 ? 18 : 10), yy);
        ctx.stroke();
        if (i % 20 === 0) {
          ctx.fillStyle = '#2d3142';
          ctx.font = '10px Poppins, sans-serif';
          ctx.fillText(`${(i * maxH / 80).toFixed(0)}m`, rulerX + 22, yy + 4);
        }
      }
      ctx.setLineDash([4, 4]);
      ctx.strokeStyle = 'rgba(0,0,0,0.25)';
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.moveTo(w * 0.5, originY);
      ctx.lineTo(w * 0.5, groundY);
      ctx.stroke();
      ctx.setLineDash([]);
      const trail = 6;
      for (let i = 1; i <= trail; i++) {
        const ti = Math.max(0, t - i * 0.15);
        const yi = 0.5 * g * ti * ti;
        const by = originY + Math.min(yi * scaleY / 2, groundY - originY - 24);
        ctx.fillStyle = `rgba(255,155,69,${0.15 * (1 - i / trail)})`;
        ctx.beginPath();
        ctx.arc(w * 0.5, by, 8, 0, Math.PI * 2);
        ctx.fill();
      }
      ctx.fillStyle = '#ff9b45';
      ctx.beginPath();
      ctx.arc(w * 0.5, ballScreenY, 14, 0, Math.PI * 2);
      ctx.fill();
      ctx.strokeStyle = '#c62828';
      ctx.lineWidth = 2;
      ctx.stroke();
      ctx.fillStyle = '#1f2a44';
      ctx.font = 'bold 13px Poppins, sans-serif';
      ctx.fillText(`t = ${t.toFixed(2)} s  →  v = gt = ${v.toFixed(1)} m/s`, 20, 28);
      ctx.fillText(`h = ½gt² = ${y.toFixed(1)} m  （调节 t 观察位置与速度）`, 20, 48);
      ctx.restore();
    }

    function drawHooke(ctx, w, h, params) {
      ctx.save();
      const k = params.k || 50;
      const xCm = params.x != null ? params.x : 10;
      const x = xCm / 100;
      const F = k * x;
      const cx = h * 0.5;
      const anchorX = 70;
      const naturalLen = 50;
      const stretchPx = 2.5 * xCm;
      const totalLen = naturalLen + stretchPx;
      const nCoils = 10 + Math.floor(k / 15);
      ctx.fillStyle = '#f0f4fa';
      ctx.fillRect(0, 0, w, h);
      ctx.fillStyle = '#5a6478';
      ctx.fillRect(anchorX - 10, cx - 6, 20, 100);
      ctx.strokeStyle = '#3d4556';
      ctx.lineWidth = 2;
      ctx.strokeRect(anchorX - 10, cx - 6, 20, 100);
      const coilW = 6;
      for (let i = 0; i < nCoils; i++) {
        const seg = totalLen / nCoils;
        const x0 = anchorX + 12 + i * seg;
        const x1 = anchorX + 12 + (i + 1) * seg;
        ctx.strokeStyle = i % 2 === 0 ? '#8a9bab' : '#6a7a8e';
        ctx.lineWidth = 4;
        ctx.beginPath();
        ctx.moveTo(x0, cx);
        ctx.lineTo(x1, cx + (i % 2 === 0 ? coilW : -coilW));
        ctx.stroke();
      }
      const blockX = anchorX + 12 + totalLen;
      ctx.fillStyle = '#ff9b45';
      ctx.fillRect(blockX - 8, cx - 28, 24, 56);
      ctx.strokeStyle = '#c62828';
      ctx.lineWidth = 2;
      ctx.strokeRect(blockX - 8, cx - 28, 24, 56);
      ctx.fillStyle = '#1f2a44';
      ctx.font = '11px Poppins, sans-serif';
      ctx.fillText('形变 x', blockX + 14, cx - 32);
      ctx.beginPath();
      ctx.moveTo(anchorX + 12, cx - 12);
      ctx.lineTo(blockX - 8, cx - 12);
      ctx.strokeStyle = '#c62828';
      ctx.lineWidth = 2;
      ctx.stroke();
      ctx.fillStyle = '#c62828';
      ctx.font = 'bold 14px Poppins, sans-serif';
      ctx.fillText(`F = kx = ${k}×${xCm/100} = ${F.toFixed(1)} N`, 24, 32);
      ctx.font = '12px Poppins, sans-serif';
      ctx.fillStyle = '#5a6478';
      ctx.fillText('调节 k 或 x：形变量 x 越大、k 越大，弹力 F 越大', 24, 52);
      ctx.restore();
    }

    function drawPower(ctx, w, h, params) {
      ctx.save();
      const F = params.forceP || 50;
      const v = params.velocity || 2;
      const P = F * v;
      const cy = h * 0.55;
      const baseSpeed = 12 + v * 18;
      const carX = 60 + (params.time || 0) * baseSpeed % (w - 140);
      ctx.fillStyle = '#e0eaf8';
      ctx.fillRect(0, 0, w, h);
      ctx.fillStyle = '#9ca8b8';
      ctx.fillRect(0, cy + 35, w, h - cy - 35);
      ctx.strokeStyle = '#7a8596';
      ctx.setLineDash([8, 8]);
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(0, cy + 38);
      ctx.lineTo(w, cy + 38);
      ctx.stroke();
      ctx.setLineDash([]);
      ctx.fillStyle = '#4c7be5';
      ctx.fillRect(carX, cy - 22, 70, 44);
      ctx.strokeStyle = '#2d3d6b';
      ctx.lineWidth = 2;
      ctx.strokeRect(carX, cy - 22, 70, 44);
      const arrowLen = 12 + F / 8;
      ctx.fillStyle = '#e65100';
      ctx.beginPath();
      ctx.moveTo(carX + 72, cy);
      ctx.lineTo(carX + 72 + arrowLen, cy - 6);
      ctx.lineTo(carX + 72 + arrowLen, cy + 6);
      ctx.closePath();
      ctx.fill();
      ctx.strokeStyle = '#bf360c';
      ctx.stroke();
      ctx.fillStyle = '#1f2a44';
      ctx.font = 'bold 13px Poppins, sans-serif';
      ctx.fillText(`P = F·v = ${F}×${v} = ${P.toFixed(0)} W`, 24, 28);
      ctx.font = '12px Poppins, sans-serif';
      ctx.fillText(`拉力 F↑ 或 速度 v↑ → 功率 P↑（小车移动速度随 v 变化）`, 24, 48);
      ctx.restore();
    }

    function drawPendulum(ctx, w, h, params) {
      ctx.save();
      const L = params.lengthP || 1;
      const T = 2 * Math.PI * Math.sqrt(L / g);
      const cx = w * 0.5;
      const topY = h * 0.14;
      const scale = 75;
      const angleMax = 0.35;
      const phase = (params.time || 0) * 2 * Math.PI / Math.max(T, 0.1);
      const angle = angleMax * Math.sin(phase);
      const bobX = cx + scale * L * Math.sin(angle);
      const bobY = topY + scale * L * Math.cos(angle);
      ctx.fillStyle = '#f0f4fa';
      ctx.fillRect(0, 0, w, h);
      ctx.fillStyle = '#5a6478';
      ctx.fillRect(cx - 20, topY - 8, 40, 16);
      ctx.strokeStyle = '#3d4556';
      ctx.lineWidth = 2;
      ctx.strokeRect(cx - 20, topY - 8, 40, 16);
      ctx.strokeStyle = '#4a5568';
      ctx.lineWidth = 3;
      ctx.beginPath();
      ctx.moveTo(cx, topY);
      ctx.lineTo(bobX, bobY);
      ctx.stroke();
      ctx.fillStyle = '#4c7be5';
      ctx.beginPath();
      ctx.arc(bobX, bobY, 14 + L * 2, 0, Math.PI * 2);
      ctx.fill();
      ctx.strokeStyle = '#2d3d6b';
      ctx.lineWidth = 2;
      ctx.stroke();
      ctx.fillStyle = '#1f2a44';
      ctx.font = 'bold 13px Poppins, sans-serif';
      ctx.fillText(`T = 2π√(L/g) = ${T.toFixed(2)} s  摆长 L = ${L} m`, 24, 28);
      ctx.font = '12px Poppins, sans-serif';
      ctx.fillText('调节 L：摆越长，周期 T 越大，摆动越慢', 24, 48);
      ctx.restore();
    }

    function drawTotalReflection(ctx, w, h, params) {
      ctx.save();
      const n1 = params.n1 || 1.5;
      const n2 = params.n2 || 1;
      const C = n1 > n2 ? Math.asin(n2 / n1) * 180 / Math.PI : 90;
      const mirrorY = h * 0.5;
      const cx = w * 0.5;
      ctx.fillStyle = 'rgba(80,150,220,0.35)';
      ctx.fillRect(0, 0, w, mirrorY);
      ctx.fillStyle = 'rgba(200,230,255,0.5)';
      ctx.fillRect(0, mirrorY, w, h - mirrorY);
      ctx.strokeStyle = 'rgba(76,123,229,0.6)';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(cx, 0);
      ctx.lineTo(cx, h);
      ctx.stroke();
      ctx.fillStyle = '#1f2a44';
      ctx.font = '11px Poppins, sans-serif';
      ctx.fillText('光密 n₁', cx - 50, mirrorY - 50);
      ctx.fillText('光疏 n₂', cx - 50, mirrorY + 60);
      const rayLen = 140;
      const toRad = (d) => d * Math.PI / 180;
      const drawRay = (angleDeg, color, fromY) => {
        const rad = toRad(angleDeg);
        const dx = rayLen * Math.sin(rad);
        const dy = rayLen * Math.cos(rad);
        ctx.strokeStyle = color;
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.moveTo(cx, fromY);
        ctx.lineTo(cx + dx, fromY - dy);
        ctx.stroke();
      };
      drawRay(C, '#e65100', mirrorY - 20);
      drawRay(C - 15, '#1565c0', mirrorY - 20);
      ctx.setLineDash([5, 5]);
      ctx.strokeStyle = 'rgba(0,0,0,0.4)';
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.moveTo(cx, mirrorY);
      ctx.lineTo(cx + 100, mirrorY - 80);
      ctx.stroke();
      ctx.setLineDash([]);
      ctx.fillStyle = '#1f2a44';
      ctx.font = 'bold 13px Poppins, sans-serif';
      ctx.fillText(`sin C = n₂/n₁ = ${n2}/${n1}  →  临界角 C ≈ ${C.toFixed(1)}°`, 24, 28);
      ctx.font = '12px Poppins, sans-serif';
      ctx.fillText('入射角 ≥ C 时全反射；调节 n₁、n₂ 观察 C 变化', 24, 48);
      ctx.restore();
    }

    function drawResistivity(ctx, w, h, params) {
      ctx.save();
      const L = params.lengthR || 1;
      const S = params.areaS || 1;
      const R = L / S;
      const cy = h * 0.5;
      const startX = 60;
      const wireLen = 80 + L * 120;
      const wireH = 6 + S * 10;
      ctx.fillStyle = '#f0f4fa';
      ctx.fillRect(0, 0, w, h);
      ctx.fillStyle = '#6a7a8e';
      ctx.fillRect(startX, cy - wireH / 2, wireLen, wireH);
      ctx.strokeStyle = '#4a5568';
      ctx.lineWidth = 2;
      ctx.strokeRect(startX, cy - wireH / 2, wireLen, wireH);
      ctx.fillStyle = '#1f2a44';
      ctx.font = '11px Poppins, sans-serif';
      ctx.fillText('L', startX + wireLen / 2 - 6, cy - wireH / 2 - 8);
      ctx.fillText('S', startX + wireLen + 8, cy + 4);
      ctx.fillStyle = '#c62828';
      ctx.font = 'bold 14px Poppins, sans-serif';
      ctx.fillText(`R = ρ·L/S  （相对）L/S = ${R.toFixed(2)}`, 24, 28);
      ctx.fillStyle = '#5a6478';
      ctx.font = '12px Poppins, sans-serif';
      ctx.fillText('L↑ 或 S↓ → R 增大；调节 L、S 观察导线长短与粗细', 24, 48);
      ctx.restore();
    }

    function drawConduction(ctx, w, h, params) {
      ctx.save();
      const dT = params.tempDiff || 30;
      const d = params.thickness || 1;
      const flux = dT / d;
      const leftX = w * 0.28;
      const rightX = w * 0.28 + 180 * d;
      const cy = h * 0.5;
      const wallH = 100;
      ctx.fillStyle = '#f8fafc';
      ctx.fillRect(0, 0, w, h);
      const grad = ctx.createLinearGradient(leftX, 0, rightX, 0);
      grad.addColorStop(0, `rgb(255,${Math.max(80, 180 - dT)},60)`);
      grad.addColorStop(0.5, `rgb(255,${200 - dT},120)`);
      grad.addColorStop(1, 'rgb(180,210,255)');
      ctx.fillStyle = grad;
      ctx.fillRect(leftX, cy - wallH / 2, rightX - leftX, wallH);
      ctx.strokeStyle = '#5a6478';
      ctx.lineWidth = 2;
      ctx.strokeRect(leftX, cy - wallH / 2, rightX - leftX, wallH);
      const nArrows = 3 + Math.min(Math.floor(flux / 15), 6);
      for (let i = 0; i < nArrows; i++) {
        const tx = leftX + (i + 1) * (rightX - leftX) / (nArrows + 1);
        ctx.fillStyle = `rgba(230,80,50,${0.3 + flux / 100})`;
        ctx.beginPath();
        ctx.moveTo(tx + 12, cy - 4);
        ctx.lineTo(tx, cy);
        ctx.lineTo(tx + 12, cy + 4);
        ctx.closePath();
        ctx.fill();
      }
      ctx.fillStyle = '#1f2a44';
      ctx.font = '11px Poppins, sans-serif';
      ctx.fillText('热端', leftX - 28, cy - 55);
      ctx.fillText('冷端', rightX + 8, cy - 55);
      ctx.fillText(`ΔT=${dT}°C`, leftX - 32, cy + 62);
      ctx.fillText(`d=${d}`, rightX + 6, cy + 62);
      ctx.font = 'bold 13px Poppins, sans-serif';
      ctx.fillText(`热流 ∝ ΔT/d = ${flux.toFixed(0)}   ΔT↑ 或 d↓ → 热流增强`, 24, 28);
      ctx.restore();
    }

    function drawWorkEnergy(ctx, w, h, params) {
      ctx.save();
      const m = params.massW || 2;
      const v0 = params.v0 || 0;
      const v = params.vEnd || 6;
      const Ek0 = 0.5 * m * v0 * v0;
      const Ek = 0.5 * m * v * v;
      const W = Ek - Ek0;
      const cy = h * 0.5;
      const trackY = cy + 20;
      const x0 = 80;
      const x1 = 280;
      const prog = 0.4 + 0.2 * Math.sin((params.time || 0) * 2);
      const blockX = x0 + (x1 - x0) * prog;
      ctx.fillStyle = '#e8ecf4';
      ctx.fillRect(0, 0, w, h);
      ctx.fillStyle = '#9ca8b8';
      ctx.fillRect(0, trackY - 8, w, 16);
      ctx.fillStyle = '#4c7be5';
      ctx.fillRect(blockX - 20, trackY - 28, 40, 56);
      ctx.strokeStyle = '#2d3d6b';
      ctx.lineWidth = 2;
      ctx.strokeRect(blockX - 20, trackY - 28, 40, 56);
      ctx.fillStyle = '#1f2a44';
      ctx.font = '11px Poppins, sans-serif';
      ctx.fillText(`v₀=${v0}`, x0 - 25, trackY - 35);
      ctx.fillText(`v=${v}`, x1 + 10, trackY - 35);
      ctx.font = 'bold 13px Poppins, sans-serif';
      ctx.fillText(`W_合 = ΔE_k = ½m(v²−v₀²) = ${W.toFixed(1)} J`, 24, 28);
      ctx.font = '12px Poppins, sans-serif';
      ctx.fillText(`E_k初 = ${Ek0.toFixed(1)} J  →  E_k末 = ${Ek.toFixed(1)} J  调节 m、v₀、v 观察`, 24, 48);
      ctx.restore();
    }

    function drawImpulse(ctx, w, h, params) {
      ctx.save();
      const F = params.forceI || 50;
      const dt = params.dt || 0.5;
      const I = F * dt;
      const cx = w * 0.5;
      const cy = h * 0.5;
      const boxW = 50;
      const arrowW = 8 + F / 12;
      const durationW = 40 + dt * 80;
      ctx.fillStyle = '#f0f4fa';
      ctx.fillRect(0, 0, w, h);
      ctx.fillStyle = '#8a9bab';
      ctx.fillRect(cx - boxW / 2 - durationW, cy - 30, boxW + durationW * 2, 60);
      ctx.strokeStyle = '#5a6478';
      ctx.lineWidth = 2;
      ctx.strokeRect(cx - boxW / 2 - durationW, cy - 30, boxW + durationW * 2, 60);
      ctx.fillStyle = '#4c7be5';
      ctx.fillRect(cx - boxW / 2, cy - 22, boxW, 44);
      ctx.strokeStyle = '#2d3d6b';
      ctx.strokeRect(cx - boxW / 2, cy - 22, boxW, 44);
      ctx.fillStyle = '#e65100';
      ctx.beginPath();
      ctx.moveTo(cx + boxW / 2 + 8, cy);
      ctx.lineTo(cx + boxW / 2 + 20 + arrowW, cy - arrowW);
      ctx.lineTo(cx + boxW / 2 + 20 + arrowW, cy + arrowW);
      ctx.closePath();
      ctx.fill();
      ctx.strokeStyle = '#bf360c';
      ctx.stroke();
      ctx.fillStyle = '#1f2a44';
      ctx.font = '11px Poppins, sans-serif';
      ctx.fillText('Δt', cx - 8, cy + 42);
      ctx.font = 'bold 13px Poppins, sans-serif';
      ctx.fillText(`I = F·Δt = ${F}×${dt} = ${I.toFixed(1)} N·s  （冲量=动量变化）`, 24, 28);
      ctx.font = '12px Poppins, sans-serif';
      ctx.fillText('F 大或 Δt 长 → I 大；缓冲即增大 Δt 减小 F', 24, 48);
      ctx.restore();
    }

    function drawDensity(ctx, w, h, params) {
      ctx.save();
      const m = params.massD || 2;
      const V = params.volume || 2;
      const rho = m / V;
      const cx = w * 0.5;
      const beakerBottom = h * 0.82;
      const beakerW = 70;
      const maxH = 120;
      const fillH = Math.min(V * 28, maxH);
      const liquidTop = beakerBottom - fillH;
      ctx.fillStyle = '#f0f4fa';
      ctx.fillRect(0, 0, w, h);
      ctx.strokeStyle = '#5a6478';
      ctx.lineWidth = 3;
      ctx.beginPath();
      ctx.moveTo(cx - beakerW / 2, liquidTop);
      ctx.lineTo(cx - beakerW / 2 + 10, beakerBottom);
      ctx.lineTo(cx + beakerW / 2 - 10, beakerBottom);
      ctx.lineTo(cx + beakerW / 2, liquidTop);
      ctx.closePath();
      ctx.stroke();
      const alpha = 0.25 + Math.min(rho / 2, 0.4);
      ctx.fillStyle = `rgba(76,123,229,${alpha})`;
      ctx.fill();
      const blockSize = 18 + Math.min(V * 4, 25);
      const blockY = beakerBottom - fillH / 2 - blockSize / 2;
      ctx.fillStyle = rho > 1 ? '#8b7355' : rho > 0.8 ? '#9a8b6a' : '#a8b878';
      ctx.fillRect(cx - blockSize / 2, blockY, blockSize, blockSize);
      ctx.strokeStyle = '#5a4a3a';
      ctx.strokeRect(cx - blockSize / 2, blockY, blockSize, blockSize);
      ctx.fillStyle = '#1f2a44';
      ctx.font = '11px Poppins, sans-serif';
      ctx.fillText('V', cx + beakerW / 2 + 10, beakerBottom - fillH / 2);
      ctx.font = 'bold 13px Poppins, sans-serif';
      ctx.fillText(`ρ = m/V = ${m}/${V} = ${rho.toFixed(2)} kg/L`, 24, 28);
      ctx.font = '12px Poppins, sans-serif';
      ctx.fillText('同体积 m↑→ρ↑；同质量 V↑→ρ↓  调节 m、V 观察', 24, 48);
      ctx.restore();
    }

    function drawPlaceholder(ctx, w, h, params) {
      const name = params.principleName || '本实验';
      ctx.save();
      const g = ctx.createLinearGradient(0, 0, 0, h);
      g.addColorStop(0, '#e8f0fe');
      g.addColorStop(1, '#f0f4fc');
      ctx.fillStyle = g;
      ctx.fillRect(0, 0, w, h);
      ctx.fillStyle = '#4c7be5';
      ctx.font = 'bold 22px Poppins, sans-serif';
      ctx.textAlign = 'center';
      ctx.fillText(name, w / 2, h / 2 - 24);
      ctx.fillStyle = '#62729d';
      ctx.font = '14px Poppins, sans-serif';
      ctx.fillText('动画与实景描述请点击「课本讲解」', w / 2, h / 2 + 12);
      ctx.fillText('查看 动画交互描述 与 现实结合点', w / 2, h / 2 + 36);
      ctx.textAlign = 'left';
      ctx.restore();
    }

    const learningNodes = [
      { id: 'path-mech', label: '力学基础', principles: ['newton', 'freeFall', 'hooke', 'friction', 'lever', 'pulley', 'power', 'pendulum', 'workEnergy', 'impulse', 'circular', 'projectile', 'mechanicalEnergy'] },
      { id: 'path-mech-energy', label: '机械能', principles: ['energy', 'mechanicalEnergy'] },
      { id: 'path-fluid', label: '流体与压强', principles: ['buoyancy', 'pressure', 'solidPressure'] },
      { id: 'path-energy', label: '热与能量', principles: ['energyFlow', 'specificHeat'] },
      { id: 'path-wave', label: '振动与波', principles: ['harmonic', 'wave', 'doppler'] },
      { id: 'path-optics', label: '几何光学', principles: ['reflection', 'refraction', 'totalReflection', 'lens', 'geometricOptics'] },
      { id: 'path-electric', label: '电路入门', principles: ['ohm', 'series', 'parallel', 'resistivity', 'capacitor', 'capacitorLab', 'fuse', 'joule'] },
      { id: 'path-charge', label: '静电与场', principles: ['coulomb'] },
      { id: 'path-magnet', label: '电磁与磁', principles: ['ampere', 'magnetic', 'induction'] },
      { id: 'path-modern', label: '近代物理', principles: ['photoelectric', 'buildAtom', 'atomicLevel', 'fission'] },
      { id: 'path-astro', label: '天文与宇宙', principles: ['gravityOrbit', 'blackHole'] },
      { id: 'path-app', label: '综合应用', principles: ['hydroPower', 'eddyCurrent'] },
      { id: 'path-thermal', label: '热学', principles: ['specificHeat', 'conduction', 'thermal'] },
      { id: 'path-fluid', label: '流体与压强', principles: ['pressure', 'buoyancy', 'density', 'solidPressure'] }
    ];

    const categoryOrder = ['力学', '流体与压强', '光学', '电学', '静电学', '波动与声', '热学', '电磁与现代物理', '近代物理', '天文与宇宙', '综合应用'];

    const canvas = document.getElementById('principleCanvas');
    const ctx = canvas.getContext('2d');
    const outlineContainer = document.getElementById('outlineContainer');
    const sliderContainer = document.getElementById('sliderControls');
    const titleEl = document.getElementById('visualTitle');
    const badgeEl = document.getElementById('visualBadge');
    const summaryText = document.getElementById('summaryText');
    const formulaText = document.getElementById('formulaText');
    const randomBtn = document.getElementById('randomBtn');
    const soundBtn = document.getElementById('soundToggle');
    const pathContainer = document.getElementById('learningPath');
    const practicePrompt = document.getElementById('practicePrompt');
    const practiceStatus = document.getElementById('practiceStatus');
    const practiceValue = document.getElementById('practiceValue');
    const practiceRing = document.getElementById('practiceRing');
    const practiceReset = document.getElementById('practiceReset');
    const practiceExplain = document.getElementById('practiceExplain');
    const practiceProgressWrap = document.getElementById('practiceProgressWrap');
    const practiceProgressFill = document.getElementById('practiceProgressFill');
    const practiceProgressText = document.getElementById('practiceProgressText');
    const practiceHasTask = document.getElementById('practiceHasTask');
    const practiceNoTask = document.getElementById('practiceNoTask');
    const navToggle = document.getElementById('navToggle');
    const sidebar = document.querySelector('.sidebar');
    const sidebarOverlay = document.getElementById('sidebarOverlay');
    const sidebarClose = document.getElementById('sidebarClose');
    const textbookBtn = document.getElementById('textbookBtn');
    const textbookModal = document.getElementById('textbookModal');
    const textbookContent = document.getElementById('textbookContent');
    const textbookClose = document.getElementById('textbookClose');
    const morePracticeBtn = document.getElementById('morePracticeBtn');
    const morePracticeModal = document.getElementById('morePracticeModal');
    const morePracticeContent = document.getElementById('morePracticeContent');
    const morePracticeClose = document.getElementById('morePracticeClose');

    let currentPrinciple = null;
    let currentParams = {};
    let animationTime = 0;
    const practiceTargets = {};

    function renderOutline() {
      outlineContainer.innerHTML = '';
      const grouped = {};
      principles.forEach((p) => {
        if (!grouped[p.category]) grouped[p.category] = [];
        grouped[p.category].push(p);
      });
      categoryOrder.forEach((cat) => {
        if (!grouped[cat]) return;
        const groupEl = document.createElement('div');
        groupEl.className = 'outline-group';
        const header = document.createElement('button');
        header.className = 'outline-group-header';
        header.innerHTML = `<span><i class="fa-solid fa-caret-down"></i>${cat}</span><i class="fa-solid fa-angles-down"></i>`;
        header.addEventListener('click', () => groupEl.classList.toggle('collapsed'));
        const list = document.createElement('div');
        list.className = 'outline-items';
        grouped[cat].forEach((principle) => {
          const item = document.createElement('button');
          item.className = 'outline-item';
          item.textContent = principle.name;
          item.dataset.id = principle.id;
          item.addEventListener('click', () => {
            setActivePrinciple(principle.id);
            closeSidebarOnMobile();
          });
          list.appendChild(item);
        });
        groupEl.appendChild(header);
        groupEl.appendChild(list);
        outlineContainer.appendChild(groupEl);
      });
    }

    function renderLearningPath() {
      pathContainer.innerHTML = '';
      learningNodes.forEach((node, index) => {
        const btn = document.createElement('button');
        btn.className = 'path-node';
        btn.dataset.nodeId = node.id;
        btn.textContent = node.label;
        btn.addEventListener('click', () => {
          if (node.principles.length) {
            setActivePrinciple(node.principles[0]);
            closeSidebarOnMobile();
          }
        });
        pathContainer.appendChild(btn);
        if (index < learningNodes.length - 1) {
          const arrow = document.createElement('i');
          arrow.className = 'fa-solid fa-arrow-right path-arrow';
          pathContainer.appendChild(arrow);
        }
      });
    }

    function highlightOutline(id) {
      document.querySelectorAll('.outline-item').forEach((btn) => {
        btn.classList.toggle('active', btn.dataset.id === id);
      });
    }

    function highlightPath(id) {
      learningNodes.forEach((node) => {
        const btn = document.querySelector(`[data-node-id="${node.id}"]`);
        if (!btn) return;
        btn.classList.toggle('active', node.principles.includes(id));
      });
    }

    function formatSliderValue(slider, value) {
      const decimals = slider.step && slider.step < 1 ? 2 : 0;
      return `${value.toFixed(decimals)} ${slider.unit || ''}`.trim();
    }

    function renderSliders(principle) {
      sliderContainer.innerHTML = '';
      (principle.sliders || []).forEach((slider) => {
        const wrapper = document.createElement('label');
        wrapper.className = 'slider-control';
        const title = document.createElement('span');
        title.textContent = slider.label;
        const input = document.createElement('input');
        input.type = 'range';
        input.min = slider.min;
        input.max = slider.max;
        input.step = slider.step || 1;
        input.value = slider.value;
        const numberInput = document.createElement('input');
        numberInput.type = 'number';
        numberInput.min = slider.min;
        numberInput.max = slider.max;
        numberInput.step = slider.step || 1;
        numberInput.value = slider.value;
        const valueEl = document.createElement('div');
        valueEl.className = 'slider-value';
        currentParams[slider.id] = Number(slider.value);
        valueEl.textContent = formatSliderValue(slider, Number(slider.value));
        const syncValue = (val) => {
          currentParams[slider.id] = val;
          valueEl.textContent = formatSliderValue(slider, val);
          numberInput.value = val;
          input.value = val;
          updateInfo();
        };
        input.addEventListener('input', (e) => {
          syncValue(parseFloat(e.target.value));
        });
        numberInput.addEventListener('input', (e) => {
          const val = parseFloat(e.target.value);
          if (isNaN(val)) return;
          syncValue(clamp(val, slider.min, slider.max));
        });
        const row = document.createElement('div');
        row.className = 'slider-input-row';
        row.appendChild(input);
        row.appendChild(numberInput);
        wrapper.appendChild(title);
        wrapper.appendChild(row);
        wrapper.appendChild(valueEl);
        if (slider.ticks && Array.isArray(slider.ticks) && slider.ticks.length) {
          const ticksWrap = document.createElement('div');
          ticksWrap.className = 'slider-ticks';
          const min = slider.min;
          const max = slider.max;
          slider.ticks.forEach((tickVal) => {
            const span = document.createElement('span');
            span.className = 'slider-tick';
            span.textContent = `${tickVal}${slider.unit ? slider.unit : ''}`;
            span.style.left = `${((tickVal - min) / (max - min)) * 100}%`;
            ticksWrap.appendChild(span);
          });
          wrapper.appendChild(ticksWrap);
        }
        sliderContainer.appendChild(wrapper);
      });
      updateInfo();
    }

    function ensurePracticeTarget(principle) {
      if (!principle.practice) return null;
      if (!practiceTargets[principle.id]) {
        const targets = principle.practice.targets;
        const target = targets[Math.floor(Math.random() * targets.length)];
        practiceTargets[principle.id] = target;
      }
      return practiceTargets[principle.id];
    }

    function rerollPracticeTarget() {
      if (!currentPrinciple || !currentPrinciple.practice) return;
      const targets = currentPrinciple.practice.targets;
      practiceTargets[currentPrinciple.id] = targets[Math.floor(Math.random() * targets.length)];
      updatePractice();
    }

    function explainPractice() {
      if (!currentPrinciple) return;
      const tips = currentPrinciple.teachingPoints || [];
      const lines = tips.length ? tips.map((t, i) => `${i + 1}. ${t}`).join('\n') : currentPrinciple.summary;
      alert(`教学提示\n————————\n${lines}`);
    }

    function getDefaultExtraPractice(principle) {
      const name = principle.name || '';
      const formula = principle.formula || '';
      return [
        { prompt: `根据「${name}」公式 ${formula}，试写出各物理量的单位。`, answer: '结合教材中该节的单位说明作答，注意国际单位制。' },
        { prompt: `举一个生活中的例子说明「${name}」的应用。`, answer: '参考本页「知识总结」与「教学提示」中的实例作答。' },
        { prompt: `若公式中某一量增大而其他量不变，结果会如何变化？请简要说明。`, answer: '根据公式中该量所处位置（分子或分母）判断正比或反比关系。' }
      ];
    }

    function updatePractice() {
      if (!currentPrinciple) return;
      if (!currentPrinciple.practice) {
        if (practiceHasTask) practiceHasTask.style.display = 'none';
        if (practiceNoTask) {
          practiceNoTask.style.display = 'block';
          practiceNoTask.textContent = '本模块暂无可视化练习，请通过调节滑块探索规律。';
        }
        return;
      }
      if (practiceHasTask) practiceHasTask.style.display = '';
      if (practiceNoTask) practiceNoTask.style.display = 'none';
      const practice = currentPrinciple.practice;
      const target = ensurePracticeTarget(currentPrinciple);
      const current = practice.getCurrent(currentParams);
      const tolerance = practice.tolerance;
      let diff;
      if (practice.type === 'difference') {
        diff = Math.abs(current);
      } else {
        diff = Math.abs(current - target);
      }
      const progressBase = practice.type === 'difference'
        ? Math.max(tolerance * 3, 1)
        : Math.max(Math.abs(target), tolerance * 4);
      const ratio = clamp(1 - diff / progressBase, 0, 1);
      const circumference = 2 * Math.PI * 34;
      practiceRing.style.strokeDasharray = circumference;
      practiceRing.style.strokeDashoffset = circumference * (1 - ratio);
      practiceValue.textContent = `${Math.round(ratio * 100)}%`;
      const formattedCurrent = practice.format ? practice.format(current) : `${current.toFixed(2)} ${practice.unit || ''}`.trim();
      const formattedDiff = practice.unit ? `${diff.toFixed(2)} ${practice.unit}` : diff.toFixed(2);
      const targetDisplay = practice.type === 'difference'
        ? (practice.targetLabel || `≈0 ${practice.unit || ''}`.trim())
        : `${practice.format ? practice.format(target) : `${target} ${practice.unit || ''}`.trim()}`;
      practicePrompt.textContent = `${practice.prompt} (目标：${targetDisplay})`;
      const success = diff <= tolerance;
      if (success) {
        practiceStatus.textContent = `完成！当前 ${formattedCurrent} 已满足目标要求，继续挑战新的目标吧。`;
        practiceStatus.style.color = '#2da44e';
        practiceRing.style.stroke = '#2da44e';
      } else {
        practiceStatus.textContent = `当前：${formattedCurrent}，与目标差≈${formattedDiff}，继续微调滑块。`;
        practiceStatus.style.color = '#56618a';
        const ratioForColor = clamp(ratio, 0, 1);
        if (currentPrinciple.id === 'parallel') {
          practiceRing.style.stroke = ratioForColor >= 0.8 ? '#2da44e' : ratioForColor >= 0.5 ? '#e67700' : '#c62828';
        } else {
          practiceRing.style.stroke = '';
        }
      }
      const isParallel = currentPrinciple && currentPrinciple.id === 'parallel';
      if (practiceProgressWrap) {
        practiceProgressWrap.style.display = isParallel && practice ? 'block' : 'none';
      }
      if (isParallel && practice && practiceProgressFill && practiceProgressText) {
        practiceProgressFill.style.width = `${Math.round(ratio * 100)}%`;
        practiceProgressFill.style.background = ratio >= 0.8 ? 'linear-gradient(90deg, #81c784, #2da44e)' : ratio >= 0.5 ? 'linear-gradient(90deg, #ffb74d, #e67700)' : 'linear-gradient(90deg, #e57373, #c62828)';
        if (success) {
          practiceProgressText.textContent = '已达成目标电流！';
        } else {
          const gap = Math.abs(target - current);
          practiceProgressText.textContent = `还差 ${gap.toFixed(2)} A`;
        }
      }
    }

    function updateInfo() {
      if (!currentPrinciple) return;
      const detail = currentPrinciple.getDetails ? currentPrinciple.getDetails(currentParams) : '';
      const teachList = currentPrinciple.teachingPoints && currentPrinciple.teachingPoints.length
        ? `<ul class="teach-list">${currentPrinciple.teachingPoints.map((t) => `<li>${t}</li>`).join('')}</ul>`
        : '';
      const detailHtml = detail ? `<span class="detail-extra">${detail}</span>` : '';
      summaryText.innerHTML = `<p class="summary-main">${currentPrinciple.summary}</p>${teachList}${detailHtml}`;
      const formulaDetail = currentPrinciple.formulaDetail || '';
      const formulaSteps = currentPrinciple.formulaSteps && currentPrinciple.formulaSteps.length
        ? `<ul class="formula-extras">${currentPrinciple.formulaSteps.map((step) => `<li>${step}</li>`).join('')}</ul>`
        : '';
      if (currentPrinciple.id === 'parallel') {
        const r1 = currentParams.r1 != null ? currentParams.r1 : 20;
        const r2 = currentParams.r2 != null ? currentParams.r2 : 30;
        const u = currentParams.voltage != null ? currentParams.voltage : 6;
        const invR = 1 / r1 + 1 / r2;
        const rTotal = 1 / invR;
        const i1 = u / r1;
        const i2 = u / r2;
        const iTotal = i1 + i2;
        let parallelFormulaHtml = '';
        if (typeof window.katex !== 'undefined') {
          try {
            const s1 = document.createElement('span');
            s1.className = 'formula-line';
            window.katex.render('\\frac{1}{R_{\\text{总}}} = \\frac{1}{R_1} + \\frac{1}{R_2}', s1, { throwOnError: false, displayMode: true });
            const s2 = document.createElement('span');
            s2.className = 'formula-line';
            window.katex.render('I_{\\text{总}} = I_1 + I_2', s2, { throwOnError: false, displayMode: true });
            parallelFormulaHtml = s1.outerHTML + s2.outerHTML;
          } catch (e) { parallelFormulaHtml = '<span class="formula-line">1/R总 = 1/R₁ + 1/R₂，I总 = I₁ + I₂</span>'; }
        } else {
          parallelFormulaHtml = '<span class="formula-line">1/R总 = 1/R₁ + 1/R₂，I总 = I₁ + I₂</span>';
        }
        const derivation = `<div class="formula-derivation">
          <p>1/R<sub>总</sub> = 1/R<sub>1</sub> + 1/R<sub>2</sub> = 1/<span class="r1">${r1}</span> + 1/<span class="r2">${r2}</span> = ${(1/r1).toFixed(3)} + ${(1/r2).toFixed(3)} = ${invR.toFixed(4)} → R<sub>总</sub>≈<strong>${rTotal.toFixed(1)} Ω</strong></p>
          <p>I<sub>总</sub> = I<sub>1</sub> + I<sub>2</sub> = <span class="u">${u}</span>/<span class="r1">${r1}</span> + <span class="u">${u}</span>/<span class="r2">${r2}</span> = ${i1.toFixed(2)} + ${i2.toFixed(2)} = <strong>${iTotal.toFixed(2)} A</strong></p>
          <p class="formula-detail">R₁ 对应红色、R₂ 对应蓝色、U 对应绿色，与滑块联动。</p>
        </div>`;
        formulaText.innerHTML = `<div class="formula-main math-text">${parallelFormulaHtml}</div>${derivation}${formulaSteps}`;
      } else {
        let formulaMainHtml = '';
        const raw = currentPrinciple.formula;
        const formulas = Array.isArray(raw) ? raw : (raw ? [raw] : []);
        if (typeof window.katex !== 'undefined' && formulas.length) {
          formulaMainHtml = formulas.map((latex) => {
            try {
              const span = document.createElement('span');
              span.className = 'formula-line';
              window.katex.render(latex, span, { throwOnError: false, displayMode: true });
              return span.outerHTML;
            } catch (e) {
              return `<span class="formula-line">${formatFormula(latex)}</span>`;
            }
          }).join('');
        }
        if (!formulaMainHtml && raw) formulaMainHtml = `<span class="formula-line">${formatFormula(Array.isArray(raw) ? raw.join(' ') : raw)}</span>`;
        formulaText.innerHTML = `<div class="formula-main math-text">${formulaMainHtml}</div><p class="formula-detail">${formulaDetail}</p>${formulaSteps}`;
      }
      updatePractice();
    }

    function setActivePrinciple(id) {
      const principle = principles.find((p) => p.id === id);
      if (!principle) return;
      currentPrinciple = principle;
      currentParams = {};
      titleEl.textContent = principle.name;
      badgeEl.innerHTML = `<i class="fa-solid fa-layer-group"></i> ${principle.category}`;
      renderSliders(principle);
      highlightOutline(id);
      highlightPath(id);
      updateCanvas();
    }

    function updateCanvas() {
      if (!currentPrinciple) return;
      const ratio = window.devicePixelRatio || 1;
      const displayWidth = canvas.clientWidth;
      const displayHeight = canvas.clientHeight;
      if (canvas.width !== displayWidth * ratio || canvas.height !== displayHeight * ratio) {
        canvas.width = displayWidth * ratio;
        canvas.height = displayHeight * ratio;
      }
      ctx.setTransform(ratio, 0, 0, ratio, 0, 0);
      ctx.clearRect(0, 0, displayWidth, displayHeight);
      ctx.fillStyle = '#f3f9ff';
      ctx.fillRect(0, 0, displayWidth, displayHeight);
      const drawParams = Object.assign({}, currentParams, { time: animationTime / 1000, principleName: currentPrinciple.name });
      currentPrinciple.draw(ctx, displayWidth, displayHeight, drawParams);
      const signature = computeAudioSignature(currentPrinciple.id, drawParams);
      audioEngine.update(signature);
    }

    function animate(time) {
      animationTime = time;
      updateCanvas();
      requestAnimationFrame(animate);
    }

    randomBtn.addEventListener('click', () => {
      randomBtn.classList.add('active');
      setTimeout(() => randomBtn.classList.remove('active'), 400);
      const pick = principles[Math.floor(Math.random() * principles.length)];
      setActivePrinciple(pick.id);
    });
    soundBtn.addEventListener('click', () => {
      const next = !audioEngine.isEnabled();
      audioEngine.setEnabled(next);
      updateSoundButton();
    });

    practiceReset.addEventListener('click', rerollPracticeTarget);
    practiceExplain.addEventListener('click', explainPractice);
    textbookBtn.addEventListener('click', () => {
      if (!currentPrinciple) return;
      textbookContent.innerHTML = buildTextbookContent(currentPrinciple);
      textbookModal.classList.add('open');
    });
    textbookClose.addEventListener('click', closeTextbookModal);
    textbookModal.addEventListener('click', (event) => {
      if (event.target === textbookModal) closeTextbookModal();
    });
    morePracticeBtn.addEventListener('click', () => {
      if (!currentPrinciple) return;
      const list = currentPrinciple.extraPractice || getDefaultExtraPractice(currentPrinciple);
      morePracticeContent.innerHTML = list.length
        ? list.map((item, i) => `<div class="extra-practice-item"><div class="prompt">${i + 1}. ${escapeHTML(item.prompt || '')}</div><div class="answer">${escapeHTML(item.answer || '')}</div></div>`).join('')
        : '<p class="formula-detail">暂无更多练习题，请使用上方「重新出题」完成当前练习。</p>';
      morePracticeModal.classList.add('open');
    });
    morePracticeClose.addEventListener('click', () => morePracticeModal.classList.remove('open'));
    morePracticeModal.addEventListener('click', (e) => { if (e.target === morePracticeModal) morePracticeModal.classList.remove('open'); });
    window.addEventListener('resize', () => {
      updateCanvas();
      if (window.innerWidth > MOBILE_BREAKPOINT) {
        sidebar.classList.remove('open');
        sidebarOverlay.classList.remove('active');
      } else {
        document.body.classList.remove('nav-collapsed');
      }
      updateNavToggleIcon();
    });
    navToggle.addEventListener('click', () => {
      if (window.innerWidth <= MOBILE_BREAKPOINT) {
        const open = sidebar.classList.toggle('open');
        sidebarOverlay.classList.toggle('active', open);
      } else {
        document.body.classList.toggle('nav-collapsed');
      }
      updateNavToggleIcon();
    });
    sidebarOverlay.addEventListener('click', closeSidebarOnMobile);
    sidebarClose.addEventListener('click', collapseSidebar);

    function closeSidebarOnMobile() {
      if (window.innerWidth <= MOBILE_BREAKPOINT && sidebar.classList.contains('open')) {
        sidebar.classList.remove('open');
        sidebarOverlay.classList.remove('active');
        updateNavToggleIcon();
      }
    }

    function collapseSidebar() {
      if (window.innerWidth <= MOBILE_BREAKPOINT) {
        sidebar.classList.remove('open');
        sidebarOverlay.classList.remove('active');
      } else {
        document.body.classList.add('nav-collapsed');
      }
      updateNavToggleIcon();
    }

    function updateNavToggleIcon() {
      if (window.innerWidth <= MOBILE_BREAKPOINT) {
        navToggle.innerHTML = sidebar.classList.contains('open')
          ? '<i class="fa-solid fa-xmark"></i>'
          : '<i class="fa-solid fa-bars"></i>';
      } else {
        navToggle.innerHTML = document.body.classList.contains('nav-collapsed')
          ? '<i class="fa-solid fa-bars"></i>'
          : '<i class="fa-solid fa-angles-left"></i>';
      }
    }

    function updateSoundButton() {
      const enabled = audioEngine.isEnabled();
      soundBtn.classList.toggle('active', enabled);
      soundBtn.innerHTML = enabled
        ? '<i class="fa-solid fa-volume-high"></i> 声音开'
        : '<i class="fa-solid fa-volume-xmark"></i> 声音关';
    }

    function closeTextbookModal() {
      textbookModal.classList.remove('open');
    }

    function buildTextbookContent(principle) {
      const lines = [];
      if (principle.summary) lines.push(`<p><strong>概念：</strong>${principle.summary}</p>`);
      if (principle.formulaDetail) lines.push(`<p><strong>公式解析：</strong>${principle.formulaDetail}</p>`);
      if (principle.teachingPoints && principle.teachingPoints.length) {
        lines.push('<p><strong>课本要点：</strong></p><ul>' +
          principle.teachingPoints.map((p) => `<li>${p}</li>`).join('') +
          '</ul>');
      }
      if (principle.animationDesc) {
        lines.push('<p><strong>🎬 动画与实景描述：</strong></p><p class="animation-desc">' + principle.animationDesc + '</p>');
      }
      if (principle.realityPoint) {
        lines.push('<p><strong>📍 现实结合点：</strong></p><p>' + principle.realityPoint + '</p>');
      }
      if (principle.textbook) {
        lines.push(`<p><strong>课本参考：</strong>${principle.textbook}</p>`);
      }
      return lines.join('') || '<p>该内容暂未提供课本描述。</p>';
    }

    updateNavToggleIcon();
    updateSoundButton();
    renderOutline();
    renderLearningPath();
    setActivePrinciple('newton');
    requestAnimationFrame(animate);
  </script>
</body>
</html>
